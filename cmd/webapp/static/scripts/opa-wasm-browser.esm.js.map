{
  "version": 3,
  "sources": ["../src/builtins/json.js", "../node_modules/sprintf-js/src/sprintf.js", "../src/builtins/strings.js", "../src/builtins/regex.js", "../node_modules/yaml/dist/PlainValue-ec8e588e.js", "../node_modules/yaml/dist/parse-cst.js", "../node_modules/yaml/dist/resolveSeq-d03cb037.js", "../node_modules/yaml/dist/warnings-1000a372.js", "../node_modules/yaml/dist/Schema-88e323a7.js", "../node_modules/yaml/dist/Document-9b4560a1.js", "../node_modules/yaml/dist/index.js", "../node_modules/yaml/index.js", "../src/builtins/yaml.js", "../src/builtins/index.js", "../src/opa.js"],
  "sourcesContent": ["function isValidJSON(str) {\n  if (typeof str !== \"string\") {\n    return;\n  }\n  try {\n    JSON.parse(str);\n    return true;\n  } catch (err) {\n    if (err instanceof SyntaxError) {\n      return false;\n    }\n    throw err;\n  }\n}\n\nmodule.exports = {\n  \"json.is_valid\": isValidJSON,\n};\n", "/* global window, exports, define */\n\n!function() {\n    'use strict'\n\n    var re = {\n        not_string: /[^s]/,\n        not_bool: /[^t]/,\n        not_type: /[^T]/,\n        not_primitive: /[^v]/,\n        number: /[diefg]/,\n        numeric_arg: /[bcdiefguxX]/,\n        json: /[j]/,\n        not_json: /[^j]/,\n        text: /^[^\\x25]+/,\n        modulo: /^\\x25{2}/,\n        placeholder: /^\\x25(?:([1-9]\\d*)\\$|\\(([^)]+)\\))?(\\+)?(0|'[^$])?(-)?(\\d+)?(?:\\.(\\d+))?([b-gijostTuvxX])/,\n        key: /^([a-z_][a-z_\\d]*)/i,\n        key_access: /^\\.([a-z_][a-z_\\d]*)/i,\n        index_access: /^\\[(\\d+)\\]/,\n        sign: /^[+-]/\n    }\n\n    function sprintf(key) {\n        // `arguments` is not an array, but should be fine for this call\n        return sprintf_format(sprintf_parse(key), arguments)\n    }\n\n    function vsprintf(fmt, argv) {\n        return sprintf.apply(null, [fmt].concat(argv || []))\n    }\n\n    function sprintf_format(parse_tree, argv) {\n        var cursor = 1, tree_length = parse_tree.length, arg, output = '', i, k, ph, pad, pad_character, pad_length, is_positive, sign\n        for (i = 0; i < tree_length; i++) {\n            if (typeof parse_tree[i] === 'string') {\n                output += parse_tree[i]\n            }\n            else if (typeof parse_tree[i] === 'object') {\n                ph = parse_tree[i] // convenience purposes only\n                if (ph.keys) { // keyword argument\n                    arg = argv[cursor]\n                    for (k = 0; k < ph.keys.length; k++) {\n                        if (arg == undefined) {\n                            throw new Error(sprintf('[sprintf] Cannot access property \"%s\" of undefined value \"%s\"', ph.keys[k], ph.keys[k-1]))\n                        }\n                        arg = arg[ph.keys[k]]\n                    }\n                }\n                else if (ph.param_no) { // positional argument (explicit)\n                    arg = argv[ph.param_no]\n                }\n                else { // positional argument (implicit)\n                    arg = argv[cursor++]\n                }\n\n                if (re.not_type.test(ph.type) && re.not_primitive.test(ph.type) && arg instanceof Function) {\n                    arg = arg()\n                }\n\n                if (re.numeric_arg.test(ph.type) && (typeof arg !== 'number' && isNaN(arg))) {\n                    throw new TypeError(sprintf('[sprintf] expecting number but found %T', arg))\n                }\n\n                if (re.number.test(ph.type)) {\n                    is_positive = arg >= 0\n                }\n\n                switch (ph.type) {\n                    case 'b':\n                        arg = parseInt(arg, 10).toString(2)\n                        break\n                    case 'c':\n                        arg = String.fromCharCode(parseInt(arg, 10))\n                        break\n                    case 'd':\n                    case 'i':\n                        arg = parseInt(arg, 10)\n                        break\n                    case 'j':\n                        arg = JSON.stringify(arg, null, ph.width ? parseInt(ph.width) : 0)\n                        break\n                    case 'e':\n                        arg = ph.precision ? parseFloat(arg).toExponential(ph.precision) : parseFloat(arg).toExponential()\n                        break\n                    case 'f':\n                        arg = ph.precision ? parseFloat(arg).toFixed(ph.precision) : parseFloat(arg)\n                        break\n                    case 'g':\n                        arg = ph.precision ? String(Number(arg.toPrecision(ph.precision))) : parseFloat(arg)\n                        break\n                    case 'o':\n                        arg = (parseInt(arg, 10) >>> 0).toString(8)\n                        break\n                    case 's':\n                        arg = String(arg)\n                        arg = (ph.precision ? arg.substring(0, ph.precision) : arg)\n                        break\n                    case 't':\n                        arg = String(!!arg)\n                        arg = (ph.precision ? arg.substring(0, ph.precision) : arg)\n                        break\n                    case 'T':\n                        arg = Object.prototype.toString.call(arg).slice(8, -1).toLowerCase()\n                        arg = (ph.precision ? arg.substring(0, ph.precision) : arg)\n                        break\n                    case 'u':\n                        arg = parseInt(arg, 10) >>> 0\n                        break\n                    case 'v':\n                        arg = arg.valueOf()\n                        arg = (ph.precision ? arg.substring(0, ph.precision) : arg)\n                        break\n                    case 'x':\n                        arg = (parseInt(arg, 10) >>> 0).toString(16)\n                        break\n                    case 'X':\n                        arg = (parseInt(arg, 10) >>> 0).toString(16).toUpperCase()\n                        break\n                }\n                if (re.json.test(ph.type)) {\n                    output += arg\n                }\n                else {\n                    if (re.number.test(ph.type) && (!is_positive || ph.sign)) {\n                        sign = is_positive ? '+' : '-'\n                        arg = arg.toString().replace(re.sign, '')\n                    }\n                    else {\n                        sign = ''\n                    }\n                    pad_character = ph.pad_char ? ph.pad_char === '0' ? '0' : ph.pad_char.charAt(1) : ' '\n                    pad_length = ph.width - (sign + arg).length\n                    pad = ph.width ? (pad_length > 0 ? pad_character.repeat(pad_length) : '') : ''\n                    output += ph.align ? sign + arg + pad : (pad_character === '0' ? sign + pad + arg : pad + sign + arg)\n                }\n            }\n        }\n        return output\n    }\n\n    var sprintf_cache = Object.create(null)\n\n    function sprintf_parse(fmt) {\n        if (sprintf_cache[fmt]) {\n            return sprintf_cache[fmt]\n        }\n\n        var _fmt = fmt, match, parse_tree = [], arg_names = 0\n        while (_fmt) {\n            if ((match = re.text.exec(_fmt)) !== null) {\n                parse_tree.push(match[0])\n            }\n            else if ((match = re.modulo.exec(_fmt)) !== null) {\n                parse_tree.push('%')\n            }\n            else if ((match = re.placeholder.exec(_fmt)) !== null) {\n                if (match[2]) {\n                    arg_names |= 1\n                    var field_list = [], replacement_field = match[2], field_match = []\n                    if ((field_match = re.key.exec(replacement_field)) !== null) {\n                        field_list.push(field_match[1])\n                        while ((replacement_field = replacement_field.substring(field_match[0].length)) !== '') {\n                            if ((field_match = re.key_access.exec(replacement_field)) !== null) {\n                                field_list.push(field_match[1])\n                            }\n                            else if ((field_match = re.index_access.exec(replacement_field)) !== null) {\n                                field_list.push(field_match[1])\n                            }\n                            else {\n                                throw new SyntaxError('[sprintf] failed to parse named argument key')\n                            }\n                        }\n                    }\n                    else {\n                        throw new SyntaxError('[sprintf] failed to parse named argument key')\n                    }\n                    match[2] = field_list\n                }\n                else {\n                    arg_names |= 2\n                }\n                if (arg_names === 3) {\n                    throw new Error('[sprintf] mixing positional and named placeholders is not (yet) supported')\n                }\n\n                parse_tree.push(\n                    {\n                        placeholder: match[0],\n                        param_no:    match[1],\n                        keys:        match[2],\n                        sign:        match[3],\n                        pad_char:    match[4],\n                        align:       match[5],\n                        width:       match[6],\n                        precision:   match[7],\n                        type:        match[8]\n                    }\n                )\n            }\n            else {\n                throw new SyntaxError('[sprintf] unexpected placeholder')\n            }\n            _fmt = _fmt.substring(match[0].length)\n        }\n        return sprintf_cache[fmt] = parse_tree\n    }\n\n    /**\n     * export to either browser or node.js\n     */\n    /* eslint-disable quote-props */\n    if (typeof exports !== 'undefined') {\n        exports['sprintf'] = sprintf\n        exports['vsprintf'] = vsprintf\n    }\n    if (typeof window !== 'undefined') {\n        window['sprintf'] = sprintf\n        window['vsprintf'] = vsprintf\n\n        if (typeof define === 'function' && define['amd']) {\n            define(function() {\n                return {\n                    'sprintf': sprintf,\n                    'vsprintf': vsprintf\n                }\n            })\n        }\n    }\n    /* eslint-enable quote-props */\n}(); // eslint-disable-line\n", "const vsprintf = require(\"sprintf-js\").vsprintf;\n\nconst sprintf = (s, values) => vsprintf(s, values);\n\nmodule.exports = { sprintf };\n", "const regexSplit = (pattern, s) => s.split(RegExp(pattern));\n\nmodule.exports = { \"regex.split\": regexSplit };\n", "'use strict';\n\nconst Char = {\n  ANCHOR: '&',\n  COMMENT: '#',\n  TAG: '!',\n  DIRECTIVES_END: '-',\n  DOCUMENT_END: '.'\n};\nconst Type = {\n  ALIAS: 'ALIAS',\n  BLANK_LINE: 'BLANK_LINE',\n  BLOCK_FOLDED: 'BLOCK_FOLDED',\n  BLOCK_LITERAL: 'BLOCK_LITERAL',\n  COMMENT: 'COMMENT',\n  DIRECTIVE: 'DIRECTIVE',\n  DOCUMENT: 'DOCUMENT',\n  FLOW_MAP: 'FLOW_MAP',\n  FLOW_SEQ: 'FLOW_SEQ',\n  MAP: 'MAP',\n  MAP_KEY: 'MAP_KEY',\n  MAP_VALUE: 'MAP_VALUE',\n  PLAIN: 'PLAIN',\n  QUOTE_DOUBLE: 'QUOTE_DOUBLE',\n  QUOTE_SINGLE: 'QUOTE_SINGLE',\n  SEQ: 'SEQ',\n  SEQ_ITEM: 'SEQ_ITEM'\n};\nconst defaultTagPrefix = 'tag:yaml.org,2002:';\nconst defaultTags = {\n  MAP: 'tag:yaml.org,2002:map',\n  SEQ: 'tag:yaml.org,2002:seq',\n  STR: 'tag:yaml.org,2002:str'\n};\n\nfunction findLineStarts(src) {\n  const ls = [0];\n  let offset = src.indexOf('\\n');\n\n  while (offset !== -1) {\n    offset += 1;\n    ls.push(offset);\n    offset = src.indexOf('\\n', offset);\n  }\n\n  return ls;\n}\n\nfunction getSrcInfo(cst) {\n  let lineStarts, src;\n\n  if (typeof cst === 'string') {\n    lineStarts = findLineStarts(cst);\n    src = cst;\n  } else {\n    if (Array.isArray(cst)) cst = cst[0];\n\n    if (cst && cst.context) {\n      if (!cst.lineStarts) cst.lineStarts = findLineStarts(cst.context.src);\n      lineStarts = cst.lineStarts;\n      src = cst.context.src;\n    }\n  }\n\n  return {\n    lineStarts,\n    src\n  };\n}\n/**\n * @typedef {Object} LinePos - One-indexed position in the source\n * @property {number} line\n * @property {number} col\n */\n\n/**\n * Determine the line/col position matching a character offset.\n *\n * Accepts a source string or a CST document as the second parameter. With\n * the latter, starting indices for lines are cached in the document as\n * `lineStarts: number[]`.\n *\n * Returns a one-indexed `{ line, col }` location if found, or\n * `undefined` otherwise.\n *\n * @param {number} offset\n * @param {string|Document|Document[]} cst\n * @returns {?LinePos}\n */\n\n\nfunction getLinePos(offset, cst) {\n  if (typeof offset !== 'number' || offset < 0) return null;\n  const {\n    lineStarts,\n    src\n  } = getSrcInfo(cst);\n  if (!lineStarts || !src || offset > src.length) return null;\n\n  for (let i = 0; i < lineStarts.length; ++i) {\n    const start = lineStarts[i];\n\n    if (offset < start) {\n      return {\n        line: i,\n        col: offset - lineStarts[i - 1] + 1\n      };\n    }\n\n    if (offset === start) return {\n      line: i + 1,\n      col: 1\n    };\n  }\n\n  const line = lineStarts.length;\n  return {\n    line,\n    col: offset - lineStarts[line - 1] + 1\n  };\n}\n/**\n * Get a specified line from the source.\n *\n * Accepts a source string or a CST document as the second parameter. With\n * the latter, starting indices for lines are cached in the document as\n * `lineStarts: number[]`.\n *\n * Returns the line as a string if found, or `null` otherwise.\n *\n * @param {number} line One-indexed line number\n * @param {string|Document|Document[]} cst\n * @returns {?string}\n */\n\nfunction getLine(line, cst) {\n  const {\n    lineStarts,\n    src\n  } = getSrcInfo(cst);\n  if (!lineStarts || !(line >= 1) || line > lineStarts.length) return null;\n  const start = lineStarts[line - 1];\n  let end = lineStarts[line]; // undefined for last line; that's ok for slice()\n\n  while (end && end > start && src[end - 1] === '\\n') --end;\n\n  return src.slice(start, end);\n}\n/**\n * Pretty-print the starting line from the source indicated by the range `pos`\n *\n * Trims output to `maxWidth` chars while keeping the starting column visible,\n * using `\u2026` at either end to indicate dropped characters.\n *\n * Returns a two-line string (or `null`) with `\\n` as separator; the second line\n * will hold appropriately indented `^` marks indicating the column range.\n *\n * @param {Object} pos\n * @param {LinePos} pos.start\n * @param {LinePos} [pos.end]\n * @param {string|Document|Document[]*} cst\n * @param {number} [maxWidth=80]\n * @returns {?string}\n */\n\nfunction getPrettyContext({\n  start,\n  end\n}, cst, maxWidth = 80) {\n  let src = getLine(start.line, cst);\n  if (!src) return null;\n  let {\n    col\n  } = start;\n\n  if (src.length > maxWidth) {\n    if (col <= maxWidth - 10) {\n      src = src.substr(0, maxWidth - 1) + '\u2026';\n    } else {\n      const halfWidth = Math.round(maxWidth / 2);\n      if (src.length > col + halfWidth) src = src.substr(0, col + halfWidth - 1) + '\u2026';\n      col -= src.length - maxWidth;\n      src = '\u2026' + src.substr(1 - maxWidth);\n    }\n  }\n\n  let errLen = 1;\n  let errEnd = '';\n\n  if (end) {\n    if (end.line === start.line && col + (end.col - start.col) <= maxWidth + 1) {\n      errLen = end.col - start.col;\n    } else {\n      errLen = Math.min(src.length + 1, maxWidth) - col;\n      errEnd = '\u2026';\n    }\n  }\n\n  const offset = col > 1 ? ' '.repeat(col - 1) : '';\n  const err = '^'.repeat(errLen);\n  return `${src}\\n${offset}${err}${errEnd}`;\n}\n\nclass Range {\n  static copy(orig) {\n    return new Range(orig.start, orig.end);\n  }\n\n  constructor(start, end) {\n    this.start = start;\n    this.end = end || start;\n  }\n\n  isEmpty() {\n    return typeof this.start !== 'number' || !this.end || this.end <= this.start;\n  }\n  /**\n   * Set `origStart` and `origEnd` to point to the original source range for\n   * this node, which may differ due to dropped CR characters.\n   *\n   * @param {number[]} cr - Positions of dropped CR characters\n   * @param {number} offset - Starting index of `cr` from the last call\n   * @returns {number} - The next offset, matching the one found for `origStart`\n   */\n\n\n  setOrigRange(cr, offset) {\n    const {\n      start,\n      end\n    } = this;\n\n    if (cr.length === 0 || end <= cr[0]) {\n      this.origStart = start;\n      this.origEnd = end;\n      return offset;\n    }\n\n    let i = offset;\n\n    while (i < cr.length) {\n      if (cr[i] > start) break;else ++i;\n    }\n\n    this.origStart = start + i;\n    const nextOffset = i;\n\n    while (i < cr.length) {\n      // if end was at \\n, it should now be at \\r\n      if (cr[i] >= end) break;else ++i;\n    }\n\n    this.origEnd = end + i;\n    return nextOffset;\n  }\n\n}\n\n/** Root class of all nodes */\n\nclass Node {\n  static addStringTerminator(src, offset, str) {\n    if (str[str.length - 1] === '\\n') return str;\n    const next = Node.endOfWhiteSpace(src, offset);\n    return next >= src.length || src[next] === '\\n' ? str + '\\n' : str;\n  } // ^(---|...)\n\n\n  static atDocumentBoundary(src, offset, sep) {\n    const ch0 = src[offset];\n    if (!ch0) return true;\n    const prev = src[offset - 1];\n    if (prev && prev !== '\\n') return false;\n\n    if (sep) {\n      if (ch0 !== sep) return false;\n    } else {\n      if (ch0 !== Char.DIRECTIVES_END && ch0 !== Char.DOCUMENT_END) return false;\n    }\n\n    const ch1 = src[offset + 1];\n    const ch2 = src[offset + 2];\n    if (ch1 !== ch0 || ch2 !== ch0) return false;\n    const ch3 = src[offset + 3];\n    return !ch3 || ch3 === '\\n' || ch3 === '\\t' || ch3 === ' ';\n  }\n\n  static endOfIdentifier(src, offset) {\n    let ch = src[offset];\n    const isVerbatim = ch === '<';\n    const notOk = isVerbatim ? ['\\n', '\\t', ' ', '>'] : ['\\n', '\\t', ' ', '[', ']', '{', '}', ','];\n\n    while (ch && notOk.indexOf(ch) === -1) ch = src[offset += 1];\n\n    if (isVerbatim && ch === '>') offset += 1;\n    return offset;\n  }\n\n  static endOfIndent(src, offset) {\n    let ch = src[offset];\n\n    while (ch === ' ') ch = src[offset += 1];\n\n    return offset;\n  }\n\n  static endOfLine(src, offset) {\n    let ch = src[offset];\n\n    while (ch && ch !== '\\n') ch = src[offset += 1];\n\n    return offset;\n  }\n\n  static endOfWhiteSpace(src, offset) {\n    let ch = src[offset];\n\n    while (ch === '\\t' || ch === ' ') ch = src[offset += 1];\n\n    return offset;\n  }\n\n  static startOfLine(src, offset) {\n    let ch = src[offset - 1];\n    if (ch === '\\n') return offset;\n\n    while (ch && ch !== '\\n') ch = src[offset -= 1];\n\n    return offset + 1;\n  }\n  /**\n   * End of indentation, or null if the line's indent level is not more\n   * than `indent`\n   *\n   * @param {string} src\n   * @param {number} indent\n   * @param {number} lineStart\n   * @returns {?number}\n   */\n\n\n  static endOfBlockIndent(src, indent, lineStart) {\n    const inEnd = Node.endOfIndent(src, lineStart);\n\n    if (inEnd > lineStart + indent) {\n      return inEnd;\n    } else {\n      const wsEnd = Node.endOfWhiteSpace(src, inEnd);\n      const ch = src[wsEnd];\n      if (!ch || ch === '\\n') return wsEnd;\n    }\n\n    return null;\n  }\n\n  static atBlank(src, offset, endAsBlank) {\n    const ch = src[offset];\n    return ch === '\\n' || ch === '\\t' || ch === ' ' || endAsBlank && !ch;\n  }\n\n  static nextNodeIsIndented(ch, indentDiff, indicatorAsIndent) {\n    if (!ch || indentDiff < 0) return false;\n    if (indentDiff > 0) return true;\n    return indicatorAsIndent && ch === '-';\n  } // should be at line or string end, or at next non-whitespace char\n\n\n  static normalizeOffset(src, offset) {\n    const ch = src[offset];\n    return !ch ? offset : ch !== '\\n' && src[offset - 1] === '\\n' ? offset - 1 : Node.endOfWhiteSpace(src, offset);\n  } // fold single newline into space, multiple newlines to N - 1 newlines\n  // presumes src[offset] === '\\n'\n\n\n  static foldNewline(src, offset, indent) {\n    let inCount = 0;\n    let error = false;\n    let fold = '';\n    let ch = src[offset + 1];\n\n    while (ch === ' ' || ch === '\\t' || ch === '\\n') {\n      switch (ch) {\n        case '\\n':\n          inCount = 0;\n          offset += 1;\n          fold += '\\n';\n          break;\n\n        case '\\t':\n          if (inCount <= indent) error = true;\n          offset = Node.endOfWhiteSpace(src, offset + 2) - 1;\n          break;\n\n        case ' ':\n          inCount += 1;\n          offset += 1;\n          break;\n      }\n\n      ch = src[offset + 1];\n    }\n\n    if (!fold) fold = ' ';\n    if (ch && inCount <= indent) error = true;\n    return {\n      fold,\n      offset,\n      error\n    };\n  }\n\n  constructor(type, props, context) {\n    Object.defineProperty(this, 'context', {\n      value: context || null,\n      writable: true\n    });\n    this.error = null;\n    this.range = null;\n    this.valueRange = null;\n    this.props = props || [];\n    this.type = type;\n    this.value = null;\n  }\n\n  getPropValue(idx, key, skipKey) {\n    if (!this.context) return null;\n    const {\n      src\n    } = this.context;\n    const prop = this.props[idx];\n    return prop && src[prop.start] === key ? src.slice(prop.start + (skipKey ? 1 : 0), prop.end) : null;\n  }\n\n  get anchor() {\n    for (let i = 0; i < this.props.length; ++i) {\n      const anchor = this.getPropValue(i, Char.ANCHOR, true);\n      if (anchor != null) return anchor;\n    }\n\n    return null;\n  }\n\n  get comment() {\n    const comments = [];\n\n    for (let i = 0; i < this.props.length; ++i) {\n      const comment = this.getPropValue(i, Char.COMMENT, true);\n      if (comment != null) comments.push(comment);\n    }\n\n    return comments.length > 0 ? comments.join('\\n') : null;\n  }\n\n  commentHasRequiredWhitespace(start) {\n    const {\n      src\n    } = this.context;\n    if (this.header && start === this.header.end) return false;\n    if (!this.valueRange) return false;\n    const {\n      end\n    } = this.valueRange;\n    return start !== end || Node.atBlank(src, end - 1);\n  }\n\n  get hasComment() {\n    if (this.context) {\n      const {\n        src\n      } = this.context;\n\n      for (let i = 0; i < this.props.length; ++i) {\n        if (src[this.props[i].start] === Char.COMMENT) return true;\n      }\n    }\n\n    return false;\n  }\n\n  get hasProps() {\n    if (this.context) {\n      const {\n        src\n      } = this.context;\n\n      for (let i = 0; i < this.props.length; ++i) {\n        if (src[this.props[i].start] !== Char.COMMENT) return true;\n      }\n    }\n\n    return false;\n  }\n\n  get includesTrailingLines() {\n    return false;\n  }\n\n  get jsonLike() {\n    const jsonLikeTypes = [Type.FLOW_MAP, Type.FLOW_SEQ, Type.QUOTE_DOUBLE, Type.QUOTE_SINGLE];\n    return jsonLikeTypes.indexOf(this.type) !== -1;\n  }\n\n  get rangeAsLinePos() {\n    if (!this.range || !this.context) return undefined;\n    const start = getLinePos(this.range.start, this.context.root);\n    if (!start) return undefined;\n    const end = getLinePos(this.range.end, this.context.root);\n    return {\n      start,\n      end\n    };\n  }\n\n  get rawValue() {\n    if (!this.valueRange || !this.context) return null;\n    const {\n      start,\n      end\n    } = this.valueRange;\n    return this.context.src.slice(start, end);\n  }\n\n  get tag() {\n    for (let i = 0; i < this.props.length; ++i) {\n      const tag = this.getPropValue(i, Char.TAG, false);\n\n      if (tag != null) {\n        if (tag[1] === '<') {\n          return {\n            verbatim: tag.slice(2, -1)\n          };\n        } else {\n          // eslint-disable-next-line no-unused-vars\n          const [_, handle, suffix] = tag.match(/^(.*!)([^!]*)$/);\n          return {\n            handle,\n            suffix\n          };\n        }\n      }\n    }\n\n    return null;\n  }\n\n  get valueRangeContainsNewline() {\n    if (!this.valueRange || !this.context) return false;\n    const {\n      start,\n      end\n    } = this.valueRange;\n    const {\n      src\n    } = this.context;\n\n    for (let i = start; i < end; ++i) {\n      if (src[i] === '\\n') return true;\n    }\n\n    return false;\n  }\n\n  parseComment(start) {\n    const {\n      src\n    } = this.context;\n\n    if (src[start] === Char.COMMENT) {\n      const end = Node.endOfLine(src, start + 1);\n      const commentRange = new Range(start, end);\n      this.props.push(commentRange);\n      return end;\n    }\n\n    return start;\n  }\n  /**\n   * Populates the `origStart` and `origEnd` values of all ranges for this\n   * node. Extended by child classes to handle descendant nodes.\n   *\n   * @param {number[]} cr - Positions of dropped CR characters\n   * @param {number} offset - Starting index of `cr` from the last call\n   * @returns {number} - The next offset, matching the one found for `origStart`\n   */\n\n\n  setOrigRanges(cr, offset) {\n    if (this.range) offset = this.range.setOrigRange(cr, offset);\n    if (this.valueRange) this.valueRange.setOrigRange(cr, offset);\n    this.props.forEach(prop => prop.setOrigRange(cr, offset));\n    return offset;\n  }\n\n  toString() {\n    const {\n      context: {\n        src\n      },\n      range,\n      value\n    } = this;\n    if (value != null) return value;\n    const str = src.slice(range.start, range.end);\n    return Node.addStringTerminator(src, range.end, str);\n  }\n\n}\n\nclass YAMLError extends Error {\n  constructor(name, source, message) {\n    if (!message || !(source instanceof Node)) throw new Error(`Invalid arguments for new ${name}`);\n    super();\n    this.name = name;\n    this.message = message;\n    this.source = source;\n  }\n\n  makePretty() {\n    if (!this.source) return;\n    this.nodeType = this.source.type;\n    const cst = this.source.context && this.source.context.root;\n\n    if (typeof this.offset === 'number') {\n      this.range = new Range(this.offset, this.offset + 1);\n      const start = cst && getLinePos(this.offset, cst);\n\n      if (start) {\n        const end = {\n          line: start.line,\n          col: start.col + 1\n        };\n        this.linePos = {\n          start,\n          end\n        };\n      }\n\n      delete this.offset;\n    } else {\n      this.range = this.source.range;\n      this.linePos = this.source.rangeAsLinePos;\n    }\n\n    if (this.linePos) {\n      const {\n        line,\n        col\n      } = this.linePos.start;\n      this.message += ` at line ${line}, column ${col}`;\n      const ctx = cst && getPrettyContext(this.linePos, cst);\n      if (ctx) this.message += `:\\n\\n${ctx}\\n`;\n    }\n\n    delete this.source;\n  }\n\n}\nclass YAMLReferenceError extends YAMLError {\n  constructor(source, message) {\n    super('YAMLReferenceError', source, message);\n  }\n\n}\nclass YAMLSemanticError extends YAMLError {\n  constructor(source, message) {\n    super('YAMLSemanticError', source, message);\n  }\n\n}\nclass YAMLSyntaxError extends YAMLError {\n  constructor(source, message) {\n    super('YAMLSyntaxError', source, message);\n  }\n\n}\nclass YAMLWarning extends YAMLError {\n  constructor(source, message) {\n    super('YAMLWarning', source, message);\n  }\n\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nclass PlainValue extends Node {\n  static endOfLine(src, start, inFlow) {\n    let ch = src[start];\n    let offset = start;\n\n    while (ch && ch !== '\\n') {\n      if (inFlow && (ch === '[' || ch === ']' || ch === '{' || ch === '}' || ch === ',')) break;\n      const next = src[offset + 1];\n      if (ch === ':' && (!next || next === '\\n' || next === '\\t' || next === ' ' || inFlow && next === ',')) break;\n      if ((ch === ' ' || ch === '\\t') && next === '#') break;\n      offset += 1;\n      ch = next;\n    }\n\n    return offset;\n  }\n\n  get strValue() {\n    if (!this.valueRange || !this.context) return null;\n    let {\n      start,\n      end\n    } = this.valueRange;\n    const {\n      src\n    } = this.context;\n    let ch = src[end - 1];\n\n    while (start < end && (ch === '\\n' || ch === '\\t' || ch === ' ')) ch = src[--end - 1];\n\n    let str = '';\n\n    for (let i = start; i < end; ++i) {\n      const ch = src[i];\n\n      if (ch === '\\n') {\n        const {\n          fold,\n          offset\n        } = Node.foldNewline(src, i, -1);\n        str += fold;\n        i = offset;\n      } else if (ch === ' ' || ch === '\\t') {\n        // trim trailing whitespace\n        const wsStart = i;\n        let next = src[i + 1];\n\n        while (i < end && (next === ' ' || next === '\\t')) {\n          i += 1;\n          next = src[i + 1];\n        }\n\n        if (next !== '\\n') str += i > wsStart ? src.slice(wsStart, i + 1) : ch;\n      } else {\n        str += ch;\n      }\n    }\n\n    const ch0 = src[start];\n\n    switch (ch0) {\n      case '\\t':\n        {\n          const msg = 'Plain value cannot start with a tab character';\n          const errors = [new YAMLSemanticError(this, msg)];\n          return {\n            errors,\n            str\n          };\n        }\n\n      case '@':\n      case '`':\n        {\n          const msg = `Plain value cannot start with reserved character ${ch0}`;\n          const errors = [new YAMLSemanticError(this, msg)];\n          return {\n            errors,\n            str\n          };\n        }\n\n      default:\n        return str;\n    }\n  }\n\n  parseBlockValue(start) {\n    const {\n      indent,\n      inFlow,\n      src\n    } = this.context;\n    let offset = start;\n    let valueEnd = start;\n\n    for (let ch = src[offset]; ch === '\\n'; ch = src[offset]) {\n      if (Node.atDocumentBoundary(src, offset + 1)) break;\n      const end = Node.endOfBlockIndent(src, indent, offset + 1);\n      if (end === null || src[end] === '#') break;\n\n      if (src[end] === '\\n') {\n        offset = end;\n      } else {\n        valueEnd = PlainValue.endOfLine(src, end, inFlow);\n        offset = valueEnd;\n      }\n    }\n\n    if (this.valueRange.isEmpty()) this.valueRange.start = start;\n    this.valueRange.end = valueEnd;\n    return valueEnd;\n  }\n  /**\n   * Parses a plain value from the source\n   *\n   * Accepted forms are:\n   * ```\n   * #comment\n   *\n   * first line\n   *\n   * first line #comment\n   *\n   * first line\n   * block\n   * lines\n   *\n   * #comment\n   * block\n   * lines\n   * ```\n   * where block lines are empty or have an indent level greater than `indent`.\n   *\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this scalar, may be `\\n`\n   */\n\n\n  parse(context, start) {\n    this.context = context;\n    const {\n      inFlow,\n      src\n    } = context;\n    let offset = start;\n    const ch = src[offset];\n\n    if (ch && ch !== '#' && ch !== '\\n') {\n      offset = PlainValue.endOfLine(src, start, inFlow);\n    }\n\n    this.valueRange = new Range(start, offset);\n    offset = Node.endOfWhiteSpace(src, offset);\n    offset = this.parseComment(offset);\n\n    if (!this.hasComment || this.valueRange.isEmpty()) {\n      offset = this.parseBlockValue(offset);\n    }\n\n    return offset;\n  }\n\n}\n\nexports.Char = Char;\nexports.Node = Node;\nexports.PlainValue = PlainValue;\nexports.Range = Range;\nexports.Type = Type;\nexports.YAMLError = YAMLError;\nexports.YAMLReferenceError = YAMLReferenceError;\nexports.YAMLSemanticError = YAMLSemanticError;\nexports.YAMLSyntaxError = YAMLSyntaxError;\nexports.YAMLWarning = YAMLWarning;\nexports._defineProperty = _defineProperty;\nexports.defaultTagPrefix = defaultTagPrefix;\nexports.defaultTags = defaultTags;\n", "'use strict';\n\nvar PlainValue = require('./PlainValue-ec8e588e.js');\n\nclass BlankLine extends PlainValue.Node {\n  constructor() {\n    super(PlainValue.Type.BLANK_LINE);\n  }\n  /* istanbul ignore next */\n\n\n  get includesTrailingLines() {\n    // This is never called from anywhere, but if it were,\n    // this is the value it should return.\n    return true;\n  }\n  /**\n   * Parses a blank line from the source\n   *\n   * @param {ParseContext} context\n   * @param {number} start - Index of first \\n character\n   * @returns {number} - Index of the character after this\n   */\n\n\n  parse(context, start) {\n    this.context = context;\n    this.range = new PlainValue.Range(start, start + 1);\n    return start + 1;\n  }\n\n}\n\nclass CollectionItem extends PlainValue.Node {\n  constructor(type, props) {\n    super(type, props);\n    this.node = null;\n  }\n\n  get includesTrailingLines() {\n    return !!this.node && this.node.includesTrailingLines;\n  }\n  /**\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this\n   */\n\n\n  parse(context, start) {\n    this.context = context;\n    const {\n      parseNode,\n      src\n    } = context;\n    let {\n      atLineStart,\n      lineStart\n    } = context;\n    if (!atLineStart && this.type === PlainValue.Type.SEQ_ITEM) this.error = new PlainValue.YAMLSemanticError(this, 'Sequence items must not have preceding content on the same line');\n    const indent = atLineStart ? start - lineStart : context.indent;\n    let offset = PlainValue.Node.endOfWhiteSpace(src, start + 1);\n    let ch = src[offset];\n    const inlineComment = ch === '#';\n    const comments = [];\n    let blankLine = null;\n\n    while (ch === '\\n' || ch === '#') {\n      if (ch === '#') {\n        const end = PlainValue.Node.endOfLine(src, offset + 1);\n        comments.push(new PlainValue.Range(offset, end));\n        offset = end;\n      } else {\n        atLineStart = true;\n        lineStart = offset + 1;\n        const wsEnd = PlainValue.Node.endOfWhiteSpace(src, lineStart);\n\n        if (src[wsEnd] === '\\n' && comments.length === 0) {\n          blankLine = new BlankLine();\n          lineStart = blankLine.parse({\n            src\n          }, lineStart);\n        }\n\n        offset = PlainValue.Node.endOfIndent(src, lineStart);\n      }\n\n      ch = src[offset];\n    }\n\n    if (PlainValue.Node.nextNodeIsIndented(ch, offset - (lineStart + indent), this.type !== PlainValue.Type.SEQ_ITEM)) {\n      this.node = parseNode({\n        atLineStart,\n        inCollection: false,\n        indent,\n        lineStart,\n        parent: this\n      }, offset);\n    } else if (ch && lineStart > start + 1) {\n      offset = lineStart - 1;\n    }\n\n    if (this.node) {\n      if (blankLine) {\n        // Only blank lines preceding non-empty nodes are captured. Note that\n        // this means that collection item range start indices do not always\n        // increase monotonically. -- eemeli/yaml#126\n        const items = context.parent.items || context.parent.contents;\n        if (items) items.push(blankLine);\n      }\n\n      if (comments.length) Array.prototype.push.apply(this.props, comments);\n      offset = this.node.range.end;\n    } else {\n      if (inlineComment) {\n        const c = comments[0];\n        this.props.push(c);\n        offset = c.end;\n      } else {\n        offset = PlainValue.Node.endOfLine(src, start + 1);\n      }\n    }\n\n    const end = this.node ? this.node.valueRange.end : offset;\n    this.valueRange = new PlainValue.Range(start, end);\n    return offset;\n  }\n\n  setOrigRanges(cr, offset) {\n    offset = super.setOrigRanges(cr, offset);\n    return this.node ? this.node.setOrigRanges(cr, offset) : offset;\n  }\n\n  toString() {\n    const {\n      context: {\n        src\n      },\n      node,\n      range,\n      value\n    } = this;\n    if (value != null) return value;\n    const str = node ? src.slice(range.start, node.range.start) + String(node) : src.slice(range.start, range.end);\n    return PlainValue.Node.addStringTerminator(src, range.end, str);\n  }\n\n}\n\nclass Comment extends PlainValue.Node {\n  constructor() {\n    super(PlainValue.Type.COMMENT);\n  }\n  /**\n   * Parses a comment line from the source\n   *\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this scalar\n   */\n\n\n  parse(context, start) {\n    this.context = context;\n    const offset = this.parseComment(start);\n    this.range = new PlainValue.Range(start, offset);\n    return offset;\n  }\n\n}\n\nfunction grabCollectionEndComments(node) {\n  let cnode = node;\n\n  while (cnode instanceof CollectionItem) cnode = cnode.node;\n\n  if (!(cnode instanceof Collection)) return null;\n  const len = cnode.items.length;\n  let ci = -1;\n\n  for (let i = len - 1; i >= 0; --i) {\n    const n = cnode.items[i];\n\n    if (n.type === PlainValue.Type.COMMENT) {\n      // Keep sufficiently indented comments with preceding node\n      const {\n        indent,\n        lineStart\n      } = n.context;\n      if (indent > 0 && n.range.start >= lineStart + indent) break;\n      ci = i;\n    } else if (n.type === PlainValue.Type.BLANK_LINE) ci = i;else break;\n  }\n\n  if (ci === -1) return null;\n  const ca = cnode.items.splice(ci, len - ci);\n  const prevEnd = ca[0].range.start;\n\n  while (true) {\n    cnode.range.end = prevEnd;\n    if (cnode.valueRange && cnode.valueRange.end > prevEnd) cnode.valueRange.end = prevEnd;\n    if (cnode === node) break;\n    cnode = cnode.context.parent;\n  }\n\n  return ca;\n}\nclass Collection extends PlainValue.Node {\n  static nextContentHasIndent(src, offset, indent) {\n    const lineStart = PlainValue.Node.endOfLine(src, offset) + 1;\n    offset = PlainValue.Node.endOfWhiteSpace(src, lineStart);\n    const ch = src[offset];\n    if (!ch) return false;\n    if (offset >= lineStart + indent) return true;\n    if (ch !== '#' && ch !== '\\n') return false;\n    return Collection.nextContentHasIndent(src, offset, indent);\n  }\n\n  constructor(firstItem) {\n    super(firstItem.type === PlainValue.Type.SEQ_ITEM ? PlainValue.Type.SEQ : PlainValue.Type.MAP);\n\n    for (let i = firstItem.props.length - 1; i >= 0; --i) {\n      if (firstItem.props[i].start < firstItem.context.lineStart) {\n        // props on previous line are assumed by the collection\n        this.props = firstItem.props.slice(0, i + 1);\n        firstItem.props = firstItem.props.slice(i + 1);\n        const itemRange = firstItem.props[0] || firstItem.valueRange;\n        firstItem.range.start = itemRange.start;\n        break;\n      }\n    }\n\n    this.items = [firstItem];\n    const ec = grabCollectionEndComments(firstItem);\n    if (ec) Array.prototype.push.apply(this.items, ec);\n  }\n\n  get includesTrailingLines() {\n    return this.items.length > 0;\n  }\n  /**\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this\n   */\n\n\n  parse(context, start) {\n    this.context = context;\n    const {\n      parseNode,\n      src\n    } = context; // It's easier to recalculate lineStart here rather than tracking down the\n    // last context from which to read it -- eemeli/yaml#2\n\n    let lineStart = PlainValue.Node.startOfLine(src, start);\n    const firstItem = this.items[0]; // First-item context needs to be correct for later comment handling\n    // -- eemeli/yaml#17\n\n    firstItem.context.parent = this;\n    this.valueRange = PlainValue.Range.copy(firstItem.valueRange);\n    const indent = firstItem.range.start - firstItem.context.lineStart;\n    let offset = start;\n    offset = PlainValue.Node.normalizeOffset(src, offset);\n    let ch = src[offset];\n    let atLineStart = PlainValue.Node.endOfWhiteSpace(src, lineStart) === offset;\n    let prevIncludesTrailingLines = false;\n\n    while (ch) {\n      while (ch === '\\n' || ch === '#') {\n        if (atLineStart && ch === '\\n' && !prevIncludesTrailingLines) {\n          const blankLine = new BlankLine();\n          offset = blankLine.parse({\n            src\n          }, offset);\n          this.valueRange.end = offset;\n\n          if (offset >= src.length) {\n            ch = null;\n            break;\n          }\n\n          this.items.push(blankLine);\n          offset -= 1; // blankLine.parse() consumes terminal newline\n        } else if (ch === '#') {\n          if (offset < lineStart + indent && !Collection.nextContentHasIndent(src, offset, indent)) {\n            return offset;\n          }\n\n          const comment = new Comment();\n          offset = comment.parse({\n            indent,\n            lineStart,\n            src\n          }, offset);\n          this.items.push(comment);\n          this.valueRange.end = offset;\n\n          if (offset >= src.length) {\n            ch = null;\n            break;\n          }\n        }\n\n        lineStart = offset + 1;\n        offset = PlainValue.Node.endOfIndent(src, lineStart);\n\n        if (PlainValue.Node.atBlank(src, offset)) {\n          const wsEnd = PlainValue.Node.endOfWhiteSpace(src, offset);\n          const next = src[wsEnd];\n\n          if (!next || next === '\\n' || next === '#') {\n            offset = wsEnd;\n          }\n        }\n\n        ch = src[offset];\n        atLineStart = true;\n      }\n\n      if (!ch) {\n        break;\n      }\n\n      if (offset !== lineStart + indent && (atLineStart || ch !== ':')) {\n        if (offset < lineStart + indent) {\n          if (lineStart > start) offset = lineStart;\n          break;\n        } else if (!this.error) {\n          const msg = 'All collection items must start at the same column';\n          this.error = new PlainValue.YAMLSyntaxError(this, msg);\n        }\n      }\n\n      if (firstItem.type === PlainValue.Type.SEQ_ITEM) {\n        if (ch !== '-') {\n          if (lineStart > start) offset = lineStart;\n          break;\n        }\n      } else if (ch === '-' && !this.error) {\n        // map key may start with -, as long as it's followed by a non-whitespace char\n        const next = src[offset + 1];\n\n        if (!next || next === '\\n' || next === '\\t' || next === ' ') {\n          const msg = 'A collection cannot be both a mapping and a sequence';\n          this.error = new PlainValue.YAMLSyntaxError(this, msg);\n        }\n      }\n\n      const node = parseNode({\n        atLineStart,\n        inCollection: true,\n        indent,\n        lineStart,\n        parent: this\n      }, offset);\n      if (!node) return offset; // at next document start\n\n      this.items.push(node);\n      this.valueRange.end = node.valueRange.end;\n      offset = PlainValue.Node.normalizeOffset(src, node.range.end);\n      ch = src[offset];\n      atLineStart = false;\n      prevIncludesTrailingLines = node.includesTrailingLines; // Need to reset lineStart and atLineStart here if preceding node's range\n      // has advanced to check the current line's indentation level\n      // -- eemeli/yaml#10 & eemeli/yaml#38\n\n      if (ch) {\n        let ls = offset - 1;\n        let prev = src[ls];\n\n        while (prev === ' ' || prev === '\\t') prev = src[--ls];\n\n        if (prev === '\\n') {\n          lineStart = ls + 1;\n          atLineStart = true;\n        }\n      }\n\n      const ec = grabCollectionEndComments(node);\n      if (ec) Array.prototype.push.apply(this.items, ec);\n    }\n\n    return offset;\n  }\n\n  setOrigRanges(cr, offset) {\n    offset = super.setOrigRanges(cr, offset);\n    this.items.forEach(node => {\n      offset = node.setOrigRanges(cr, offset);\n    });\n    return offset;\n  }\n\n  toString() {\n    const {\n      context: {\n        src\n      },\n      items,\n      range,\n      value\n    } = this;\n    if (value != null) return value;\n    let str = src.slice(range.start, items[0].range.start) + String(items[0]);\n\n    for (let i = 1; i < items.length; ++i) {\n      const item = items[i];\n      const {\n        atLineStart,\n        indent\n      } = item.context;\n      if (atLineStart) for (let i = 0; i < indent; ++i) str += ' ';\n      str += String(item);\n    }\n\n    return PlainValue.Node.addStringTerminator(src, range.end, str);\n  }\n\n}\n\nclass Directive extends PlainValue.Node {\n  constructor() {\n    super(PlainValue.Type.DIRECTIVE);\n    this.name = null;\n  }\n\n  get parameters() {\n    const raw = this.rawValue;\n    return raw ? raw.trim().split(/[ \\t]+/) : [];\n  }\n\n  parseName(start) {\n    const {\n      src\n    } = this.context;\n    let offset = start;\n    let ch = src[offset];\n\n    while (ch && ch !== '\\n' && ch !== '\\t' && ch !== ' ') ch = src[offset += 1];\n\n    this.name = src.slice(start, offset);\n    return offset;\n  }\n\n  parseParameters(start) {\n    const {\n      src\n    } = this.context;\n    let offset = start;\n    let ch = src[offset];\n\n    while (ch && ch !== '\\n' && ch !== '#') ch = src[offset += 1];\n\n    this.valueRange = new PlainValue.Range(start, offset);\n    return offset;\n  }\n\n  parse(context, start) {\n    this.context = context;\n    let offset = this.parseName(start + 1);\n    offset = this.parseParameters(offset);\n    offset = this.parseComment(offset);\n    this.range = new PlainValue.Range(start, offset);\n    return offset;\n  }\n\n}\n\nclass Document extends PlainValue.Node {\n  static startCommentOrEndBlankLine(src, start) {\n    const offset = PlainValue.Node.endOfWhiteSpace(src, start);\n    const ch = src[offset];\n    return ch === '#' || ch === '\\n' ? offset : start;\n  }\n\n  constructor() {\n    super(PlainValue.Type.DOCUMENT);\n    this.directives = null;\n    this.contents = null;\n    this.directivesEndMarker = null;\n    this.documentEndMarker = null;\n  }\n\n  parseDirectives(start) {\n    const {\n      src\n    } = this.context;\n    this.directives = [];\n    let atLineStart = true;\n    let hasDirectives = false;\n    let offset = start;\n\n    while (!PlainValue.Node.atDocumentBoundary(src, offset, PlainValue.Char.DIRECTIVES_END)) {\n      offset = Document.startCommentOrEndBlankLine(src, offset);\n\n      switch (src[offset]) {\n        case '\\n':\n          if (atLineStart) {\n            const blankLine = new BlankLine();\n            offset = blankLine.parse({\n              src\n            }, offset);\n\n            if (offset < src.length) {\n              this.directives.push(blankLine);\n            }\n          } else {\n            offset += 1;\n            atLineStart = true;\n          }\n\n          break;\n\n        case '#':\n          {\n            const comment = new Comment();\n            offset = comment.parse({\n              src\n            }, offset);\n            this.directives.push(comment);\n            atLineStart = false;\n          }\n          break;\n\n        case '%':\n          {\n            const directive = new Directive();\n            offset = directive.parse({\n              parent: this,\n              src\n            }, offset);\n            this.directives.push(directive);\n            hasDirectives = true;\n            atLineStart = false;\n          }\n          break;\n\n        default:\n          if (hasDirectives) {\n            this.error = new PlainValue.YAMLSemanticError(this, 'Missing directives-end indicator line');\n          } else if (this.directives.length > 0) {\n            this.contents = this.directives;\n            this.directives = [];\n          }\n\n          return offset;\n      }\n    }\n\n    if (src[offset]) {\n      this.directivesEndMarker = new PlainValue.Range(offset, offset + 3);\n      return offset + 3;\n    }\n\n    if (hasDirectives) {\n      this.error = new PlainValue.YAMLSemanticError(this, 'Missing directives-end indicator line');\n    } else if (this.directives.length > 0) {\n      this.contents = this.directives;\n      this.directives = [];\n    }\n\n    return offset;\n  }\n\n  parseContents(start) {\n    const {\n      parseNode,\n      src\n    } = this.context;\n    if (!this.contents) this.contents = [];\n    let lineStart = start;\n\n    while (src[lineStart - 1] === '-') lineStart -= 1;\n\n    let offset = PlainValue.Node.endOfWhiteSpace(src, start);\n    let atLineStart = lineStart === start;\n    this.valueRange = new PlainValue.Range(offset);\n\n    while (!PlainValue.Node.atDocumentBoundary(src, offset, PlainValue.Char.DOCUMENT_END)) {\n      switch (src[offset]) {\n        case '\\n':\n          if (atLineStart) {\n            const blankLine = new BlankLine();\n            offset = blankLine.parse({\n              src\n            }, offset);\n\n            if (offset < src.length) {\n              this.contents.push(blankLine);\n            }\n          } else {\n            offset += 1;\n            atLineStart = true;\n          }\n\n          lineStart = offset;\n          break;\n\n        case '#':\n          {\n            const comment = new Comment();\n            offset = comment.parse({\n              src\n            }, offset);\n            this.contents.push(comment);\n            atLineStart = false;\n          }\n          break;\n\n        default:\n          {\n            const iEnd = PlainValue.Node.endOfIndent(src, offset);\n            const context = {\n              atLineStart,\n              indent: -1,\n              inFlow: false,\n              inCollection: false,\n              lineStart,\n              parent: this\n            };\n            const node = parseNode(context, iEnd);\n            if (!node) return this.valueRange.end = iEnd; // at next document start\n\n            this.contents.push(node);\n            offset = node.range.end;\n            atLineStart = false;\n            const ec = grabCollectionEndComments(node);\n            if (ec) Array.prototype.push.apply(this.contents, ec);\n          }\n      }\n\n      offset = Document.startCommentOrEndBlankLine(src, offset);\n    }\n\n    this.valueRange.end = offset;\n\n    if (src[offset]) {\n      this.documentEndMarker = new PlainValue.Range(offset, offset + 3);\n      offset += 3;\n\n      if (src[offset]) {\n        offset = PlainValue.Node.endOfWhiteSpace(src, offset);\n\n        if (src[offset] === '#') {\n          const comment = new Comment();\n          offset = comment.parse({\n            src\n          }, offset);\n          this.contents.push(comment);\n        }\n\n        switch (src[offset]) {\n          case '\\n':\n            offset += 1;\n            break;\n\n          case undefined:\n            break;\n\n          default:\n            this.error = new PlainValue.YAMLSyntaxError(this, 'Document end marker line cannot have a non-comment suffix');\n        }\n      }\n    }\n\n    return offset;\n  }\n  /**\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this\n   */\n\n\n  parse(context, start) {\n    context.root = this;\n    this.context = context;\n    const {\n      src\n    } = context;\n    let offset = src.charCodeAt(start) === 0xfeff ? start + 1 : start; // skip BOM\n\n    offset = this.parseDirectives(offset);\n    offset = this.parseContents(offset);\n    return offset;\n  }\n\n  setOrigRanges(cr, offset) {\n    offset = super.setOrigRanges(cr, offset);\n    this.directives.forEach(node => {\n      offset = node.setOrigRanges(cr, offset);\n    });\n    if (this.directivesEndMarker) offset = this.directivesEndMarker.setOrigRange(cr, offset);\n    this.contents.forEach(node => {\n      offset = node.setOrigRanges(cr, offset);\n    });\n    if (this.documentEndMarker) offset = this.documentEndMarker.setOrigRange(cr, offset);\n    return offset;\n  }\n\n  toString() {\n    const {\n      contents,\n      directives,\n      value\n    } = this;\n    if (value != null) return value;\n    let str = directives.join('');\n\n    if (contents.length > 0) {\n      if (directives.length > 0 || contents[0].type === PlainValue.Type.COMMENT) str += '---\\n';\n      str += contents.join('');\n    }\n\n    if (str[str.length - 1] !== '\\n') str += '\\n';\n    return str;\n  }\n\n}\n\nclass Alias extends PlainValue.Node {\n  /**\n   * Parses an *alias from the source\n   *\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this scalar\n   */\n  parse(context, start) {\n    this.context = context;\n    const {\n      src\n    } = context;\n    let offset = PlainValue.Node.endOfIdentifier(src, start + 1);\n    this.valueRange = new PlainValue.Range(start + 1, offset);\n    offset = PlainValue.Node.endOfWhiteSpace(src, offset);\n    offset = this.parseComment(offset);\n    return offset;\n  }\n\n}\n\nconst Chomp = {\n  CLIP: 'CLIP',\n  KEEP: 'KEEP',\n  STRIP: 'STRIP'\n};\nclass BlockValue extends PlainValue.Node {\n  constructor(type, props) {\n    super(type, props);\n    this.blockIndent = null;\n    this.chomping = Chomp.CLIP;\n    this.header = null;\n  }\n\n  get includesTrailingLines() {\n    return this.chomping === Chomp.KEEP;\n  }\n\n  get strValue() {\n    if (!this.valueRange || !this.context) return null;\n    let {\n      start,\n      end\n    } = this.valueRange;\n    const {\n      indent,\n      src\n    } = this.context;\n    if (this.valueRange.isEmpty()) return '';\n    let lastNewLine = null;\n    let ch = src[end - 1];\n\n    while (ch === '\\n' || ch === '\\t' || ch === ' ') {\n      end -= 1;\n\n      if (end <= start) {\n        if (this.chomping === Chomp.KEEP) break;else return ''; // probably never happens\n      }\n\n      if (ch === '\\n') lastNewLine = end;\n      ch = src[end - 1];\n    }\n\n    let keepStart = end + 1;\n\n    if (lastNewLine) {\n      if (this.chomping === Chomp.KEEP) {\n        keepStart = lastNewLine;\n        end = this.valueRange.end;\n      } else {\n        end = lastNewLine;\n      }\n    }\n\n    const bi = indent + this.blockIndent;\n    const folded = this.type === PlainValue.Type.BLOCK_FOLDED;\n    let atStart = true;\n    let str = '';\n    let sep = '';\n    let prevMoreIndented = false;\n\n    for (let i = start; i < end; ++i) {\n      for (let j = 0; j < bi; ++j) {\n        if (src[i] !== ' ') break;\n        i += 1;\n      }\n\n      const ch = src[i];\n\n      if (ch === '\\n') {\n        if (sep === '\\n') str += '\\n';else sep = '\\n';\n      } else {\n        const lineEnd = PlainValue.Node.endOfLine(src, i);\n        const line = src.slice(i, lineEnd);\n        i = lineEnd;\n\n        if (folded && (ch === ' ' || ch === '\\t') && i < keepStart) {\n          if (sep === ' ') sep = '\\n';else if (!prevMoreIndented && !atStart && sep === '\\n') sep = '\\n\\n';\n          str += sep + line; //+ ((lineEnd < end && src[lineEnd]) || '')\n\n          sep = lineEnd < end && src[lineEnd] || '';\n          prevMoreIndented = true;\n        } else {\n          str += sep + line;\n          sep = folded && i < keepStart ? ' ' : '\\n';\n          prevMoreIndented = false;\n        }\n\n        if (atStart && line !== '') atStart = false;\n      }\n    }\n\n    return this.chomping === Chomp.STRIP ? str : str + '\\n';\n  }\n\n  parseBlockHeader(start) {\n    const {\n      src\n    } = this.context;\n    let offset = start + 1;\n    let bi = '';\n\n    while (true) {\n      const ch = src[offset];\n\n      switch (ch) {\n        case '-':\n          this.chomping = Chomp.STRIP;\n          break;\n\n        case '+':\n          this.chomping = Chomp.KEEP;\n          break;\n\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n          bi += ch;\n          break;\n\n        default:\n          this.blockIndent = Number(bi) || null;\n          this.header = new PlainValue.Range(start, offset);\n          return offset;\n      }\n\n      offset += 1;\n    }\n  }\n\n  parseBlockValue(start) {\n    const {\n      indent,\n      src\n    } = this.context;\n    const explicit = !!this.blockIndent;\n    let offset = start;\n    let valueEnd = start;\n    let minBlockIndent = 1;\n\n    for (let ch = src[offset]; ch === '\\n'; ch = src[offset]) {\n      offset += 1;\n      if (PlainValue.Node.atDocumentBoundary(src, offset)) break;\n      const end = PlainValue.Node.endOfBlockIndent(src, indent, offset); // should not include tab?\n\n      if (end === null) break;\n      const ch = src[end];\n      const lineIndent = end - (offset + indent);\n\n      if (!this.blockIndent) {\n        // no explicit block indent, none yet detected\n        if (src[end] !== '\\n') {\n          // first line with non-whitespace content\n          if (lineIndent < minBlockIndent) {\n            const msg = 'Block scalars with more-indented leading empty lines must use an explicit indentation indicator';\n            this.error = new PlainValue.YAMLSemanticError(this, msg);\n          }\n\n          this.blockIndent = lineIndent;\n        } else if (lineIndent > minBlockIndent) {\n          // empty line with more whitespace\n          minBlockIndent = lineIndent;\n        }\n      } else if (ch && ch !== '\\n' && lineIndent < this.blockIndent) {\n        if (src[end] === '#') break;\n\n        if (!this.error) {\n          const src = explicit ? 'explicit indentation indicator' : 'first line';\n          const msg = `Block scalars must not be less indented than their ${src}`;\n          this.error = new PlainValue.YAMLSemanticError(this, msg);\n        }\n      }\n\n      if (src[end] === '\\n') {\n        offset = end;\n      } else {\n        offset = valueEnd = PlainValue.Node.endOfLine(src, end);\n      }\n    }\n\n    if (this.chomping !== Chomp.KEEP) {\n      offset = src[valueEnd] ? valueEnd + 1 : valueEnd;\n    }\n\n    this.valueRange = new PlainValue.Range(start + 1, offset);\n    return offset;\n  }\n  /**\n   * Parses a block value from the source\n   *\n   * Accepted forms are:\n   * ```\n   * BS\n   * block\n   * lines\n   *\n   * BS #comment\n   * block\n   * lines\n   * ```\n   * where the block style BS matches the regexp `[|>][-+1-9]*` and block lines\n   * are empty or have an indent level greater than `indent`.\n   *\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this block\n   */\n\n\n  parse(context, start) {\n    this.context = context;\n    const {\n      src\n    } = context;\n    let offset = this.parseBlockHeader(start);\n    offset = PlainValue.Node.endOfWhiteSpace(src, offset);\n    offset = this.parseComment(offset);\n    offset = this.parseBlockValue(offset);\n    return offset;\n  }\n\n  setOrigRanges(cr, offset) {\n    offset = super.setOrigRanges(cr, offset);\n    return this.header ? this.header.setOrigRange(cr, offset) : offset;\n  }\n\n}\n\nclass FlowCollection extends PlainValue.Node {\n  constructor(type, props) {\n    super(type, props);\n    this.items = null;\n  }\n\n  prevNodeIsJsonLike(idx = this.items.length) {\n    const node = this.items[idx - 1];\n    return !!node && (node.jsonLike || node.type === PlainValue.Type.COMMENT && this.prevNodeIsJsonLike(idx - 1));\n  }\n  /**\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this\n   */\n\n\n  parse(context, start) {\n    this.context = context;\n    const {\n      parseNode,\n      src\n    } = context;\n    let {\n      indent,\n      lineStart\n    } = context;\n    let char = src[start]; // { or [\n\n    this.items = [{\n      char,\n      offset: start\n    }];\n    let offset = PlainValue.Node.endOfWhiteSpace(src, start + 1);\n    char = src[offset];\n\n    while (char && char !== ']' && char !== '}') {\n      switch (char) {\n        case '\\n':\n          {\n            lineStart = offset + 1;\n            const wsEnd = PlainValue.Node.endOfWhiteSpace(src, lineStart);\n\n            if (src[wsEnd] === '\\n') {\n              const blankLine = new BlankLine();\n              lineStart = blankLine.parse({\n                src\n              }, lineStart);\n              this.items.push(blankLine);\n            }\n\n            offset = PlainValue.Node.endOfIndent(src, lineStart);\n\n            if (offset <= lineStart + indent) {\n              char = src[offset];\n\n              if (offset < lineStart + indent || char !== ']' && char !== '}') {\n                const msg = 'Insufficient indentation in flow collection';\n                this.error = new PlainValue.YAMLSemanticError(this, msg);\n              }\n            }\n          }\n          break;\n\n        case ',':\n          {\n            this.items.push({\n              char,\n              offset\n            });\n            offset += 1;\n          }\n          break;\n\n        case '#':\n          {\n            const comment = new Comment();\n            offset = comment.parse({\n              src\n            }, offset);\n            this.items.push(comment);\n          }\n          break;\n\n        case '?':\n        case ':':\n          {\n            const next = src[offset + 1];\n\n            if (next === '\\n' || next === '\\t' || next === ' ' || next === ',' || // in-flow : after JSON-like key does not need to be followed by whitespace\n            char === ':' && this.prevNodeIsJsonLike()) {\n              this.items.push({\n                char,\n                offset\n              });\n              offset += 1;\n              break;\n            }\n          }\n        // fallthrough\n\n        default:\n          {\n            const node = parseNode({\n              atLineStart: false,\n              inCollection: false,\n              inFlow: true,\n              indent: -1,\n              lineStart,\n              parent: this\n            }, offset);\n\n            if (!node) {\n              // at next document start\n              this.valueRange = new PlainValue.Range(start, offset);\n              return offset;\n            }\n\n            this.items.push(node);\n            offset = PlainValue.Node.normalizeOffset(src, node.range.end);\n          }\n      }\n\n      offset = PlainValue.Node.endOfWhiteSpace(src, offset);\n      char = src[offset];\n    }\n\n    this.valueRange = new PlainValue.Range(start, offset + 1);\n\n    if (char) {\n      this.items.push({\n        char,\n        offset\n      });\n      offset = PlainValue.Node.endOfWhiteSpace(src, offset + 1);\n      offset = this.parseComment(offset);\n    }\n\n    return offset;\n  }\n\n  setOrigRanges(cr, offset) {\n    offset = super.setOrigRanges(cr, offset);\n    this.items.forEach(node => {\n      if (node instanceof PlainValue.Node) {\n        offset = node.setOrigRanges(cr, offset);\n      } else if (cr.length === 0) {\n        node.origOffset = node.offset;\n      } else {\n        let i = offset;\n\n        while (i < cr.length) {\n          if (cr[i] > node.offset) break;else ++i;\n        }\n\n        node.origOffset = node.offset + i;\n        offset = i;\n      }\n    });\n    return offset;\n  }\n\n  toString() {\n    const {\n      context: {\n        src\n      },\n      items,\n      range,\n      value\n    } = this;\n    if (value != null) return value;\n    const nodes = items.filter(item => item instanceof PlainValue.Node);\n    let str = '';\n    let prevEnd = range.start;\n    nodes.forEach(node => {\n      const prefix = src.slice(prevEnd, node.range.start);\n      prevEnd = node.range.end;\n      str += prefix + String(node);\n\n      if (str[str.length - 1] === '\\n' && src[prevEnd - 1] !== '\\n' && src[prevEnd] === '\\n') {\n        // Comment range does not include the terminal newline, but its\n        // stringified value does. Without this fix, newlines at comment ends\n        // get duplicated.\n        prevEnd += 1;\n      }\n    });\n    str += src.slice(prevEnd, range.end);\n    return PlainValue.Node.addStringTerminator(src, range.end, str);\n  }\n\n}\n\nclass QuoteDouble extends PlainValue.Node {\n  static endOfQuote(src, offset) {\n    let ch = src[offset];\n\n    while (ch && ch !== '\"') {\n      offset += ch === '\\\\' ? 2 : 1;\n      ch = src[offset];\n    }\n\n    return offset + 1;\n  }\n  /**\n   * @returns {string | { str: string, errors: YAMLSyntaxError[] }}\n   */\n\n\n  get strValue() {\n    if (!this.valueRange || !this.context) return null;\n    const errors = [];\n    const {\n      start,\n      end\n    } = this.valueRange;\n    const {\n      indent,\n      src\n    } = this.context;\n    if (src[end - 1] !== '\"') errors.push(new PlainValue.YAMLSyntaxError(this, 'Missing closing \"quote')); // Using String#replace is too painful with escaped newlines preceded by\n    // escaped backslashes; also, this should be faster.\n\n    let str = '';\n\n    for (let i = start + 1; i < end - 1; ++i) {\n      const ch = src[i];\n\n      if (ch === '\\n') {\n        if (PlainValue.Node.atDocumentBoundary(src, i + 1)) errors.push(new PlainValue.YAMLSemanticError(this, 'Document boundary indicators are not allowed within string values'));\n        const {\n          fold,\n          offset,\n          error\n        } = PlainValue.Node.foldNewline(src, i, indent);\n        str += fold;\n        i = offset;\n        if (error) errors.push(new PlainValue.YAMLSemanticError(this, 'Multi-line double-quoted string needs to be sufficiently indented'));\n      } else if (ch === '\\\\') {\n        i += 1;\n\n        switch (src[i]) {\n          case '0':\n            str += '\\0';\n            break;\n          // null character\n\n          case 'a':\n            str += '\\x07';\n            break;\n          // bell character\n\n          case 'b':\n            str += '\\b';\n            break;\n          // backspace\n\n          case 'e':\n            str += '\\x1b';\n            break;\n          // escape character\n\n          case 'f':\n            str += '\\f';\n            break;\n          // form feed\n\n          case 'n':\n            str += '\\n';\n            break;\n          // line feed\n\n          case 'r':\n            str += '\\r';\n            break;\n          // carriage return\n\n          case 't':\n            str += '\\t';\n            break;\n          // horizontal tab\n\n          case 'v':\n            str += '\\v';\n            break;\n          // vertical tab\n\n          case 'N':\n            str += '\\u0085';\n            break;\n          // Unicode next line\n\n          case '_':\n            str += '\\u00a0';\n            break;\n          // Unicode non-breaking space\n\n          case 'L':\n            str += '\\u2028';\n            break;\n          // Unicode line separator\n\n          case 'P':\n            str += '\\u2029';\n            break;\n          // Unicode paragraph separator\n\n          case ' ':\n            str += ' ';\n            break;\n\n          case '\"':\n            str += '\"';\n            break;\n\n          case '/':\n            str += '/';\n            break;\n\n          case '\\\\':\n            str += '\\\\';\n            break;\n\n          case '\\t':\n            str += '\\t';\n            break;\n\n          case 'x':\n            str += this.parseCharCode(i + 1, 2, errors);\n            i += 2;\n            break;\n\n          case 'u':\n            str += this.parseCharCode(i + 1, 4, errors);\n            i += 4;\n            break;\n\n          case 'U':\n            str += this.parseCharCode(i + 1, 8, errors);\n            i += 8;\n            break;\n\n          case '\\n':\n            // skip escaped newlines, but still trim the following line\n            while (src[i + 1] === ' ' || src[i + 1] === '\\t') i += 1;\n\n            break;\n\n          default:\n            errors.push(new PlainValue.YAMLSyntaxError(this, `Invalid escape sequence ${src.substr(i - 1, 2)}`));\n            str += '\\\\' + src[i];\n        }\n      } else if (ch === ' ' || ch === '\\t') {\n        // trim trailing whitespace\n        const wsStart = i;\n        let next = src[i + 1];\n\n        while (next === ' ' || next === '\\t') {\n          i += 1;\n          next = src[i + 1];\n        }\n\n        if (next !== '\\n') str += i > wsStart ? src.slice(wsStart, i + 1) : ch;\n      } else {\n        str += ch;\n      }\n    }\n\n    return errors.length > 0 ? {\n      errors,\n      str\n    } : str;\n  }\n\n  parseCharCode(offset, length, errors) {\n    const {\n      src\n    } = this.context;\n    const cc = src.substr(offset, length);\n    const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);\n    const code = ok ? parseInt(cc, 16) : NaN;\n\n    if (isNaN(code)) {\n      errors.push(new PlainValue.YAMLSyntaxError(this, `Invalid escape sequence ${src.substr(offset - 2, length + 2)}`));\n      return src.substr(offset - 2, length + 2);\n    }\n\n    return String.fromCodePoint(code);\n  }\n  /**\n   * Parses a \"double quoted\" value from the source\n   *\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this scalar\n   */\n\n\n  parse(context, start) {\n    this.context = context;\n    const {\n      src\n    } = context;\n    let offset = QuoteDouble.endOfQuote(src, start + 1);\n    this.valueRange = new PlainValue.Range(start, offset);\n    offset = PlainValue.Node.endOfWhiteSpace(src, offset);\n    offset = this.parseComment(offset);\n    return offset;\n  }\n\n}\n\nclass QuoteSingle extends PlainValue.Node {\n  static endOfQuote(src, offset) {\n    let ch = src[offset];\n\n    while (ch) {\n      if (ch === \"'\") {\n        if (src[offset + 1] !== \"'\") break;\n        ch = src[offset += 2];\n      } else {\n        ch = src[offset += 1];\n      }\n    }\n\n    return offset + 1;\n  }\n  /**\n   * @returns {string | { str: string, errors: YAMLSyntaxError[] }}\n   */\n\n\n  get strValue() {\n    if (!this.valueRange || !this.context) return null;\n    const errors = [];\n    const {\n      start,\n      end\n    } = this.valueRange;\n    const {\n      indent,\n      src\n    } = this.context;\n    if (src[end - 1] !== \"'\") errors.push(new PlainValue.YAMLSyntaxError(this, \"Missing closing 'quote\"));\n    let str = '';\n\n    for (let i = start + 1; i < end - 1; ++i) {\n      const ch = src[i];\n\n      if (ch === '\\n') {\n        if (PlainValue.Node.atDocumentBoundary(src, i + 1)) errors.push(new PlainValue.YAMLSemanticError(this, 'Document boundary indicators are not allowed within string values'));\n        const {\n          fold,\n          offset,\n          error\n        } = PlainValue.Node.foldNewline(src, i, indent);\n        str += fold;\n        i = offset;\n        if (error) errors.push(new PlainValue.YAMLSemanticError(this, 'Multi-line single-quoted string needs to be sufficiently indented'));\n      } else if (ch === \"'\") {\n        str += ch;\n        i += 1;\n        if (src[i] !== \"'\") errors.push(new PlainValue.YAMLSyntaxError(this, 'Unescaped single quote? This should not happen.'));\n      } else if (ch === ' ' || ch === '\\t') {\n        // trim trailing whitespace\n        const wsStart = i;\n        let next = src[i + 1];\n\n        while (next === ' ' || next === '\\t') {\n          i += 1;\n          next = src[i + 1];\n        }\n\n        if (next !== '\\n') str += i > wsStart ? src.slice(wsStart, i + 1) : ch;\n      } else {\n        str += ch;\n      }\n    }\n\n    return errors.length > 0 ? {\n      errors,\n      str\n    } : str;\n  }\n  /**\n   * Parses a 'single quoted' value from the source\n   *\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this scalar\n   */\n\n\n  parse(context, start) {\n    this.context = context;\n    const {\n      src\n    } = context;\n    let offset = QuoteSingle.endOfQuote(src, start + 1);\n    this.valueRange = new PlainValue.Range(start, offset);\n    offset = PlainValue.Node.endOfWhiteSpace(src, offset);\n    offset = this.parseComment(offset);\n    return offset;\n  }\n\n}\n\nfunction createNewNode(type, props) {\n  switch (type) {\n    case PlainValue.Type.ALIAS:\n      return new Alias(type, props);\n\n    case PlainValue.Type.BLOCK_FOLDED:\n    case PlainValue.Type.BLOCK_LITERAL:\n      return new BlockValue(type, props);\n\n    case PlainValue.Type.FLOW_MAP:\n    case PlainValue.Type.FLOW_SEQ:\n      return new FlowCollection(type, props);\n\n    case PlainValue.Type.MAP_KEY:\n    case PlainValue.Type.MAP_VALUE:\n    case PlainValue.Type.SEQ_ITEM:\n      return new CollectionItem(type, props);\n\n    case PlainValue.Type.COMMENT:\n    case PlainValue.Type.PLAIN:\n      return new PlainValue.PlainValue(type, props);\n\n    case PlainValue.Type.QUOTE_DOUBLE:\n      return new QuoteDouble(type, props);\n\n    case PlainValue.Type.QUOTE_SINGLE:\n      return new QuoteSingle(type, props);\n\n    /* istanbul ignore next */\n\n    default:\n      return null;\n    // should never happen\n  }\n}\n/**\n * @param {boolean} atLineStart - Node starts at beginning of line\n * @param {boolean} inFlow - true if currently in a flow context\n * @param {boolean} inCollection - true if currently in a collection context\n * @param {number} indent - Current level of indentation\n * @param {number} lineStart - Start of the current line\n * @param {Node} parent - The parent of the node\n * @param {string} src - Source of the YAML document\n */\n\n\nclass ParseContext {\n  static parseType(src, offset, inFlow) {\n    switch (src[offset]) {\n      case '*':\n        return PlainValue.Type.ALIAS;\n\n      case '>':\n        return PlainValue.Type.BLOCK_FOLDED;\n\n      case '|':\n        return PlainValue.Type.BLOCK_LITERAL;\n\n      case '{':\n        return PlainValue.Type.FLOW_MAP;\n\n      case '[':\n        return PlainValue.Type.FLOW_SEQ;\n\n      case '?':\n        return !inFlow && PlainValue.Node.atBlank(src, offset + 1, true) ? PlainValue.Type.MAP_KEY : PlainValue.Type.PLAIN;\n\n      case ':':\n        return !inFlow && PlainValue.Node.atBlank(src, offset + 1, true) ? PlainValue.Type.MAP_VALUE : PlainValue.Type.PLAIN;\n\n      case '-':\n        return !inFlow && PlainValue.Node.atBlank(src, offset + 1, true) ? PlainValue.Type.SEQ_ITEM : PlainValue.Type.PLAIN;\n\n      case '\"':\n        return PlainValue.Type.QUOTE_DOUBLE;\n\n      case \"'\":\n        return PlainValue.Type.QUOTE_SINGLE;\n\n      default:\n        return PlainValue.Type.PLAIN;\n    }\n  }\n\n  constructor(orig = {}, {\n    atLineStart,\n    inCollection,\n    inFlow,\n    indent,\n    lineStart,\n    parent\n  } = {}) {\n    PlainValue._defineProperty(this, \"parseNode\", (overlay, start) => {\n      if (PlainValue.Node.atDocumentBoundary(this.src, start)) return null;\n      const context = new ParseContext(this, overlay);\n      const {\n        props,\n        type,\n        valueStart\n      } = context.parseProps(start);\n      const node = createNewNode(type, props);\n      let offset = node.parse(context, valueStart);\n      node.range = new PlainValue.Range(start, offset);\n      /* istanbul ignore if */\n\n      if (offset <= start) {\n        // This should never happen, but if it does, let's make sure to at least\n        // step one character forward to avoid a busy loop.\n        node.error = new Error(`Node#parse consumed no characters`);\n        node.error.parseEnd = offset;\n        node.error.source = node;\n        node.range.end = start + 1;\n      }\n\n      if (context.nodeStartsCollection(node)) {\n        if (!node.error && !context.atLineStart && context.parent.type === PlainValue.Type.DOCUMENT) {\n          node.error = new PlainValue.YAMLSyntaxError(node, 'Block collection must not have preceding content here (e.g. directives-end indicator)');\n        }\n\n        const collection = new Collection(node);\n        offset = collection.parse(new ParseContext(context), offset);\n        collection.range = new PlainValue.Range(start, offset);\n        return collection;\n      }\n\n      return node;\n    });\n\n    this.atLineStart = atLineStart != null ? atLineStart : orig.atLineStart || false;\n    this.inCollection = inCollection != null ? inCollection : orig.inCollection || false;\n    this.inFlow = inFlow != null ? inFlow : orig.inFlow || false;\n    this.indent = indent != null ? indent : orig.indent;\n    this.lineStart = lineStart != null ? lineStart : orig.lineStart;\n    this.parent = parent != null ? parent : orig.parent || {};\n    this.root = orig.root;\n    this.src = orig.src;\n  }\n\n  nodeStartsCollection(node) {\n    const {\n      inCollection,\n      inFlow,\n      src\n    } = this;\n    if (inCollection || inFlow) return false;\n    if (node instanceof CollectionItem) return true; // check for implicit key\n\n    let offset = node.range.end;\n    if (src[offset] === '\\n' || src[offset - 1] === '\\n') return false;\n    offset = PlainValue.Node.endOfWhiteSpace(src, offset);\n    return src[offset] === ':';\n  } // Anchor and tag are before type, which determines the node implementation\n  // class; hence this intermediate step.\n\n\n  parseProps(offset) {\n    const {\n      inFlow,\n      parent,\n      src\n    } = this;\n    const props = [];\n    let lineHasProps = false;\n    offset = this.atLineStart ? PlainValue.Node.endOfIndent(src, offset) : PlainValue.Node.endOfWhiteSpace(src, offset);\n    let ch = src[offset];\n\n    while (ch === PlainValue.Char.ANCHOR || ch === PlainValue.Char.COMMENT || ch === PlainValue.Char.TAG || ch === '\\n') {\n      if (ch === '\\n') {\n        let inEnd = offset;\n        let lineStart;\n\n        do {\n          lineStart = inEnd + 1;\n          inEnd = PlainValue.Node.endOfIndent(src, lineStart);\n        } while (src[inEnd] === '\\n');\n\n        const indentDiff = inEnd - (lineStart + this.indent);\n        const noIndicatorAsIndent = parent.type === PlainValue.Type.SEQ_ITEM && parent.context.atLineStart;\n        if (src[inEnd] !== '#' && !PlainValue.Node.nextNodeIsIndented(src[inEnd], indentDiff, !noIndicatorAsIndent)) break;\n        this.atLineStart = true;\n        this.lineStart = lineStart;\n        lineHasProps = false;\n        offset = inEnd;\n      } else if (ch === PlainValue.Char.COMMENT) {\n        const end = PlainValue.Node.endOfLine(src, offset + 1);\n        props.push(new PlainValue.Range(offset, end));\n        offset = end;\n      } else {\n        let end = PlainValue.Node.endOfIdentifier(src, offset + 1);\n\n        if (ch === PlainValue.Char.TAG && src[end] === ',' && /^[a-zA-Z0-9-]+\\.[a-zA-Z0-9-]+,\\d\\d\\d\\d(-\\d\\d){0,2}\\/\\S/.test(src.slice(offset + 1, end + 13))) {\n          // Let's presume we're dealing with a YAML 1.0 domain tag here, rather\n          // than an empty but 'foo.bar' private-tagged node in a flow collection\n          // followed without whitespace by a plain string starting with a year\n          // or date divided by something.\n          end = PlainValue.Node.endOfIdentifier(src, end + 5);\n        }\n\n        props.push(new PlainValue.Range(offset, end));\n        lineHasProps = true;\n        offset = PlainValue.Node.endOfWhiteSpace(src, end);\n      }\n\n      ch = src[offset];\n    } // '- &a : b' has an anchor on an empty node\n\n\n    if (lineHasProps && ch === ':' && PlainValue.Node.atBlank(src, offset + 1, true)) offset -= 1;\n    const type = ParseContext.parseType(src, offset, inFlow);\n    return {\n      props,\n      type,\n      valueStart: offset\n    };\n  }\n  /**\n   * Parses a node from the source\n   * @param {ParseContext} overlay\n   * @param {number} start - Index of first non-whitespace character for the node\n   * @returns {?Node} - null if at a document boundary\n   */\n\n\n}\n\n// Published as 'yaml/parse-cst'\nfunction parse(src) {\n  const cr = [];\n\n  if (src.indexOf('\\r') !== -1) {\n    src = src.replace(/\\r\\n?/g, (match, offset) => {\n      if (match.length > 1) cr.push(offset);\n      return '\\n';\n    });\n  }\n\n  const documents = [];\n  let offset = 0;\n\n  do {\n    const doc = new Document();\n    const context = new ParseContext({\n      src\n    });\n    offset = doc.parse(context, offset);\n    documents.push(doc);\n  } while (offset < src.length);\n\n  documents.setOrigRanges = () => {\n    if (cr.length === 0) return false;\n\n    for (let i = 1; i < cr.length; ++i) cr[i] -= i;\n\n    let crOffset = 0;\n\n    for (let i = 0; i < documents.length; ++i) {\n      crOffset = documents[i].setOrigRanges(cr, crOffset);\n    }\n\n    cr.splice(0, cr.length);\n    return true;\n  };\n\n  documents.toString = () => documents.join('...\\n');\n\n  return documents;\n}\n\nexports.parse = parse;\n", "'use strict';\n\nvar PlainValue = require('./PlainValue-ec8e588e.js');\n\nfunction addCommentBefore(str, indent, comment) {\n  if (!comment) return str;\n  const cc = comment.replace(/[\\s\\S]^/gm, `$&${indent}#`);\n  return `#${cc}\\n${indent}${str}`;\n}\nfunction addComment(str, indent, comment) {\n  return !comment ? str : comment.indexOf('\\n') === -1 ? `${str} #${comment}` : `${str}\\n` + comment.replace(/^/gm, `${indent || ''}#`);\n}\n\nclass Node {}\n\nfunction toJSON(value, arg, ctx) {\n  if (Array.isArray(value)) return value.map((v, i) => toJSON(v, String(i), ctx));\n\n  if (value && typeof value.toJSON === 'function') {\n    const anchor = ctx && ctx.anchors && ctx.anchors.get(value);\n    if (anchor) ctx.onCreate = res => {\n      anchor.res = res;\n      delete ctx.onCreate;\n    };\n    const res = value.toJSON(arg, ctx);\n    if (anchor && ctx.onCreate) ctx.onCreate(res);\n    return res;\n  }\n\n  if ((!ctx || !ctx.keep) && typeof value === 'bigint') return Number(value);\n  return value;\n}\n\nclass Scalar extends Node {\n  constructor(value) {\n    super();\n    this.value = value;\n  }\n\n  toJSON(arg, ctx) {\n    return ctx && ctx.keep ? this.value : toJSON(this.value, arg, ctx);\n  }\n\n  toString() {\n    return String(this.value);\n  }\n\n}\n\nfunction collectionFromPath(schema, path, value) {\n  let v = value;\n\n  for (let i = path.length - 1; i >= 0; --i) {\n    const k = path[i];\n\n    if (Number.isInteger(k) && k >= 0) {\n      const a = [];\n      a[k] = v;\n      v = a;\n    } else {\n      const o = {};\n      Object.defineProperty(o, k, {\n        value: v,\n        writable: true,\n        enumerable: true,\n        configurable: true\n      });\n      v = o;\n    }\n  }\n\n  return schema.createNode(v, false);\n} // null, undefined, or an empty non-string iterable (e.g. [])\n\n\nconst isEmptyPath = path => path == null || typeof path === 'object' && path[Symbol.iterator]().next().done;\nclass Collection extends Node {\n  constructor(schema) {\n    super();\n\n    PlainValue._defineProperty(this, \"items\", []);\n\n    this.schema = schema;\n  }\n\n  addIn(path, value) {\n    if (isEmptyPath(path)) this.add(value);else {\n      const [key, ...rest] = path;\n      const node = this.get(key, true);\n      if (node instanceof Collection) node.addIn(rest, value);else if (node === undefined && this.schema) this.set(key, collectionFromPath(this.schema, rest, value));else throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);\n    }\n  }\n\n  deleteIn([key, ...rest]) {\n    if (rest.length === 0) return this.delete(key);\n    const node = this.get(key, true);\n    if (node instanceof Collection) return node.deleteIn(rest);else throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);\n  }\n\n  getIn([key, ...rest], keepScalar) {\n    const node = this.get(key, true);\n    if (rest.length === 0) return !keepScalar && node instanceof Scalar ? node.value : node;else return node instanceof Collection ? node.getIn(rest, keepScalar) : undefined;\n  }\n\n  hasAllNullValues() {\n    return this.items.every(node => {\n      if (!node || node.type !== 'PAIR') return false;\n      const n = node.value;\n      return n == null || n instanceof Scalar && n.value == null && !n.commentBefore && !n.comment && !n.tag;\n    });\n  }\n\n  hasIn([key, ...rest]) {\n    if (rest.length === 0) return this.has(key);\n    const node = this.get(key, true);\n    return node instanceof Collection ? node.hasIn(rest) : false;\n  }\n\n  setIn([key, ...rest], value) {\n    if (rest.length === 0) {\n      this.set(key, value);\n    } else {\n      const node = this.get(key, true);\n      if (node instanceof Collection) node.setIn(rest, value);else if (node === undefined && this.schema) this.set(key, collectionFromPath(this.schema, rest, value));else throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);\n    }\n  } // overridden in implementations\n\n  /* istanbul ignore next */\n\n\n  toJSON() {\n    return null;\n  }\n\n  toString(ctx, {\n    blockItem,\n    flowChars,\n    isMap,\n    itemIndent\n  }, onComment, onChompKeep) {\n    const {\n      indent,\n      indentStep,\n      stringify\n    } = ctx;\n    const inFlow = this.type === PlainValue.Type.FLOW_MAP || this.type === PlainValue.Type.FLOW_SEQ || ctx.inFlow;\n    if (inFlow) itemIndent += indentStep;\n    const allNullValues = isMap && this.hasAllNullValues();\n    ctx = Object.assign({}, ctx, {\n      allNullValues,\n      indent: itemIndent,\n      inFlow,\n      type: null\n    });\n    let chompKeep = false;\n    let hasItemWithNewLine = false;\n    const nodes = this.items.reduce((nodes, item, i) => {\n      let comment;\n\n      if (item) {\n        if (!chompKeep && item.spaceBefore) nodes.push({\n          type: 'comment',\n          str: ''\n        });\n        if (item.commentBefore) item.commentBefore.match(/^.*$/gm).forEach(line => {\n          nodes.push({\n            type: 'comment',\n            str: `#${line}`\n          });\n        });\n        if (item.comment) comment = item.comment;\n        if (inFlow && (!chompKeep && item.spaceBefore || item.commentBefore || item.comment || item.key && (item.key.commentBefore || item.key.comment) || item.value && (item.value.commentBefore || item.value.comment))) hasItemWithNewLine = true;\n      }\n\n      chompKeep = false;\n      let str = stringify(item, ctx, () => comment = null, () => chompKeep = true);\n      if (inFlow && !hasItemWithNewLine && str.includes('\\n')) hasItemWithNewLine = true;\n      if (inFlow && i < this.items.length - 1) str += ',';\n      str = addComment(str, itemIndent, comment);\n      if (chompKeep && (comment || inFlow)) chompKeep = false;\n      nodes.push({\n        type: 'item',\n        str\n      });\n      return nodes;\n    }, []);\n    let str;\n\n    if (nodes.length === 0) {\n      str = flowChars.start + flowChars.end;\n    } else if (inFlow) {\n      const {\n        start,\n        end\n      } = flowChars;\n      const strings = nodes.map(n => n.str);\n\n      if (hasItemWithNewLine || strings.reduce((sum, str) => sum + str.length + 2, 2) > Collection.maxFlowStringSingleLineLength) {\n        str = start;\n\n        for (const s of strings) {\n          str += s ? `\\n${indentStep}${indent}${s}` : '\\n';\n        }\n\n        str += `\\n${indent}${end}`;\n      } else {\n        str = `${start} ${strings.join(' ')} ${end}`;\n      }\n    } else {\n      const strings = nodes.map(blockItem);\n      str = strings.shift();\n\n      for (const s of strings) str += s ? `\\n${indent}${s}` : '\\n';\n    }\n\n    if (this.comment) {\n      str += '\\n' + this.comment.replace(/^/gm, `${indent}#`);\n      if (onComment) onComment();\n    } else if (chompKeep && onChompKeep) onChompKeep();\n\n    return str;\n  }\n\n}\n\nPlainValue._defineProperty(Collection, \"maxFlowStringSingleLineLength\", 60);\n\nfunction asItemIndex(key) {\n  let idx = key instanceof Scalar ? key.value : key;\n  if (idx && typeof idx === 'string') idx = Number(idx);\n  return Number.isInteger(idx) && idx >= 0 ? idx : null;\n}\n\nclass YAMLSeq extends Collection {\n  add(value) {\n    this.items.push(value);\n  }\n\n  delete(key) {\n    const idx = asItemIndex(key);\n    if (typeof idx !== 'number') return false;\n    const del = this.items.splice(idx, 1);\n    return del.length > 0;\n  }\n\n  get(key, keepScalar) {\n    const idx = asItemIndex(key);\n    if (typeof idx !== 'number') return undefined;\n    const it = this.items[idx];\n    return !keepScalar && it instanceof Scalar ? it.value : it;\n  }\n\n  has(key) {\n    const idx = asItemIndex(key);\n    return typeof idx === 'number' && idx < this.items.length;\n  }\n\n  set(key, value) {\n    const idx = asItemIndex(key);\n    if (typeof idx !== 'number') throw new Error(`Expected a valid index, not ${key}.`);\n    this.items[idx] = value;\n  }\n\n  toJSON(_, ctx) {\n    const seq = [];\n    if (ctx && ctx.onCreate) ctx.onCreate(seq);\n    let i = 0;\n\n    for (const item of this.items) seq.push(toJSON(item, String(i++), ctx));\n\n    return seq;\n  }\n\n  toString(ctx, onComment, onChompKeep) {\n    if (!ctx) return JSON.stringify(this);\n    return super.toString(ctx, {\n      blockItem: n => n.type === 'comment' ? n.str : `- ${n.str}`,\n      flowChars: {\n        start: '[',\n        end: ']'\n      },\n      isMap: false,\n      itemIndent: (ctx.indent || '') + '  '\n    }, onComment, onChompKeep);\n  }\n\n}\n\nconst stringifyKey = (key, jsKey, ctx) => {\n  if (jsKey === null) return '';\n  if (typeof jsKey !== 'object') return String(jsKey);\n  if (key instanceof Node && ctx && ctx.doc) return key.toString({\n    anchors: Object.create(null),\n    doc: ctx.doc,\n    indent: '',\n    indentStep: ctx.indentStep,\n    inFlow: true,\n    inStringifyKey: true,\n    stringify: ctx.stringify\n  });\n  return JSON.stringify(jsKey);\n};\n\nclass Pair extends Node {\n  constructor(key, value = null) {\n    super();\n    this.key = key;\n    this.value = value;\n    this.type = Pair.Type.PAIR;\n  }\n\n  get commentBefore() {\n    return this.key instanceof Node ? this.key.commentBefore : undefined;\n  }\n\n  set commentBefore(cb) {\n    if (this.key == null) this.key = new Scalar(null);\n    if (this.key instanceof Node) this.key.commentBefore = cb;else {\n      const msg = 'Pair.commentBefore is an alias for Pair.key.commentBefore. To set it, the key must be a Node.';\n      throw new Error(msg);\n    }\n  }\n\n  addToJSMap(ctx, map) {\n    const key = toJSON(this.key, '', ctx);\n\n    if (map instanceof Map) {\n      const value = toJSON(this.value, key, ctx);\n      map.set(key, value);\n    } else if (map instanceof Set) {\n      map.add(key);\n    } else {\n      const stringKey = stringifyKey(this.key, key, ctx);\n      const value = toJSON(this.value, stringKey, ctx);\n      if (stringKey in map) Object.defineProperty(map, stringKey, {\n        value,\n        writable: true,\n        enumerable: true,\n        configurable: true\n      });else map[stringKey] = value;\n    }\n\n    return map;\n  }\n\n  toJSON(_, ctx) {\n    const pair = ctx && ctx.mapAsMap ? new Map() : {};\n    return this.addToJSMap(ctx, pair);\n  }\n\n  toString(ctx, onComment, onChompKeep) {\n    if (!ctx || !ctx.doc) return JSON.stringify(this);\n    const {\n      indent: indentSize,\n      indentSeq,\n      simpleKeys\n    } = ctx.doc.options;\n    let {\n      key,\n      value\n    } = this;\n    let keyComment = key instanceof Node && key.comment;\n\n    if (simpleKeys) {\n      if (keyComment) {\n        throw new Error('With simple keys, key nodes cannot have comments');\n      }\n\n      if (key instanceof Collection) {\n        const msg = 'With simple keys, collection cannot be used as a key value';\n        throw new Error(msg);\n      }\n    }\n\n    let explicitKey = !simpleKeys && (!key || keyComment || (key instanceof Node ? key instanceof Collection || key.type === PlainValue.Type.BLOCK_FOLDED || key.type === PlainValue.Type.BLOCK_LITERAL : typeof key === 'object'));\n    const {\n      doc,\n      indent,\n      indentStep,\n      stringify\n    } = ctx;\n    ctx = Object.assign({}, ctx, {\n      implicitKey: !explicitKey,\n      indent: indent + indentStep\n    });\n    let chompKeep = false;\n    let str = stringify(key, ctx, () => keyComment = null, () => chompKeep = true);\n    str = addComment(str, ctx.indent, keyComment);\n\n    if (!explicitKey && str.length > 1024) {\n      if (simpleKeys) throw new Error('With simple keys, single line scalar must not span more than 1024 characters');\n      explicitKey = true;\n    }\n\n    if (ctx.allNullValues && !simpleKeys) {\n      if (this.comment) {\n        str = addComment(str, ctx.indent, this.comment);\n        if (onComment) onComment();\n      } else if (chompKeep && !keyComment && onChompKeep) onChompKeep();\n\n      return ctx.inFlow && !explicitKey ? str : `? ${str}`;\n    }\n\n    str = explicitKey ? `? ${str}\\n${indent}:` : `${str}:`;\n\n    if (this.comment) {\n      // expected (but not strictly required) to be a single-line comment\n      str = addComment(str, ctx.indent, this.comment);\n      if (onComment) onComment();\n    }\n\n    let vcb = '';\n    let valueComment = null;\n\n    if (value instanceof Node) {\n      if (value.spaceBefore) vcb = '\\n';\n\n      if (value.commentBefore) {\n        const cs = value.commentBefore.replace(/^/gm, `${ctx.indent}#`);\n        vcb += `\\n${cs}`;\n      }\n\n      valueComment = value.comment;\n    } else if (value && typeof value === 'object') {\n      value = doc.schema.createNode(value, true);\n    }\n\n    ctx.implicitKey = false;\n    if (!explicitKey && !this.comment && value instanceof Scalar) ctx.indentAtStart = str.length + 1;\n    chompKeep = false;\n\n    if (!indentSeq && indentSize >= 2 && !ctx.inFlow && !explicitKey && value instanceof YAMLSeq && value.type !== PlainValue.Type.FLOW_SEQ && !value.tag && !doc.anchors.getName(value)) {\n      // If indentSeq === false, consider '- ' as part of indentation where possible\n      ctx.indent = ctx.indent.substr(2);\n    }\n\n    const valueStr = stringify(value, ctx, () => valueComment = null, () => chompKeep = true);\n    let ws = ' ';\n\n    if (vcb || this.comment) {\n      ws = `${vcb}\\n${ctx.indent}`;\n    } else if (!explicitKey && value instanceof Collection) {\n      const flow = valueStr[0] === '[' || valueStr[0] === '{';\n      if (!flow || valueStr.includes('\\n')) ws = `\\n${ctx.indent}`;\n    } else if (valueStr[0] === '\\n') ws = '';\n\n    if (chompKeep && !valueComment && onChompKeep) onChompKeep();\n    return addComment(str + ws + valueStr, ctx.indent, valueComment);\n  }\n\n}\n\nPlainValue._defineProperty(Pair, \"Type\", {\n  PAIR: 'PAIR',\n  MERGE_PAIR: 'MERGE_PAIR'\n});\n\nconst getAliasCount = (node, anchors) => {\n  if (node instanceof Alias) {\n    const anchor = anchors.get(node.source);\n    return anchor.count * anchor.aliasCount;\n  } else if (node instanceof Collection) {\n    let count = 0;\n\n    for (const item of node.items) {\n      const c = getAliasCount(item, anchors);\n      if (c > count) count = c;\n    }\n\n    return count;\n  } else if (node instanceof Pair) {\n    const kc = getAliasCount(node.key, anchors);\n    const vc = getAliasCount(node.value, anchors);\n    return Math.max(kc, vc);\n  }\n\n  return 1;\n};\n\nclass Alias extends Node {\n  static stringify({\n    range,\n    source\n  }, {\n    anchors,\n    doc,\n    implicitKey,\n    inStringifyKey\n  }) {\n    let anchor = Object.keys(anchors).find(a => anchors[a] === source);\n    if (!anchor && inStringifyKey) anchor = doc.anchors.getName(source) || doc.anchors.newName();\n    if (anchor) return `*${anchor}${implicitKey ? ' ' : ''}`;\n    const msg = doc.anchors.getName(source) ? 'Alias node must be after source node' : 'Source node not found for alias node';\n    throw new Error(`${msg} [${range}]`);\n  }\n\n  constructor(source) {\n    super();\n    this.source = source;\n    this.type = PlainValue.Type.ALIAS;\n  }\n\n  set tag(t) {\n    throw new Error('Alias nodes cannot have tags');\n  }\n\n  toJSON(arg, ctx) {\n    if (!ctx) return toJSON(this.source, arg, ctx);\n    const {\n      anchors,\n      maxAliasCount\n    } = ctx;\n    const anchor = anchors.get(this.source);\n    /* istanbul ignore if */\n\n    if (!anchor || anchor.res === undefined) {\n      const msg = 'This should not happen: Alias anchor was not resolved?';\n      if (this.cstNode) throw new PlainValue.YAMLReferenceError(this.cstNode, msg);else throw new ReferenceError(msg);\n    }\n\n    if (maxAliasCount >= 0) {\n      anchor.count += 1;\n      if (anchor.aliasCount === 0) anchor.aliasCount = getAliasCount(this.source, anchors);\n\n      if (anchor.count * anchor.aliasCount > maxAliasCount) {\n        const msg = 'Excessive alias count indicates a resource exhaustion attack';\n        if (this.cstNode) throw new PlainValue.YAMLReferenceError(this.cstNode, msg);else throw new ReferenceError(msg);\n      }\n    }\n\n    return anchor.res;\n  } // Only called when stringifying an alias mapping key while constructing\n  // Object output.\n\n\n  toString(ctx) {\n    return Alias.stringify(this, ctx);\n  }\n\n}\n\nPlainValue._defineProperty(Alias, \"default\", true);\n\nfunction findPair(items, key) {\n  const k = key instanceof Scalar ? key.value : key;\n\n  for (const it of items) {\n    if (it instanceof Pair) {\n      if (it.key === key || it.key === k) return it;\n      if (it.key && it.key.value === k) return it;\n    }\n  }\n\n  return undefined;\n}\nclass YAMLMap extends Collection {\n  add(pair, overwrite) {\n    if (!pair) pair = new Pair(pair);else if (!(pair instanceof Pair)) pair = new Pair(pair.key || pair, pair.value);\n    const prev = findPair(this.items, pair.key);\n    const sortEntries = this.schema && this.schema.sortMapEntries;\n\n    if (prev) {\n      if (overwrite) prev.value = pair.value;else throw new Error(`Key ${pair.key} already set`);\n    } else if (sortEntries) {\n      const i = this.items.findIndex(item => sortEntries(pair, item) < 0);\n      if (i === -1) this.items.push(pair);else this.items.splice(i, 0, pair);\n    } else {\n      this.items.push(pair);\n    }\n  }\n\n  delete(key) {\n    const it = findPair(this.items, key);\n    if (!it) return false;\n    const del = this.items.splice(this.items.indexOf(it), 1);\n    return del.length > 0;\n  }\n\n  get(key, keepScalar) {\n    const it = findPair(this.items, key);\n    const node = it && it.value;\n    return !keepScalar && node instanceof Scalar ? node.value : node;\n  }\n\n  has(key) {\n    return !!findPair(this.items, key);\n  }\n\n  set(key, value) {\n    this.add(new Pair(key, value), true);\n  }\n  /**\n   * @param {*} arg ignored\n   * @param {*} ctx Conversion context, originally set in Document#toJSON()\n   * @param {Class} Type If set, forces the returned collection type\n   * @returns {*} Instance of Type, Map, or Object\n   */\n\n\n  toJSON(_, ctx, Type) {\n    const map = Type ? new Type() : ctx && ctx.mapAsMap ? new Map() : {};\n    if (ctx && ctx.onCreate) ctx.onCreate(map);\n\n    for (const item of this.items) item.addToJSMap(ctx, map);\n\n    return map;\n  }\n\n  toString(ctx, onComment, onChompKeep) {\n    if (!ctx) return JSON.stringify(this);\n\n    for (const item of this.items) {\n      if (!(item instanceof Pair)) throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);\n    }\n\n    return super.toString(ctx, {\n      blockItem: n => n.str,\n      flowChars: {\n        start: '{',\n        end: '}'\n      },\n      isMap: true,\n      itemIndent: ctx.indent || ''\n    }, onComment, onChompKeep);\n  }\n\n}\n\nconst MERGE_KEY = '<<';\nclass Merge extends Pair {\n  constructor(pair) {\n    if (pair instanceof Pair) {\n      let seq = pair.value;\n\n      if (!(seq instanceof YAMLSeq)) {\n        seq = new YAMLSeq();\n        seq.items.push(pair.value);\n        seq.range = pair.value.range;\n      }\n\n      super(pair.key, seq);\n      this.range = pair.range;\n    } else {\n      super(new Scalar(MERGE_KEY), new YAMLSeq());\n    }\n\n    this.type = Pair.Type.MERGE_PAIR;\n  } // If the value associated with a merge key is a single mapping node, each of\n  // its key/value pairs is inserted into the current mapping, unless the key\n  // already exists in it. If the value associated with the merge key is a\n  // sequence, then this sequence is expected to contain mapping nodes and each\n  // of these nodes is merged in turn according to its order in the sequence.\n  // Keys in mapping nodes earlier in the sequence override keys specified in\n  // later mapping nodes. -- http://yaml.org/type/merge.html\n\n\n  addToJSMap(ctx, map) {\n    for (const {\n      source\n    } of this.value.items) {\n      if (!(source instanceof YAMLMap)) throw new Error('Merge sources must be maps');\n      const srcMap = source.toJSON(null, ctx, Map);\n\n      for (const [key, value] of srcMap) {\n        if (map instanceof Map) {\n          if (!map.has(key)) map.set(key, value);\n        } else if (map instanceof Set) {\n          map.add(key);\n        } else if (!Object.prototype.hasOwnProperty.call(map, key)) {\n          Object.defineProperty(map, key, {\n            value,\n            writable: true,\n            enumerable: true,\n            configurable: true\n          });\n        }\n      }\n    }\n\n    return map;\n  }\n\n  toString(ctx, onComment) {\n    const seq = this.value;\n    if (seq.items.length > 1) return super.toString(ctx, onComment);\n    this.value = seq.items[0];\n    const str = super.toString(ctx, onComment);\n    this.value = seq;\n    return str;\n  }\n\n}\n\nconst binaryOptions = {\n  defaultType: PlainValue.Type.BLOCK_LITERAL,\n  lineWidth: 76\n};\nconst boolOptions = {\n  trueStr: 'true',\n  falseStr: 'false'\n};\nconst intOptions = {\n  asBigInt: false\n};\nconst nullOptions = {\n  nullStr: 'null'\n};\nconst strOptions = {\n  defaultType: PlainValue.Type.PLAIN,\n  doubleQuoted: {\n    jsonEncoding: false,\n    minMultiLineLength: 40\n  },\n  fold: {\n    lineWidth: 80,\n    minContentWidth: 20\n  }\n};\n\nfunction resolveScalar(str, tags, scalarFallback) {\n  for (const {\n    format,\n    test,\n    resolve\n  } of tags) {\n    if (test) {\n      const match = str.match(test);\n\n      if (match) {\n        let res = resolve.apply(null, match);\n        if (!(res instanceof Scalar)) res = new Scalar(res);\n        if (format) res.format = format;\n        return res;\n      }\n    }\n  }\n\n  if (scalarFallback) str = scalarFallback(str);\n  return new Scalar(str);\n}\n\nconst FOLD_FLOW = 'flow';\nconst FOLD_BLOCK = 'block';\nconst FOLD_QUOTED = 'quoted'; // presumes i+1 is at the start of a line\n// returns index of last newline in more-indented block\n\nconst consumeMoreIndentedLines = (text, i) => {\n  let ch = text[i + 1];\n\n  while (ch === ' ' || ch === '\\t') {\n    do {\n      ch = text[i += 1];\n    } while (ch && ch !== '\\n');\n\n    ch = text[i + 1];\n  }\n\n  return i;\n};\n/**\n * Tries to keep input at up to `lineWidth` characters, splitting only on spaces\n * not followed by newlines or spaces unless `mode` is `'quoted'`. Lines are\n * terminated with `\\n` and started with `indent`.\n *\n * @param {string} text\n * @param {string} indent\n * @param {string} [mode='flow'] `'block'` prevents more-indented lines\n *   from being folded; `'quoted'` allows for `\\` escapes, including escaped\n *   newlines\n * @param {Object} options\n * @param {number} [options.indentAtStart] Accounts for leading contents on\n *   the first line, defaulting to `indent.length`\n * @param {number} [options.lineWidth=80]\n * @param {number} [options.minContentWidth=20] Allow highly indented lines to\n *   stretch the line width or indent content from the start\n * @param {function} options.onFold Called once if the text is folded\n * @param {function} options.onFold Called once if any line of text exceeds\n *   lineWidth characters\n */\n\n\nfunction foldFlowLines(text, indent, mode, {\n  indentAtStart,\n  lineWidth = 80,\n  minContentWidth = 20,\n  onFold,\n  onOverflow\n}) {\n  if (!lineWidth || lineWidth < 0) return text;\n  const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);\n  if (text.length <= endStep) return text;\n  const folds = [];\n  const escapedFolds = {};\n  let end = lineWidth - indent.length;\n\n  if (typeof indentAtStart === 'number') {\n    if (indentAtStart > lineWidth - Math.max(2, minContentWidth)) folds.push(0);else end = lineWidth - indentAtStart;\n  }\n\n  let split = undefined;\n  let prev = undefined;\n  let overflow = false;\n  let i = -1;\n  let escStart = -1;\n  let escEnd = -1;\n\n  if (mode === FOLD_BLOCK) {\n    i = consumeMoreIndentedLines(text, i);\n    if (i !== -1) end = i + endStep;\n  }\n\n  for (let ch; ch = text[i += 1];) {\n    if (mode === FOLD_QUOTED && ch === '\\\\') {\n      escStart = i;\n\n      switch (text[i + 1]) {\n        case 'x':\n          i += 3;\n          break;\n\n        case 'u':\n          i += 5;\n          break;\n\n        case 'U':\n          i += 9;\n          break;\n\n        default:\n          i += 1;\n      }\n\n      escEnd = i;\n    }\n\n    if (ch === '\\n') {\n      if (mode === FOLD_BLOCK) i = consumeMoreIndentedLines(text, i);\n      end = i + endStep;\n      split = undefined;\n    } else {\n      if (ch === ' ' && prev && prev !== ' ' && prev !== '\\n' && prev !== '\\t') {\n        // space surrounded by non-space can be replaced with newline + indent\n        const next = text[i + 1];\n        if (next && next !== ' ' && next !== '\\n' && next !== '\\t') split = i;\n      }\n\n      if (i >= end) {\n        if (split) {\n          folds.push(split);\n          end = split + endStep;\n          split = undefined;\n        } else if (mode === FOLD_QUOTED) {\n          // white-space collected at end may stretch past lineWidth\n          while (prev === ' ' || prev === '\\t') {\n            prev = ch;\n            ch = text[i += 1];\n            overflow = true;\n          } // Account for newline escape, but don't break preceding escape\n\n\n          const j = i > escEnd + 1 ? i - 2 : escStart - 1; // Bail out if lineWidth & minContentWidth are shorter than an escape string\n\n          if (escapedFolds[j]) return text;\n          folds.push(j);\n          escapedFolds[j] = true;\n          end = j + endStep;\n          split = undefined;\n        } else {\n          overflow = true;\n        }\n      }\n    }\n\n    prev = ch;\n  }\n\n  if (overflow && onOverflow) onOverflow();\n  if (folds.length === 0) return text;\n  if (onFold) onFold();\n  let res = text.slice(0, folds[0]);\n\n  for (let i = 0; i < folds.length; ++i) {\n    const fold = folds[i];\n    const end = folds[i + 1] || text.length;\n    if (fold === 0) res = `\\n${indent}${text.slice(0, end)}`;else {\n      if (mode === FOLD_QUOTED && escapedFolds[fold]) res += `${text[fold]}\\\\`;\n      res += `\\n${indent}${text.slice(fold + 1, end)}`;\n    }\n  }\n\n  return res;\n}\n\nconst getFoldOptions = ({\n  indentAtStart\n}) => indentAtStart ? Object.assign({\n  indentAtStart\n}, strOptions.fold) : strOptions.fold; // Also checks for lines starting with %, as parsing the output as YAML 1.1 will\n// presume that's starting a new document.\n\n\nconst containsDocumentMarker = str => /^(%|---|\\.\\.\\.)/m.test(str);\n\nfunction lineLengthOverLimit(str, lineWidth, indentLength) {\n  if (!lineWidth || lineWidth < 0) return false;\n  const limit = lineWidth - indentLength;\n  const strLen = str.length;\n  if (strLen <= limit) return false;\n\n  for (let i = 0, start = 0; i < strLen; ++i) {\n    if (str[i] === '\\n') {\n      if (i - start > limit) return true;\n      start = i + 1;\n      if (strLen - start <= limit) return false;\n    }\n  }\n\n  return true;\n}\n\nfunction doubleQuotedString(value, ctx) {\n  const {\n    implicitKey\n  } = ctx;\n  const {\n    jsonEncoding,\n    minMultiLineLength\n  } = strOptions.doubleQuoted;\n  const json = JSON.stringify(value);\n  if (jsonEncoding) return json;\n  const indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');\n  let str = '';\n  let start = 0;\n\n  for (let i = 0, ch = json[i]; ch; ch = json[++i]) {\n    if (ch === ' ' && json[i + 1] === '\\\\' && json[i + 2] === 'n') {\n      // space before newline needs to be escaped to not be folded\n      str += json.slice(start, i) + '\\\\ ';\n      i += 1;\n      start = i;\n      ch = '\\\\';\n    }\n\n    if (ch === '\\\\') switch (json[i + 1]) {\n      case 'u':\n        {\n          str += json.slice(start, i);\n          const code = json.substr(i + 2, 4);\n\n          switch (code) {\n            case '0000':\n              str += '\\\\0';\n              break;\n\n            case '0007':\n              str += '\\\\a';\n              break;\n\n            case '000b':\n              str += '\\\\v';\n              break;\n\n            case '001b':\n              str += '\\\\e';\n              break;\n\n            case '0085':\n              str += '\\\\N';\n              break;\n\n            case '00a0':\n              str += '\\\\_';\n              break;\n\n            case '2028':\n              str += '\\\\L';\n              break;\n\n            case '2029':\n              str += '\\\\P';\n              break;\n\n            default:\n              if (code.substr(0, 2) === '00') str += '\\\\x' + code.substr(2);else str += json.substr(i, 6);\n          }\n\n          i += 5;\n          start = i + 1;\n        }\n        break;\n\n      case 'n':\n        if (implicitKey || json[i + 2] === '\"' || json.length < minMultiLineLength) {\n          i += 1;\n        } else {\n          // folding will eat first newline\n          str += json.slice(start, i) + '\\n\\n';\n\n          while (json[i + 2] === '\\\\' && json[i + 3] === 'n' && json[i + 4] !== '\"') {\n            str += '\\n';\n            i += 2;\n          }\n\n          str += indent; // space after newline needs to be escaped to not be folded\n\n          if (json[i + 2] === ' ') str += '\\\\';\n          i += 1;\n          start = i + 1;\n        }\n\n        break;\n\n      default:\n        i += 1;\n    }\n  }\n\n  str = start ? str + json.slice(start) : json;\n  return implicitKey ? str : foldFlowLines(str, indent, FOLD_QUOTED, getFoldOptions(ctx));\n}\n\nfunction singleQuotedString(value, ctx) {\n  if (ctx.implicitKey) {\n    if (/\\n/.test(value)) return doubleQuotedString(value, ctx);\n  } else {\n    // single quoted string can't have leading or trailing whitespace around newline\n    if (/[ \\t]\\n|\\n[ \\t]/.test(value)) return doubleQuotedString(value, ctx);\n  }\n\n  const indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');\n  const res = \"'\" + value.replace(/'/g, \"''\").replace(/\\n+/g, `$&\\n${indent}`) + \"'\";\n  return ctx.implicitKey ? res : foldFlowLines(res, indent, FOLD_FLOW, getFoldOptions(ctx));\n}\n\nfunction blockString({\n  comment,\n  type,\n  value\n}, ctx, onComment, onChompKeep) {\n  // 1. Block can't end in whitespace unless the last line is non-empty.\n  // 2. Strings consisting of only whitespace are best rendered explicitly.\n  if (/\\n[\\t ]+$/.test(value) || /^\\s*$/.test(value)) {\n    return doubleQuotedString(value, ctx);\n  }\n\n  const indent = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value) ? '  ' : '');\n  const indentSize = indent ? '2' : '1'; // root is at -1\n\n  const literal = type === PlainValue.Type.BLOCK_FOLDED ? false : type === PlainValue.Type.BLOCK_LITERAL ? true : !lineLengthOverLimit(value, strOptions.fold.lineWidth, indent.length);\n  let header = literal ? '|' : '>';\n  if (!value) return header + '\\n';\n  let wsStart = '';\n  let wsEnd = '';\n  value = value.replace(/[\\n\\t ]*$/, ws => {\n    const n = ws.indexOf('\\n');\n\n    if (n === -1) {\n      header += '-'; // strip\n    } else if (value === ws || n !== ws.length - 1) {\n      header += '+'; // keep\n\n      if (onChompKeep) onChompKeep();\n    }\n\n    wsEnd = ws.replace(/\\n$/, '');\n    return '';\n  }).replace(/^[\\n ]*/, ws => {\n    if (ws.indexOf(' ') !== -1) header += indentSize;\n    const m = ws.match(/ +$/);\n\n    if (m) {\n      wsStart = ws.slice(0, -m[0].length);\n      return m[0];\n    } else {\n      wsStart = ws;\n      return '';\n    }\n  });\n  if (wsEnd) wsEnd = wsEnd.replace(/\\n+(?!\\n|$)/g, `$&${indent}`);\n  if (wsStart) wsStart = wsStart.replace(/\\n+/g, `$&${indent}`);\n\n  if (comment) {\n    header += ' #' + comment.replace(/ ?[\\r\\n]+/g, ' ');\n    if (onComment) onComment();\n  }\n\n  if (!value) return `${header}${indentSize}\\n${indent}${wsEnd}`;\n\n  if (literal) {\n    value = value.replace(/\\n+/g, `$&${indent}`);\n    return `${header}\\n${indent}${wsStart}${value}${wsEnd}`;\n  }\n\n  value = value.replace(/\\n+/g, '\\n$&').replace(/(?:^|\\n)([\\t ].*)(?:([\\n\\t ]*)\\n(?![\\n\\t ]))?/g, '$1$2') // more-indented lines aren't folded\n  //         ^ ind.line  ^ empty     ^ capture next empty lines only at end of indent\n  .replace(/\\n+/g, `$&${indent}`);\n  const body = foldFlowLines(`${wsStart}${value}${wsEnd}`, indent, FOLD_BLOCK, strOptions.fold);\n  return `${header}\\n${indent}${body}`;\n}\n\nfunction plainString(item, ctx, onComment, onChompKeep) {\n  const {\n    comment,\n    type,\n    value\n  } = item;\n  const {\n    actualString,\n    implicitKey,\n    indent,\n    inFlow\n  } = ctx;\n\n  if (implicitKey && /[\\n[\\]{},]/.test(value) || inFlow && /[[\\]{},]/.test(value)) {\n    return doubleQuotedString(value, ctx);\n  }\n\n  if (!value || /^[\\n\\t ,[\\]{}#&*!|>'\"%@`]|^[?-]$|^[?-][ \\t]|[\\n:][ \\t]|[ \\t]\\n|[\\n\\t ]#|[\\n\\t :]$/.test(value)) {\n    // not allowed:\n    // - empty string, '-' or '?'\n    // - start with an indicator character (except [?:-]) or /[?-] /\n    // - '\\n ', ': ' or ' \\n' anywhere\n    // - '#' not preceded by a non-space char\n    // - end with ' ' or ':'\n    return implicitKey || inFlow || value.indexOf('\\n') === -1 ? value.indexOf('\"') !== -1 && value.indexOf(\"'\") === -1 ? singleQuotedString(value, ctx) : doubleQuotedString(value, ctx) : blockString(item, ctx, onComment, onChompKeep);\n  }\n\n  if (!implicitKey && !inFlow && type !== PlainValue.Type.PLAIN && value.indexOf('\\n') !== -1) {\n    // Where allowed & type not set explicitly, prefer block style for multiline strings\n    return blockString(item, ctx, onComment, onChompKeep);\n  }\n\n  if (indent === '' && containsDocumentMarker(value)) {\n    ctx.forceBlockIndent = true;\n    return blockString(item, ctx, onComment, onChompKeep);\n  }\n\n  const str = value.replace(/\\n+/g, `$&\\n${indent}`); // Verify that output will be parsed as a string, as e.g. plain numbers and\n  // booleans get parsed with those types in v1.2 (e.g. '42', 'true' & '0.9e-3'),\n  // and others in v1.1.\n\n  if (actualString) {\n    const {\n      tags\n    } = ctx.doc.schema;\n    const resolved = resolveScalar(str, tags, tags.scalarFallback).value;\n    if (typeof resolved !== 'string') return doubleQuotedString(value, ctx);\n  }\n\n  const body = implicitKey ? str : foldFlowLines(str, indent, FOLD_FLOW, getFoldOptions(ctx));\n\n  if (comment && !inFlow && (body.indexOf('\\n') !== -1 || comment.indexOf('\\n') !== -1)) {\n    if (onComment) onComment();\n    return addCommentBefore(body, indent, comment);\n  }\n\n  return body;\n}\n\nfunction stringifyString(item, ctx, onComment, onChompKeep) {\n  const {\n    defaultType\n  } = strOptions;\n  const {\n    implicitKey,\n    inFlow\n  } = ctx;\n  let {\n    type,\n    value\n  } = item;\n\n  if (typeof value !== 'string') {\n    value = String(value);\n    item = Object.assign({}, item, {\n      value\n    });\n  }\n\n  const _stringify = _type => {\n    switch (_type) {\n      case PlainValue.Type.BLOCK_FOLDED:\n      case PlainValue.Type.BLOCK_LITERAL:\n        return blockString(item, ctx, onComment, onChompKeep);\n\n      case PlainValue.Type.QUOTE_DOUBLE:\n        return doubleQuotedString(value, ctx);\n\n      case PlainValue.Type.QUOTE_SINGLE:\n        return singleQuotedString(value, ctx);\n\n      case PlainValue.Type.PLAIN:\n        return plainString(item, ctx, onComment, onChompKeep);\n\n      default:\n        return null;\n    }\n  };\n\n  if (type !== PlainValue.Type.QUOTE_DOUBLE && /[\\x00-\\x08\\x0b-\\x1f\\x7f-\\x9f]/.test(value)) {\n    // force double quotes on control characters\n    type = PlainValue.Type.QUOTE_DOUBLE;\n  } else if ((implicitKey || inFlow) && (type === PlainValue.Type.BLOCK_FOLDED || type === PlainValue.Type.BLOCK_LITERAL)) {\n    // should not happen; blocks are not valid inside flow containers\n    type = PlainValue.Type.QUOTE_DOUBLE;\n  }\n\n  let res = _stringify(type);\n\n  if (res === null) {\n    res = _stringify(defaultType);\n    if (res === null) throw new Error(`Unsupported default string type ${defaultType}`);\n  }\n\n  return res;\n}\n\nfunction stringifyNumber({\n  format,\n  minFractionDigits,\n  tag,\n  value\n}) {\n  if (typeof value === 'bigint') return String(value);\n  if (!isFinite(value)) return isNaN(value) ? '.nan' : value < 0 ? '-.inf' : '.inf';\n  let n = JSON.stringify(value);\n\n  if (!format && minFractionDigits && (!tag || tag === 'tag:yaml.org,2002:float') && /^\\d/.test(n)) {\n    let i = n.indexOf('.');\n\n    if (i < 0) {\n      i = n.length;\n      n += '.';\n    }\n\n    let d = minFractionDigits - (n.length - i - 1);\n\n    while (d-- > 0) n += '0';\n  }\n\n  return n;\n}\n\nfunction checkFlowCollectionEnd(errors, cst) {\n  let char, name;\n\n  switch (cst.type) {\n    case PlainValue.Type.FLOW_MAP:\n      char = '}';\n      name = 'flow map';\n      break;\n\n    case PlainValue.Type.FLOW_SEQ:\n      char = ']';\n      name = 'flow sequence';\n      break;\n\n    default:\n      errors.push(new PlainValue.YAMLSemanticError(cst, 'Not a flow collection!?'));\n      return;\n  }\n\n  let lastItem;\n\n  for (let i = cst.items.length - 1; i >= 0; --i) {\n    const item = cst.items[i];\n\n    if (!item || item.type !== PlainValue.Type.COMMENT) {\n      lastItem = item;\n      break;\n    }\n  }\n\n  if (lastItem && lastItem.char !== char) {\n    const msg = `Expected ${name} to end with ${char}`;\n    let err;\n\n    if (typeof lastItem.offset === 'number') {\n      err = new PlainValue.YAMLSemanticError(cst, msg);\n      err.offset = lastItem.offset + 1;\n    } else {\n      err = new PlainValue.YAMLSemanticError(lastItem, msg);\n      if (lastItem.range && lastItem.range.end) err.offset = lastItem.range.end - lastItem.range.start;\n    }\n\n    errors.push(err);\n  }\n}\nfunction checkFlowCommentSpace(errors, comment) {\n  const prev = comment.context.src[comment.range.start - 1];\n\n  if (prev !== '\\n' && prev !== '\\t' && prev !== ' ') {\n    const msg = 'Comments must be separated from other tokens by white space characters';\n    errors.push(new PlainValue.YAMLSemanticError(comment, msg));\n  }\n}\nfunction getLongKeyError(source, key) {\n  const sk = String(key);\n  const k = sk.substr(0, 8) + '...' + sk.substr(-8);\n  return new PlainValue.YAMLSemanticError(source, `The \"${k}\" key is too long`);\n}\nfunction resolveComments(collection, comments) {\n  for (const {\n    afterKey,\n    before,\n    comment\n  } of comments) {\n    let item = collection.items[before];\n\n    if (!item) {\n      if (comment !== undefined) {\n        if (collection.comment) collection.comment += '\\n' + comment;else collection.comment = comment;\n      }\n    } else {\n      if (afterKey && item.value) item = item.value;\n\n      if (comment === undefined) {\n        if (afterKey || !item.commentBefore) item.spaceBefore = true;\n      } else {\n        if (item.commentBefore) item.commentBefore += '\\n' + comment;else item.commentBefore = comment;\n      }\n    }\n  }\n}\n\n// on error, will return { str: string, errors: Error[] }\nfunction resolveString(doc, node) {\n  const res = node.strValue;\n  if (!res) return '';\n  if (typeof res === 'string') return res;\n  res.errors.forEach(error => {\n    if (!error.source) error.source = node;\n    doc.errors.push(error);\n  });\n  return res.str;\n}\n\nfunction resolveTagHandle(doc, node) {\n  const {\n    handle,\n    suffix\n  } = node.tag;\n  let prefix = doc.tagPrefixes.find(p => p.handle === handle);\n\n  if (!prefix) {\n    const dtp = doc.getDefaults().tagPrefixes;\n    if (dtp) prefix = dtp.find(p => p.handle === handle);\n    if (!prefix) throw new PlainValue.YAMLSemanticError(node, `The ${handle} tag handle is non-default and was not declared.`);\n  }\n\n  if (!suffix) throw new PlainValue.YAMLSemanticError(node, `The ${handle} tag has no suffix.`);\n\n  if (handle === '!' && (doc.version || doc.options.version) === '1.0') {\n    if (suffix[0] === '^') {\n      doc.warnings.push(new PlainValue.YAMLWarning(node, 'YAML 1.0 ^ tag expansion is not supported'));\n      return suffix;\n    }\n\n    if (/[:/]/.test(suffix)) {\n      // word/foo -> tag:word.yaml.org,2002:foo\n      const vocab = suffix.match(/^([a-z0-9-]+)\\/(.*)/i);\n      return vocab ? `tag:${vocab[1]}.yaml.org,2002:${vocab[2]}` : `tag:${suffix}`;\n    }\n  }\n\n  return prefix.prefix + decodeURIComponent(suffix);\n}\n\nfunction resolveTagName(doc, node) {\n  const {\n    tag,\n    type\n  } = node;\n  let nonSpecific = false;\n\n  if (tag) {\n    const {\n      handle,\n      suffix,\n      verbatim\n    } = tag;\n\n    if (verbatim) {\n      if (verbatim !== '!' && verbatim !== '!!') return verbatim;\n      const msg = `Verbatim tags aren't resolved, so ${verbatim} is invalid.`;\n      doc.errors.push(new PlainValue.YAMLSemanticError(node, msg));\n    } else if (handle === '!' && !suffix) {\n      nonSpecific = true;\n    } else {\n      try {\n        return resolveTagHandle(doc, node);\n      } catch (error) {\n        doc.errors.push(error);\n      }\n    }\n  }\n\n  switch (type) {\n    case PlainValue.Type.BLOCK_FOLDED:\n    case PlainValue.Type.BLOCK_LITERAL:\n    case PlainValue.Type.QUOTE_DOUBLE:\n    case PlainValue.Type.QUOTE_SINGLE:\n      return PlainValue.defaultTags.STR;\n\n    case PlainValue.Type.FLOW_MAP:\n    case PlainValue.Type.MAP:\n      return PlainValue.defaultTags.MAP;\n\n    case PlainValue.Type.FLOW_SEQ:\n    case PlainValue.Type.SEQ:\n      return PlainValue.defaultTags.SEQ;\n\n    case PlainValue.Type.PLAIN:\n      return nonSpecific ? PlainValue.defaultTags.STR : null;\n\n    default:\n      return null;\n  }\n}\n\nfunction resolveByTagName(doc, node, tagName) {\n  const {\n    tags\n  } = doc.schema;\n  const matchWithTest = [];\n\n  for (const tag of tags) {\n    if (tag.tag === tagName) {\n      if (tag.test) matchWithTest.push(tag);else {\n        const res = tag.resolve(doc, node);\n        return res instanceof Collection ? res : new Scalar(res);\n      }\n    }\n  }\n\n  const str = resolveString(doc, node);\n  if (typeof str === 'string' && matchWithTest.length > 0) return resolveScalar(str, matchWithTest, tags.scalarFallback);\n  return null;\n}\n\nfunction getFallbackTagName({\n  type\n}) {\n  switch (type) {\n    case PlainValue.Type.FLOW_MAP:\n    case PlainValue.Type.MAP:\n      return PlainValue.defaultTags.MAP;\n\n    case PlainValue.Type.FLOW_SEQ:\n    case PlainValue.Type.SEQ:\n      return PlainValue.defaultTags.SEQ;\n\n    default:\n      return PlainValue.defaultTags.STR;\n  }\n}\n\nfunction resolveTag(doc, node, tagName) {\n  try {\n    const res = resolveByTagName(doc, node, tagName);\n\n    if (res) {\n      if (tagName && node.tag) res.tag = tagName;\n      return res;\n    }\n  } catch (error) {\n    /* istanbul ignore if */\n    if (!error.source) error.source = node;\n    doc.errors.push(error);\n    return null;\n  }\n\n  try {\n    const fallback = getFallbackTagName(node);\n    if (!fallback) throw new Error(`The tag ${tagName} is unavailable`);\n    const msg = `The tag ${tagName} is unavailable, falling back to ${fallback}`;\n    doc.warnings.push(new PlainValue.YAMLWarning(node, msg));\n    const res = resolveByTagName(doc, node, fallback);\n    res.tag = tagName;\n    return res;\n  } catch (error) {\n    const refError = new PlainValue.YAMLReferenceError(node, error.message);\n    refError.stack = error.stack;\n    doc.errors.push(refError);\n    return null;\n  }\n}\n\nconst isCollectionItem = node => {\n  if (!node) return false;\n  const {\n    type\n  } = node;\n  return type === PlainValue.Type.MAP_KEY || type === PlainValue.Type.MAP_VALUE || type === PlainValue.Type.SEQ_ITEM;\n};\n\nfunction resolveNodeProps(errors, node) {\n  const comments = {\n    before: [],\n    after: []\n  };\n  let hasAnchor = false;\n  let hasTag = false;\n  const props = isCollectionItem(node.context.parent) ? node.context.parent.props.concat(node.props) : node.props;\n\n  for (const {\n    start,\n    end\n  } of props) {\n    switch (node.context.src[start]) {\n      case PlainValue.Char.COMMENT:\n        {\n          if (!node.commentHasRequiredWhitespace(start)) {\n            const msg = 'Comments must be separated from other tokens by white space characters';\n            errors.push(new PlainValue.YAMLSemanticError(node, msg));\n          }\n\n          const {\n            header,\n            valueRange\n          } = node;\n          const cc = valueRange && (start > valueRange.start || header && start > header.start) ? comments.after : comments.before;\n          cc.push(node.context.src.slice(start + 1, end));\n          break;\n        }\n      // Actual anchor & tag resolution is handled by schema, here we just complain\n\n      case PlainValue.Char.ANCHOR:\n        if (hasAnchor) {\n          const msg = 'A node can have at most one anchor';\n          errors.push(new PlainValue.YAMLSemanticError(node, msg));\n        }\n\n        hasAnchor = true;\n        break;\n\n      case PlainValue.Char.TAG:\n        if (hasTag) {\n          const msg = 'A node can have at most one tag';\n          errors.push(new PlainValue.YAMLSemanticError(node, msg));\n        }\n\n        hasTag = true;\n        break;\n    }\n  }\n\n  return {\n    comments,\n    hasAnchor,\n    hasTag\n  };\n}\n\nfunction resolveNodeValue(doc, node) {\n  const {\n    anchors,\n    errors,\n    schema\n  } = doc;\n\n  if (node.type === PlainValue.Type.ALIAS) {\n    const name = node.rawValue;\n    const src = anchors.getNode(name);\n\n    if (!src) {\n      const msg = `Aliased anchor not found: ${name}`;\n      errors.push(new PlainValue.YAMLReferenceError(node, msg));\n      return null;\n    } // Lazy resolution for circular references\n\n\n    const res = new Alias(src);\n\n    anchors._cstAliases.push(res);\n\n    return res;\n  }\n\n  const tagName = resolveTagName(doc, node);\n  if (tagName) return resolveTag(doc, node, tagName);\n\n  if (node.type !== PlainValue.Type.PLAIN) {\n    const msg = `Failed to resolve ${node.type} node here`;\n    errors.push(new PlainValue.YAMLSyntaxError(node, msg));\n    return null;\n  }\n\n  try {\n    const str = resolveString(doc, node);\n    return resolveScalar(str, schema.tags, schema.tags.scalarFallback);\n  } catch (error) {\n    if (!error.source) error.source = node;\n    errors.push(error);\n    return null;\n  }\n} // sets node.resolved on success\n\n\nfunction resolveNode(doc, node) {\n  if (!node) return null;\n  if (node.error) doc.errors.push(node.error);\n  const {\n    comments,\n    hasAnchor,\n    hasTag\n  } = resolveNodeProps(doc.errors, node);\n\n  if (hasAnchor) {\n    const {\n      anchors\n    } = doc;\n    const name = node.anchor;\n    const prev = anchors.getNode(name); // At this point, aliases for any preceding node with the same anchor\n    // name have already been resolved, so it may safely be renamed.\n\n    if (prev) anchors.map[anchors.newName(name)] = prev; // During parsing, we need to store the CST node in anchors.map as\n    // anchors need to be available during resolution to allow for\n    // circular references.\n\n    anchors.map[name] = node;\n  }\n\n  if (node.type === PlainValue.Type.ALIAS && (hasAnchor || hasTag)) {\n    const msg = 'An alias node must not specify any properties';\n    doc.errors.push(new PlainValue.YAMLSemanticError(node, msg));\n  }\n\n  const res = resolveNodeValue(doc, node);\n\n  if (res) {\n    res.range = [node.range.start, node.range.end];\n    if (doc.options.keepCstNodes) res.cstNode = node;\n    if (doc.options.keepNodeTypes) res.type = node.type;\n    const cb = comments.before.join('\\n');\n\n    if (cb) {\n      res.commentBefore = res.commentBefore ? `${res.commentBefore}\\n${cb}` : cb;\n    }\n\n    const ca = comments.after.join('\\n');\n    if (ca) res.comment = res.comment ? `${res.comment}\\n${ca}` : ca;\n  }\n\n  return node.resolved = res;\n}\n\nfunction resolveMap(doc, cst) {\n  if (cst.type !== PlainValue.Type.MAP && cst.type !== PlainValue.Type.FLOW_MAP) {\n    const msg = `A ${cst.type} node cannot be resolved as a mapping`;\n    doc.errors.push(new PlainValue.YAMLSyntaxError(cst, msg));\n    return null;\n  }\n\n  const {\n    comments,\n    items\n  } = cst.type === PlainValue.Type.FLOW_MAP ? resolveFlowMapItems(doc, cst) : resolveBlockMapItems(doc, cst);\n  const map = new YAMLMap();\n  map.items = items;\n  resolveComments(map, comments);\n  let hasCollectionKey = false;\n\n  for (let i = 0; i < items.length; ++i) {\n    const {\n      key: iKey\n    } = items[i];\n    if (iKey instanceof Collection) hasCollectionKey = true;\n\n    if (doc.schema.merge && iKey && iKey.value === MERGE_KEY) {\n      items[i] = new Merge(items[i]);\n      const sources = items[i].value.items;\n      let error = null;\n      sources.some(node => {\n        if (node instanceof Alias) {\n          // During parsing, alias sources are CST nodes; to account for\n          // circular references their resolved values can't be used here.\n          const {\n            type\n          } = node.source;\n          if (type === PlainValue.Type.MAP || type === PlainValue.Type.FLOW_MAP) return false;\n          return error = 'Merge nodes aliases can only point to maps';\n        }\n\n        return error = 'Merge nodes can only have Alias nodes as values';\n      });\n      if (error) doc.errors.push(new PlainValue.YAMLSemanticError(cst, error));\n    } else {\n      for (let j = i + 1; j < items.length; ++j) {\n        const {\n          key: jKey\n        } = items[j];\n\n        if (iKey === jKey || iKey && jKey && Object.prototype.hasOwnProperty.call(iKey, 'value') && iKey.value === jKey.value) {\n          const msg = `Map keys must be unique; \"${iKey}\" is repeated`;\n          doc.errors.push(new PlainValue.YAMLSemanticError(cst, msg));\n          break;\n        }\n      }\n    }\n  }\n\n  if (hasCollectionKey && !doc.options.mapAsMap) {\n    const warn = 'Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.';\n    doc.warnings.push(new PlainValue.YAMLWarning(cst, warn));\n  }\n\n  cst.resolved = map;\n  return map;\n}\n\nconst valueHasPairComment = ({\n  context: {\n    lineStart,\n    node,\n    src\n  },\n  props\n}) => {\n  if (props.length === 0) return false;\n  const {\n    start\n  } = props[0];\n  if (node && start > node.valueRange.start) return false;\n  if (src[start] !== PlainValue.Char.COMMENT) return false;\n\n  for (let i = lineStart; i < start; ++i) if (src[i] === '\\n') return false;\n\n  return true;\n};\n\nfunction resolvePairComment(item, pair) {\n  if (!valueHasPairComment(item)) return;\n  const comment = item.getPropValue(0, PlainValue.Char.COMMENT, true);\n  let found = false;\n  const cb = pair.value.commentBefore;\n\n  if (cb && cb.startsWith(comment)) {\n    pair.value.commentBefore = cb.substr(comment.length + 1);\n    found = true;\n  } else {\n    const cc = pair.value.comment;\n\n    if (!item.node && cc && cc.startsWith(comment)) {\n      pair.value.comment = cc.substr(comment.length + 1);\n      found = true;\n    }\n  }\n\n  if (found) pair.comment = comment;\n}\n\nfunction resolveBlockMapItems(doc, cst) {\n  const comments = [];\n  const items = [];\n  let key = undefined;\n  let keyStart = null;\n\n  for (let i = 0; i < cst.items.length; ++i) {\n    const item = cst.items[i];\n\n    switch (item.type) {\n      case PlainValue.Type.BLANK_LINE:\n        comments.push({\n          afterKey: !!key,\n          before: items.length\n        });\n        break;\n\n      case PlainValue.Type.COMMENT:\n        comments.push({\n          afterKey: !!key,\n          before: items.length,\n          comment: item.comment\n        });\n        break;\n\n      case PlainValue.Type.MAP_KEY:\n        if (key !== undefined) items.push(new Pair(key));\n        if (item.error) doc.errors.push(item.error);\n        key = resolveNode(doc, item.node);\n        keyStart = null;\n        break;\n\n      case PlainValue.Type.MAP_VALUE:\n        {\n          if (key === undefined) key = null;\n          if (item.error) doc.errors.push(item.error);\n\n          if (!item.context.atLineStart && item.node && item.node.type === PlainValue.Type.MAP && !item.node.context.atLineStart) {\n            const msg = 'Nested mappings are not allowed in compact mappings';\n            doc.errors.push(new PlainValue.YAMLSemanticError(item.node, msg));\n          }\n\n          let valueNode = item.node;\n\n          if (!valueNode && item.props.length > 0) {\n            // Comments on an empty mapping value need to be preserved, so we\n            // need to construct a minimal empty node here to use instead of the\n            // missing `item.node`. -- eemeli/yaml#19\n            valueNode = new PlainValue.PlainValue(PlainValue.Type.PLAIN, []);\n            valueNode.context = {\n              parent: item,\n              src: item.context.src\n            };\n            const pos = item.range.start + 1;\n            valueNode.range = {\n              start: pos,\n              end: pos\n            };\n            valueNode.valueRange = {\n              start: pos,\n              end: pos\n            };\n\n            if (typeof item.range.origStart === 'number') {\n              const origPos = item.range.origStart + 1;\n              valueNode.range.origStart = valueNode.range.origEnd = origPos;\n              valueNode.valueRange.origStart = valueNode.valueRange.origEnd = origPos;\n            }\n          }\n\n          const pair = new Pair(key, resolveNode(doc, valueNode));\n          resolvePairComment(item, pair);\n          items.push(pair);\n\n          if (key && typeof keyStart === 'number') {\n            if (item.range.start > keyStart + 1024) doc.errors.push(getLongKeyError(cst, key));\n          }\n\n          key = undefined;\n          keyStart = null;\n        }\n        break;\n\n      default:\n        if (key !== undefined) items.push(new Pair(key));\n        key = resolveNode(doc, item);\n        keyStart = item.range.start;\n        if (item.error) doc.errors.push(item.error);\n\n        next: for (let j = i + 1;; ++j) {\n          const nextItem = cst.items[j];\n\n          switch (nextItem && nextItem.type) {\n            case PlainValue.Type.BLANK_LINE:\n            case PlainValue.Type.COMMENT:\n              continue next;\n\n            case PlainValue.Type.MAP_VALUE:\n              break next;\n\n            default:\n              {\n                const msg = 'Implicit map keys need to be followed by map values';\n                doc.errors.push(new PlainValue.YAMLSemanticError(item, msg));\n                break next;\n              }\n          }\n        }\n\n        if (item.valueRangeContainsNewline) {\n          const msg = 'Implicit map keys need to be on a single line';\n          doc.errors.push(new PlainValue.YAMLSemanticError(item, msg));\n        }\n\n    }\n  }\n\n  if (key !== undefined) items.push(new Pair(key));\n  return {\n    comments,\n    items\n  };\n}\n\nfunction resolveFlowMapItems(doc, cst) {\n  const comments = [];\n  const items = [];\n  let key = undefined;\n  let explicitKey = false;\n  let next = '{';\n\n  for (let i = 0; i < cst.items.length; ++i) {\n    const item = cst.items[i];\n\n    if (typeof item.char === 'string') {\n      const {\n        char,\n        offset\n      } = item;\n\n      if (char === '?' && key === undefined && !explicitKey) {\n        explicitKey = true;\n        next = ':';\n        continue;\n      }\n\n      if (char === ':') {\n        if (key === undefined) key = null;\n\n        if (next === ':') {\n          next = ',';\n          continue;\n        }\n      } else {\n        if (explicitKey) {\n          if (key === undefined && char !== ',') key = null;\n          explicitKey = false;\n        }\n\n        if (key !== undefined) {\n          items.push(new Pair(key));\n          key = undefined;\n\n          if (char === ',') {\n            next = ':';\n            continue;\n          }\n        }\n      }\n\n      if (char === '}') {\n        if (i === cst.items.length - 1) continue;\n      } else if (char === next) {\n        next = ':';\n        continue;\n      }\n\n      const msg = `Flow map contains an unexpected ${char}`;\n      const err = new PlainValue.YAMLSyntaxError(cst, msg);\n      err.offset = offset;\n      doc.errors.push(err);\n    } else if (item.type === PlainValue.Type.BLANK_LINE) {\n      comments.push({\n        afterKey: !!key,\n        before: items.length\n      });\n    } else if (item.type === PlainValue.Type.COMMENT) {\n      checkFlowCommentSpace(doc.errors, item);\n      comments.push({\n        afterKey: !!key,\n        before: items.length,\n        comment: item.comment\n      });\n    } else if (key === undefined) {\n      if (next === ',') doc.errors.push(new PlainValue.YAMLSemanticError(item, 'Separator , missing in flow map'));\n      key = resolveNode(doc, item);\n    } else {\n      if (next !== ',') doc.errors.push(new PlainValue.YAMLSemanticError(item, 'Indicator : missing in flow map entry'));\n      items.push(new Pair(key, resolveNode(doc, item)));\n      key = undefined;\n      explicitKey = false;\n    }\n  }\n\n  checkFlowCollectionEnd(doc.errors, cst);\n  if (key !== undefined) items.push(new Pair(key));\n  return {\n    comments,\n    items\n  };\n}\n\nfunction resolveSeq(doc, cst) {\n  if (cst.type !== PlainValue.Type.SEQ && cst.type !== PlainValue.Type.FLOW_SEQ) {\n    const msg = `A ${cst.type} node cannot be resolved as a sequence`;\n    doc.errors.push(new PlainValue.YAMLSyntaxError(cst, msg));\n    return null;\n  }\n\n  const {\n    comments,\n    items\n  } = cst.type === PlainValue.Type.FLOW_SEQ ? resolveFlowSeqItems(doc, cst) : resolveBlockSeqItems(doc, cst);\n  const seq = new YAMLSeq();\n  seq.items = items;\n  resolveComments(seq, comments);\n\n  if (!doc.options.mapAsMap && items.some(it => it instanceof Pair && it.key instanceof Collection)) {\n    const warn = 'Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.';\n    doc.warnings.push(new PlainValue.YAMLWarning(cst, warn));\n  }\n\n  cst.resolved = seq;\n  return seq;\n}\n\nfunction resolveBlockSeqItems(doc, cst) {\n  const comments = [];\n  const items = [];\n\n  for (let i = 0; i < cst.items.length; ++i) {\n    const item = cst.items[i];\n\n    switch (item.type) {\n      case PlainValue.Type.BLANK_LINE:\n        comments.push({\n          before: items.length\n        });\n        break;\n\n      case PlainValue.Type.COMMENT:\n        comments.push({\n          comment: item.comment,\n          before: items.length\n        });\n        break;\n\n      case PlainValue.Type.SEQ_ITEM:\n        if (item.error) doc.errors.push(item.error);\n        items.push(resolveNode(doc, item.node));\n\n        if (item.hasProps) {\n          const msg = 'Sequence items cannot have tags or anchors before the - indicator';\n          doc.errors.push(new PlainValue.YAMLSemanticError(item, msg));\n        }\n\n        break;\n\n      default:\n        if (item.error) doc.errors.push(item.error);\n        doc.errors.push(new PlainValue.YAMLSyntaxError(item, `Unexpected ${item.type} node in sequence`));\n    }\n  }\n\n  return {\n    comments,\n    items\n  };\n}\n\nfunction resolveFlowSeqItems(doc, cst) {\n  const comments = [];\n  const items = [];\n  let explicitKey = false;\n  let key = undefined;\n  let keyStart = null;\n  let next = '[';\n  let prevItem = null;\n\n  for (let i = 0; i < cst.items.length; ++i) {\n    const item = cst.items[i];\n\n    if (typeof item.char === 'string') {\n      const {\n        char,\n        offset\n      } = item;\n\n      if (char !== ':' && (explicitKey || key !== undefined)) {\n        if (explicitKey && key === undefined) key = next ? items.pop() : null;\n        items.push(new Pair(key));\n        explicitKey = false;\n        key = undefined;\n        keyStart = null;\n      }\n\n      if (char === next) {\n        next = null;\n      } else if (!next && char === '?') {\n        explicitKey = true;\n      } else if (next !== '[' && char === ':' && key === undefined) {\n        if (next === ',') {\n          key = items.pop();\n\n          if (key instanceof Pair) {\n            const msg = 'Chaining flow sequence pairs is invalid';\n            const err = new PlainValue.YAMLSemanticError(cst, msg);\n            err.offset = offset;\n            doc.errors.push(err);\n          }\n\n          if (!explicitKey && typeof keyStart === 'number') {\n            const keyEnd = item.range ? item.range.start : item.offset;\n            if (keyEnd > keyStart + 1024) doc.errors.push(getLongKeyError(cst, key));\n            const {\n              src\n            } = prevItem.context;\n\n            for (let i = keyStart; i < keyEnd; ++i) if (src[i] === '\\n') {\n              const msg = 'Implicit keys of flow sequence pairs need to be on a single line';\n              doc.errors.push(new PlainValue.YAMLSemanticError(prevItem, msg));\n              break;\n            }\n          }\n        } else {\n          key = null;\n        }\n\n        keyStart = null;\n        explicitKey = false;\n        next = null;\n      } else if (next === '[' || char !== ']' || i < cst.items.length - 1) {\n        const msg = `Flow sequence contains an unexpected ${char}`;\n        const err = new PlainValue.YAMLSyntaxError(cst, msg);\n        err.offset = offset;\n        doc.errors.push(err);\n      }\n    } else if (item.type === PlainValue.Type.BLANK_LINE) {\n      comments.push({\n        before: items.length\n      });\n    } else if (item.type === PlainValue.Type.COMMENT) {\n      checkFlowCommentSpace(doc.errors, item);\n      comments.push({\n        comment: item.comment,\n        before: items.length\n      });\n    } else {\n      if (next) {\n        const msg = `Expected a ${next} in flow sequence`;\n        doc.errors.push(new PlainValue.YAMLSemanticError(item, msg));\n      }\n\n      const value = resolveNode(doc, item);\n\n      if (key === undefined) {\n        items.push(value);\n        prevItem = item;\n      } else {\n        items.push(new Pair(key, value));\n        key = undefined;\n      }\n\n      keyStart = item.range.start;\n      next = ',';\n    }\n  }\n\n  checkFlowCollectionEnd(doc.errors, cst);\n  if (key !== undefined) items.push(new Pair(key));\n  return {\n    comments,\n    items\n  };\n}\n\nexports.Alias = Alias;\nexports.Collection = Collection;\nexports.Merge = Merge;\nexports.Node = Node;\nexports.Pair = Pair;\nexports.Scalar = Scalar;\nexports.YAMLMap = YAMLMap;\nexports.YAMLSeq = YAMLSeq;\nexports.addComment = addComment;\nexports.binaryOptions = binaryOptions;\nexports.boolOptions = boolOptions;\nexports.findPair = findPair;\nexports.intOptions = intOptions;\nexports.isEmptyPath = isEmptyPath;\nexports.nullOptions = nullOptions;\nexports.resolveMap = resolveMap;\nexports.resolveNode = resolveNode;\nexports.resolveSeq = resolveSeq;\nexports.resolveString = resolveString;\nexports.strOptions = strOptions;\nexports.stringifyNumber = stringifyNumber;\nexports.stringifyString = stringifyString;\nexports.toJSON = toJSON;\n", "'use strict';\n\nvar PlainValue = require('./PlainValue-ec8e588e.js');\nvar resolveSeq = require('./resolveSeq-d03cb037.js');\n\n/* global atob, btoa, Buffer */\nconst binary = {\n  identify: value => value instanceof Uint8Array,\n  // Buffer inherits from Uint8Array\n  default: false,\n  tag: 'tag:yaml.org,2002:binary',\n\n  /**\n   * Returns a Buffer in node and an Uint8Array in browsers\n   *\n   * To use the resulting buffer as an image, you'll want to do something like:\n   *\n   *   const blob = new Blob([buffer], { type: 'image/jpeg' })\n   *   document.querySelector('#photo').src = URL.createObjectURL(blob)\n   */\n  resolve: (doc, node) => {\n    const src = resolveSeq.resolveString(doc, node);\n\n    if (typeof Buffer === 'function') {\n      return Buffer.from(src, 'base64');\n    } else if (typeof atob === 'function') {\n      // On IE 11, atob() can't handle newlines\n      const str = atob(src.replace(/[\\n\\r]/g, ''));\n      const buffer = new Uint8Array(str.length);\n\n      for (let i = 0; i < str.length; ++i) buffer[i] = str.charCodeAt(i);\n\n      return buffer;\n    } else {\n      const msg = 'This environment does not support reading binary tags; either Buffer or atob is required';\n      doc.errors.push(new PlainValue.YAMLReferenceError(node, msg));\n      return null;\n    }\n  },\n  options: resolveSeq.binaryOptions,\n  stringify: ({\n    comment,\n    type,\n    value\n  }, ctx, onComment, onChompKeep) => {\n    let src;\n\n    if (typeof Buffer === 'function') {\n      src = value instanceof Buffer ? value.toString('base64') : Buffer.from(value.buffer).toString('base64');\n    } else if (typeof btoa === 'function') {\n      let s = '';\n\n      for (let i = 0; i < value.length; ++i) s += String.fromCharCode(value[i]);\n\n      src = btoa(s);\n    } else {\n      throw new Error('This environment does not support writing binary tags; either Buffer or btoa is required');\n    }\n\n    if (!type) type = resolveSeq.binaryOptions.defaultType;\n\n    if (type === PlainValue.Type.QUOTE_DOUBLE) {\n      value = src;\n    } else {\n      const {\n        lineWidth\n      } = resolveSeq.binaryOptions;\n      const n = Math.ceil(src.length / lineWidth);\n      const lines = new Array(n);\n\n      for (let i = 0, o = 0; i < n; ++i, o += lineWidth) {\n        lines[i] = src.substr(o, lineWidth);\n      }\n\n      value = lines.join(type === PlainValue.Type.BLOCK_LITERAL ? '\\n' : ' ');\n    }\n\n    return resolveSeq.stringifyString({\n      comment,\n      type,\n      value\n    }, ctx, onComment, onChompKeep);\n  }\n};\n\nfunction parsePairs(doc, cst) {\n  const seq = resolveSeq.resolveSeq(doc, cst);\n\n  for (let i = 0; i < seq.items.length; ++i) {\n    let item = seq.items[i];\n    if (item instanceof resolveSeq.Pair) continue;else if (item instanceof resolveSeq.YAMLMap) {\n      if (item.items.length > 1) {\n        const msg = 'Each pair must have its own sequence indicator';\n        throw new PlainValue.YAMLSemanticError(cst, msg);\n      }\n\n      const pair = item.items[0] || new resolveSeq.Pair();\n      if (item.commentBefore) pair.commentBefore = pair.commentBefore ? `${item.commentBefore}\\n${pair.commentBefore}` : item.commentBefore;\n      if (item.comment) pair.comment = pair.comment ? `${item.comment}\\n${pair.comment}` : item.comment;\n      item = pair;\n    }\n    seq.items[i] = item instanceof resolveSeq.Pair ? item : new resolveSeq.Pair(item);\n  }\n\n  return seq;\n}\nfunction createPairs(schema, iterable, ctx) {\n  const pairs = new resolveSeq.YAMLSeq(schema);\n  pairs.tag = 'tag:yaml.org,2002:pairs';\n\n  for (const it of iterable) {\n    let key, value;\n\n    if (Array.isArray(it)) {\n      if (it.length === 2) {\n        key = it[0];\n        value = it[1];\n      } else throw new TypeError(`Expected [key, value] tuple: ${it}`);\n    } else if (it && it instanceof Object) {\n      const keys = Object.keys(it);\n\n      if (keys.length === 1) {\n        key = keys[0];\n        value = it[key];\n      } else throw new TypeError(`Expected { key: value } tuple: ${it}`);\n    } else {\n      key = it;\n    }\n\n    const pair = schema.createPair(key, value, ctx);\n    pairs.items.push(pair);\n  }\n\n  return pairs;\n}\nconst pairs = {\n  default: false,\n  tag: 'tag:yaml.org,2002:pairs',\n  resolve: parsePairs,\n  createNode: createPairs\n};\n\nclass YAMLOMap extends resolveSeq.YAMLSeq {\n  constructor() {\n    super();\n\n    PlainValue._defineProperty(this, \"add\", resolveSeq.YAMLMap.prototype.add.bind(this));\n\n    PlainValue._defineProperty(this, \"delete\", resolveSeq.YAMLMap.prototype.delete.bind(this));\n\n    PlainValue._defineProperty(this, \"get\", resolveSeq.YAMLMap.prototype.get.bind(this));\n\n    PlainValue._defineProperty(this, \"has\", resolveSeq.YAMLMap.prototype.has.bind(this));\n\n    PlainValue._defineProperty(this, \"set\", resolveSeq.YAMLMap.prototype.set.bind(this));\n\n    this.tag = YAMLOMap.tag;\n  }\n\n  toJSON(_, ctx) {\n    const map = new Map();\n    if (ctx && ctx.onCreate) ctx.onCreate(map);\n\n    for (const pair of this.items) {\n      let key, value;\n\n      if (pair instanceof resolveSeq.Pair) {\n        key = resolveSeq.toJSON(pair.key, '', ctx);\n        value = resolveSeq.toJSON(pair.value, key, ctx);\n      } else {\n        key = resolveSeq.toJSON(pair, '', ctx);\n      }\n\n      if (map.has(key)) throw new Error('Ordered maps must not include duplicate keys');\n      map.set(key, value);\n    }\n\n    return map;\n  }\n\n}\n\nPlainValue._defineProperty(YAMLOMap, \"tag\", 'tag:yaml.org,2002:omap');\n\nfunction parseOMap(doc, cst) {\n  const pairs = parsePairs(doc, cst);\n  const seenKeys = [];\n\n  for (const {\n    key\n  } of pairs.items) {\n    if (key instanceof resolveSeq.Scalar) {\n      if (seenKeys.includes(key.value)) {\n        const msg = 'Ordered maps must not include duplicate keys';\n        throw new PlainValue.YAMLSemanticError(cst, msg);\n      } else {\n        seenKeys.push(key.value);\n      }\n    }\n  }\n\n  return Object.assign(new YAMLOMap(), pairs);\n}\n\nfunction createOMap(schema, iterable, ctx) {\n  const pairs = createPairs(schema, iterable, ctx);\n  const omap = new YAMLOMap();\n  omap.items = pairs.items;\n  return omap;\n}\n\nconst omap = {\n  identify: value => value instanceof Map,\n  nodeClass: YAMLOMap,\n  default: false,\n  tag: 'tag:yaml.org,2002:omap',\n  resolve: parseOMap,\n  createNode: createOMap\n};\n\nclass YAMLSet extends resolveSeq.YAMLMap {\n  constructor() {\n    super();\n    this.tag = YAMLSet.tag;\n  }\n\n  add(key) {\n    const pair = key instanceof resolveSeq.Pair ? key : new resolveSeq.Pair(key);\n    const prev = resolveSeq.findPair(this.items, pair.key);\n    if (!prev) this.items.push(pair);\n  }\n\n  get(key, keepPair) {\n    const pair = resolveSeq.findPair(this.items, key);\n    return !keepPair && pair instanceof resolveSeq.Pair ? pair.key instanceof resolveSeq.Scalar ? pair.key.value : pair.key : pair;\n  }\n\n  set(key, value) {\n    if (typeof value !== 'boolean') throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);\n    const prev = resolveSeq.findPair(this.items, key);\n\n    if (prev && !value) {\n      this.items.splice(this.items.indexOf(prev), 1);\n    } else if (!prev && value) {\n      this.items.push(new resolveSeq.Pair(key));\n    }\n  }\n\n  toJSON(_, ctx) {\n    return super.toJSON(_, ctx, Set);\n  }\n\n  toString(ctx, onComment, onChompKeep) {\n    if (!ctx) return JSON.stringify(this);\n    if (this.hasAllNullValues()) return super.toString(ctx, onComment, onChompKeep);else throw new Error('Set items must all have null values');\n  }\n\n}\n\nPlainValue._defineProperty(YAMLSet, \"tag\", 'tag:yaml.org,2002:set');\n\nfunction parseSet(doc, cst) {\n  const map = resolveSeq.resolveMap(doc, cst);\n  if (!map.hasAllNullValues()) throw new PlainValue.YAMLSemanticError(cst, 'Set items must all have null values');\n  return Object.assign(new YAMLSet(), map);\n}\n\nfunction createSet(schema, iterable, ctx) {\n  const set = new YAMLSet();\n\n  for (const value of iterable) set.items.push(schema.createPair(value, null, ctx));\n\n  return set;\n}\n\nconst set = {\n  identify: value => value instanceof Set,\n  nodeClass: YAMLSet,\n  default: false,\n  tag: 'tag:yaml.org,2002:set',\n  resolve: parseSet,\n  createNode: createSet\n};\n\nconst parseSexagesimal = (sign, parts) => {\n  const n = parts.split(':').reduce((n, p) => n * 60 + Number(p), 0);\n  return sign === '-' ? -n : n;\n}; // hhhh:mm:ss.sss\n\n\nconst stringifySexagesimal = ({\n  value\n}) => {\n  if (isNaN(value) || !isFinite(value)) return resolveSeq.stringifyNumber(value);\n  let sign = '';\n\n  if (value < 0) {\n    sign = '-';\n    value = Math.abs(value);\n  }\n\n  const parts = [value % 60]; // seconds, including ms\n\n  if (value < 60) {\n    parts.unshift(0); // at least one : is required\n  } else {\n    value = Math.round((value - parts[0]) / 60);\n    parts.unshift(value % 60); // minutes\n\n    if (value >= 60) {\n      value = Math.round((value - parts[0]) / 60);\n      parts.unshift(value); // hours\n    }\n  }\n\n  return sign + parts.map(n => n < 10 ? '0' + String(n) : String(n)).join(':').replace(/000000\\d*$/, '') // % 60 may introduce error\n  ;\n};\n\nconst intTime = {\n  identify: value => typeof value === 'number',\n  default: true,\n  tag: 'tag:yaml.org,2002:int',\n  format: 'TIME',\n  test: /^([-+]?)([0-9][0-9_]*(?::[0-5]?[0-9])+)$/,\n  resolve: (str, sign, parts) => parseSexagesimal(sign, parts.replace(/_/g, '')),\n  stringify: stringifySexagesimal\n};\nconst floatTime = {\n  identify: value => typeof value === 'number',\n  default: true,\n  tag: 'tag:yaml.org,2002:float',\n  format: 'TIME',\n  test: /^([-+]?)([0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*)$/,\n  resolve: (str, sign, parts) => parseSexagesimal(sign, parts.replace(/_/g, '')),\n  stringify: stringifySexagesimal\n};\nconst timestamp = {\n  identify: value => value instanceof Date,\n  default: true,\n  tag: 'tag:yaml.org,2002:timestamp',\n  // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part\n  // may be omitted altogether, resulting in a date format. In such a case, the time part is\n  // assumed to be 00:00:00Z (start of day, UTC).\n  test: RegExp('^(?:' + '([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})' + // YYYY-Mm-Dd\n  '(?:(?:t|T|[ \\\\t]+)' + // t | T | whitespace\n  '([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\\\.[0-9]+)?)' + // Hh:Mm:Ss(.ss)?\n  '(?:[ \\\\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?' + // Z | +5 | -03:30\n  ')?' + ')$'),\n  resolve: (str, year, month, day, hour, minute, second, millisec, tz) => {\n    if (millisec) millisec = (millisec + '00').substr(1, 3);\n    let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec || 0);\n\n    if (tz && tz !== 'Z') {\n      let d = parseSexagesimal(tz[0], tz.slice(1));\n      if (Math.abs(d) < 30) d *= 60;\n      date -= 60000 * d;\n    }\n\n    return new Date(date);\n  },\n  stringify: ({\n    value\n  }) => value.toISOString().replace(/((T00:00)?:00)?\\.000Z$/, '')\n};\n\n/* global console, process, YAML_SILENCE_DEPRECATION_WARNINGS, YAML_SILENCE_WARNINGS */\nfunction shouldWarn(deprecation) {\n  const env = typeof process !== 'undefined' && process.env || {};\n\n  if (deprecation) {\n    if (typeof YAML_SILENCE_DEPRECATION_WARNINGS !== 'undefined') return !YAML_SILENCE_DEPRECATION_WARNINGS;\n    return !env.YAML_SILENCE_DEPRECATION_WARNINGS;\n  }\n\n  if (typeof YAML_SILENCE_WARNINGS !== 'undefined') return !YAML_SILENCE_WARNINGS;\n  return !env.YAML_SILENCE_WARNINGS;\n}\n\nfunction warn(warning, type) {\n  if (shouldWarn(false)) {\n    const emit = typeof process !== 'undefined' && process.emitWarning; // This will throw in Jest if `warning` is an Error instance due to\n    // https://github.com/facebook/jest/issues/2549\n\n    if (emit) emit(warning, type);else {\n      // eslint-disable-next-line no-console\n      console.warn(type ? `${type}: ${warning}` : warning);\n    }\n  }\n}\nfunction warnFileDeprecation(filename) {\n  if (shouldWarn(true)) {\n    const path = filename.replace(/.*yaml[/\\\\]/i, '').replace(/\\.js$/, '').replace(/\\\\/g, '/');\n    warn(`The endpoint 'yaml/${path}' will be removed in a future release.`, 'DeprecationWarning');\n  }\n}\nconst warned = {};\nfunction warnOptionDeprecation(name, alternative) {\n  if (!warned[name] && shouldWarn(true)) {\n    warned[name] = true;\n    let msg = `The option '${name}' will be removed in a future release`;\n    msg += alternative ? `, use '${alternative}' instead.` : '.';\n    warn(msg, 'DeprecationWarning');\n  }\n}\n\nexports.binary = binary;\nexports.floatTime = floatTime;\nexports.intTime = intTime;\nexports.omap = omap;\nexports.pairs = pairs;\nexports.set = set;\nexports.timestamp = timestamp;\nexports.warn = warn;\nexports.warnFileDeprecation = warnFileDeprecation;\nexports.warnOptionDeprecation = warnOptionDeprecation;\n", "'use strict';\n\nvar PlainValue = require('./PlainValue-ec8e588e.js');\nvar resolveSeq = require('./resolveSeq-d03cb037.js');\nvar warnings = require('./warnings-1000a372.js');\n\nfunction createMap(schema, obj, ctx) {\n  const map = new resolveSeq.YAMLMap(schema);\n\n  if (obj instanceof Map) {\n    for (const [key, value] of obj) map.items.push(schema.createPair(key, value, ctx));\n  } else if (obj && typeof obj === 'object') {\n    for (const key of Object.keys(obj)) map.items.push(schema.createPair(key, obj[key], ctx));\n  }\n\n  if (typeof schema.sortMapEntries === 'function') {\n    map.items.sort(schema.sortMapEntries);\n  }\n\n  return map;\n}\n\nconst map = {\n  createNode: createMap,\n  default: true,\n  nodeClass: resolveSeq.YAMLMap,\n  tag: 'tag:yaml.org,2002:map',\n  resolve: resolveSeq.resolveMap\n};\n\nfunction createSeq(schema, obj, ctx) {\n  const seq = new resolveSeq.YAMLSeq(schema);\n\n  if (obj && obj[Symbol.iterator]) {\n    for (const it of obj) {\n      const v = schema.createNode(it, ctx.wrapScalars, null, ctx);\n      seq.items.push(v);\n    }\n  }\n\n  return seq;\n}\n\nconst seq = {\n  createNode: createSeq,\n  default: true,\n  nodeClass: resolveSeq.YAMLSeq,\n  tag: 'tag:yaml.org,2002:seq',\n  resolve: resolveSeq.resolveSeq\n};\n\nconst string = {\n  identify: value => typeof value === 'string',\n  default: true,\n  tag: 'tag:yaml.org,2002:str',\n  resolve: resolveSeq.resolveString,\n\n  stringify(item, ctx, onComment, onChompKeep) {\n    ctx = Object.assign({\n      actualString: true\n    }, ctx);\n    return resolveSeq.stringifyString(item, ctx, onComment, onChompKeep);\n  },\n\n  options: resolveSeq.strOptions\n};\n\nconst failsafe = [map, seq, string];\n\n/* global BigInt */\n\nconst intIdentify$2 = value => typeof value === 'bigint' || Number.isInteger(value);\n\nconst intResolve$1 = (src, part, radix) => resolveSeq.intOptions.asBigInt ? BigInt(src) : parseInt(part, radix);\n\nfunction intStringify$1(node, radix, prefix) {\n  const {\n    value\n  } = node;\n  if (intIdentify$2(value) && value >= 0) return prefix + value.toString(radix);\n  return resolveSeq.stringifyNumber(node);\n}\n\nconst nullObj = {\n  identify: value => value == null,\n  createNode: (schema, value, ctx) => ctx.wrapScalars ? new resolveSeq.Scalar(null) : null,\n  default: true,\n  tag: 'tag:yaml.org,2002:null',\n  test: /^(?:~|[Nn]ull|NULL)?$/,\n  resolve: () => null,\n  options: resolveSeq.nullOptions,\n  stringify: () => resolveSeq.nullOptions.nullStr\n};\nconst boolObj = {\n  identify: value => typeof value === 'boolean',\n  default: true,\n  tag: 'tag:yaml.org,2002:bool',\n  test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,\n  resolve: str => str[0] === 't' || str[0] === 'T',\n  options: resolveSeq.boolOptions,\n  stringify: ({\n    value\n  }) => value ? resolveSeq.boolOptions.trueStr : resolveSeq.boolOptions.falseStr\n};\nconst octObj = {\n  identify: value => intIdentify$2(value) && value >= 0,\n  default: true,\n  tag: 'tag:yaml.org,2002:int',\n  format: 'OCT',\n  test: /^0o([0-7]+)$/,\n  resolve: (str, oct) => intResolve$1(str, oct, 8),\n  options: resolveSeq.intOptions,\n  stringify: node => intStringify$1(node, 8, '0o')\n};\nconst intObj = {\n  identify: intIdentify$2,\n  default: true,\n  tag: 'tag:yaml.org,2002:int',\n  test: /^[-+]?[0-9]+$/,\n  resolve: str => intResolve$1(str, str, 10),\n  options: resolveSeq.intOptions,\n  stringify: resolveSeq.stringifyNumber\n};\nconst hexObj = {\n  identify: value => intIdentify$2(value) && value >= 0,\n  default: true,\n  tag: 'tag:yaml.org,2002:int',\n  format: 'HEX',\n  test: /^0x([0-9a-fA-F]+)$/,\n  resolve: (str, hex) => intResolve$1(str, hex, 16),\n  options: resolveSeq.intOptions,\n  stringify: node => intStringify$1(node, 16, '0x')\n};\nconst nanObj = {\n  identify: value => typeof value === 'number',\n  default: true,\n  tag: 'tag:yaml.org,2002:float',\n  test: /^(?:[-+]?\\.inf|(\\.nan))$/i,\n  resolve: (str, nan) => nan ? NaN : str[0] === '-' ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,\n  stringify: resolveSeq.stringifyNumber\n};\nconst expObj = {\n  identify: value => typeof value === 'number',\n  default: true,\n  tag: 'tag:yaml.org,2002:float',\n  format: 'EXP',\n  test: /^[-+]?(?:\\.[0-9]+|[0-9]+(?:\\.[0-9]*)?)[eE][-+]?[0-9]+$/,\n  resolve: str => parseFloat(str),\n  stringify: ({\n    value\n  }) => Number(value).toExponential()\n};\nconst floatObj = {\n  identify: value => typeof value === 'number',\n  default: true,\n  tag: 'tag:yaml.org,2002:float',\n  test: /^[-+]?(?:\\.([0-9]+)|[0-9]+\\.([0-9]*))$/,\n\n  resolve(str, frac1, frac2) {\n    const frac = frac1 || frac2;\n    const node = new resolveSeq.Scalar(parseFloat(str));\n    if (frac && frac[frac.length - 1] === '0') node.minFractionDigits = frac.length;\n    return node;\n  },\n\n  stringify: resolveSeq.stringifyNumber\n};\nconst core = failsafe.concat([nullObj, boolObj, octObj, intObj, hexObj, nanObj, expObj, floatObj]);\n\n/* global BigInt */\n\nconst intIdentify$1 = value => typeof value === 'bigint' || Number.isInteger(value);\n\nconst stringifyJSON = ({\n  value\n}) => JSON.stringify(value);\n\nconst json = [map, seq, {\n  identify: value => typeof value === 'string',\n  default: true,\n  tag: 'tag:yaml.org,2002:str',\n  resolve: resolveSeq.resolveString,\n  stringify: stringifyJSON\n}, {\n  identify: value => value == null,\n  createNode: (schema, value, ctx) => ctx.wrapScalars ? new resolveSeq.Scalar(null) : null,\n  default: true,\n  tag: 'tag:yaml.org,2002:null',\n  test: /^null$/,\n  resolve: () => null,\n  stringify: stringifyJSON\n}, {\n  identify: value => typeof value === 'boolean',\n  default: true,\n  tag: 'tag:yaml.org,2002:bool',\n  test: /^true|false$/,\n  resolve: str => str === 'true',\n  stringify: stringifyJSON\n}, {\n  identify: intIdentify$1,\n  default: true,\n  tag: 'tag:yaml.org,2002:int',\n  test: /^-?(?:0|[1-9][0-9]*)$/,\n  resolve: str => resolveSeq.intOptions.asBigInt ? BigInt(str) : parseInt(str, 10),\n  stringify: ({\n    value\n  }) => intIdentify$1(value) ? value.toString() : JSON.stringify(value)\n}, {\n  identify: value => typeof value === 'number',\n  default: true,\n  tag: 'tag:yaml.org,2002:float',\n  test: /^-?(?:0|[1-9][0-9]*)(?:\\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,\n  resolve: str => parseFloat(str),\n  stringify: stringifyJSON\n}];\n\njson.scalarFallback = str => {\n  throw new SyntaxError(`Unresolved plain scalar ${JSON.stringify(str)}`);\n};\n\n/* global BigInt */\n\nconst boolStringify = ({\n  value\n}) => value ? resolveSeq.boolOptions.trueStr : resolveSeq.boolOptions.falseStr;\n\nconst intIdentify = value => typeof value === 'bigint' || Number.isInteger(value);\n\nfunction intResolve(sign, src, radix) {\n  let str = src.replace(/_/g, '');\n\n  if (resolveSeq.intOptions.asBigInt) {\n    switch (radix) {\n      case 2:\n        str = `0b${str}`;\n        break;\n\n      case 8:\n        str = `0o${str}`;\n        break;\n\n      case 16:\n        str = `0x${str}`;\n        break;\n    }\n\n    const n = BigInt(str);\n    return sign === '-' ? BigInt(-1) * n : n;\n  }\n\n  const n = parseInt(str, radix);\n  return sign === '-' ? -1 * n : n;\n}\n\nfunction intStringify(node, radix, prefix) {\n  const {\n    value\n  } = node;\n\n  if (intIdentify(value)) {\n    const str = value.toString(radix);\n    return value < 0 ? '-' + prefix + str.substr(1) : prefix + str;\n  }\n\n  return resolveSeq.stringifyNumber(node);\n}\n\nconst yaml11 = failsafe.concat([{\n  identify: value => value == null,\n  createNode: (schema, value, ctx) => ctx.wrapScalars ? new resolveSeq.Scalar(null) : null,\n  default: true,\n  tag: 'tag:yaml.org,2002:null',\n  test: /^(?:~|[Nn]ull|NULL)?$/,\n  resolve: () => null,\n  options: resolveSeq.nullOptions,\n  stringify: () => resolveSeq.nullOptions.nullStr\n}, {\n  identify: value => typeof value === 'boolean',\n  default: true,\n  tag: 'tag:yaml.org,2002:bool',\n  test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,\n  resolve: () => true,\n  options: resolveSeq.boolOptions,\n  stringify: boolStringify\n}, {\n  identify: value => typeof value === 'boolean',\n  default: true,\n  tag: 'tag:yaml.org,2002:bool',\n  test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/i,\n  resolve: () => false,\n  options: resolveSeq.boolOptions,\n  stringify: boolStringify\n}, {\n  identify: intIdentify,\n  default: true,\n  tag: 'tag:yaml.org,2002:int',\n  format: 'BIN',\n  test: /^([-+]?)0b([0-1_]+)$/,\n  resolve: (str, sign, bin) => intResolve(sign, bin, 2),\n  stringify: node => intStringify(node, 2, '0b')\n}, {\n  identify: intIdentify,\n  default: true,\n  tag: 'tag:yaml.org,2002:int',\n  format: 'OCT',\n  test: /^([-+]?)0([0-7_]+)$/,\n  resolve: (str, sign, oct) => intResolve(sign, oct, 8),\n  stringify: node => intStringify(node, 8, '0')\n}, {\n  identify: intIdentify,\n  default: true,\n  tag: 'tag:yaml.org,2002:int',\n  test: /^([-+]?)([0-9][0-9_]*)$/,\n  resolve: (str, sign, abs) => intResolve(sign, abs, 10),\n  stringify: resolveSeq.stringifyNumber\n}, {\n  identify: intIdentify,\n  default: true,\n  tag: 'tag:yaml.org,2002:int',\n  format: 'HEX',\n  test: /^([-+]?)0x([0-9a-fA-F_]+)$/,\n  resolve: (str, sign, hex) => intResolve(sign, hex, 16),\n  stringify: node => intStringify(node, 16, '0x')\n}, {\n  identify: value => typeof value === 'number',\n  default: true,\n  tag: 'tag:yaml.org,2002:float',\n  test: /^(?:[-+]?\\.inf|(\\.nan))$/i,\n  resolve: (str, nan) => nan ? NaN : str[0] === '-' ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,\n  stringify: resolveSeq.stringifyNumber\n}, {\n  identify: value => typeof value === 'number',\n  default: true,\n  tag: 'tag:yaml.org,2002:float',\n  format: 'EXP',\n  test: /^[-+]?([0-9][0-9_]*)?(\\.[0-9_]*)?[eE][-+]?[0-9]+$/,\n  resolve: str => parseFloat(str.replace(/_/g, '')),\n  stringify: ({\n    value\n  }) => Number(value).toExponential()\n}, {\n  identify: value => typeof value === 'number',\n  default: true,\n  tag: 'tag:yaml.org,2002:float',\n  test: /^[-+]?(?:[0-9][0-9_]*)?\\.([0-9_]*)$/,\n\n  resolve(str, frac) {\n    const node = new resolveSeq.Scalar(parseFloat(str.replace(/_/g, '')));\n\n    if (frac) {\n      const f = frac.replace(/_/g, '');\n      if (f[f.length - 1] === '0') node.minFractionDigits = f.length;\n    }\n\n    return node;\n  },\n\n  stringify: resolveSeq.stringifyNumber\n}], warnings.binary, warnings.omap, warnings.pairs, warnings.set, warnings.intTime, warnings.floatTime, warnings.timestamp);\n\nconst schemas = {\n  core,\n  failsafe,\n  json,\n  yaml11\n};\nconst tags = {\n  binary: warnings.binary,\n  bool: boolObj,\n  float: floatObj,\n  floatExp: expObj,\n  floatNaN: nanObj,\n  floatTime: warnings.floatTime,\n  int: intObj,\n  intHex: hexObj,\n  intOct: octObj,\n  intTime: warnings.intTime,\n  map,\n  null: nullObj,\n  omap: warnings.omap,\n  pairs: warnings.pairs,\n  seq,\n  set: warnings.set,\n  timestamp: warnings.timestamp\n};\n\nfunction findTagObject(value, tagName, tags) {\n  if (tagName) {\n    const match = tags.filter(t => t.tag === tagName);\n    const tagObj = match.find(t => !t.format) || match[0];\n    if (!tagObj) throw new Error(`Tag ${tagName} not found`);\n    return tagObj;\n  } // TODO: deprecate/remove class check\n\n\n  return tags.find(t => (t.identify && t.identify(value) || t.class && value instanceof t.class) && !t.format);\n}\n\nfunction createNode(value, tagName, ctx) {\n  if (value instanceof resolveSeq.Node) return value;\n  const {\n    defaultPrefix,\n    onTagObj,\n    prevObjects,\n    schema,\n    wrapScalars\n  } = ctx;\n  if (tagName && tagName.startsWith('!!')) tagName = defaultPrefix + tagName.slice(2);\n  let tagObj = findTagObject(value, tagName, schema.tags);\n\n  if (!tagObj) {\n    if (typeof value.toJSON === 'function') value = value.toJSON();\n    if (!value || typeof value !== 'object') return wrapScalars ? new resolveSeq.Scalar(value) : value;\n    tagObj = value instanceof Map ? map : value[Symbol.iterator] ? seq : map;\n  }\n\n  if (onTagObj) {\n    onTagObj(tagObj);\n    delete ctx.onTagObj;\n  } // Detect duplicate references to the same object & use Alias nodes for all\n  // after first. The `obj` wrapper allows for circular references to resolve.\n\n\n  const obj = {\n    value: undefined,\n    node: undefined\n  };\n\n  if (value && typeof value === 'object' && prevObjects) {\n    const prev = prevObjects.get(value);\n\n    if (prev) {\n      const alias = new resolveSeq.Alias(prev); // leaves source dirty; must be cleaned by caller\n\n      ctx.aliasNodes.push(alias); // defined along with prevObjects\n\n      return alias;\n    }\n\n    obj.value = value;\n    prevObjects.set(value, obj);\n  }\n\n  obj.node = tagObj.createNode ? tagObj.createNode(ctx.schema, value, ctx) : wrapScalars ? new resolveSeq.Scalar(value) : value;\n  if (tagName && obj.node instanceof resolveSeq.Node) obj.node.tag = tagName;\n  return obj.node;\n}\n\nfunction getSchemaTags(schemas, knownTags, customTags, schemaId) {\n  let tags = schemas[schemaId.replace(/\\W/g, '')]; // 'yaml-1.1' -> 'yaml11'\n\n  if (!tags) {\n    const keys = Object.keys(schemas).map(key => JSON.stringify(key)).join(', ');\n    throw new Error(`Unknown schema \"${schemaId}\"; use one of ${keys}`);\n  }\n\n  if (Array.isArray(customTags)) {\n    for (const tag of customTags) tags = tags.concat(tag);\n  } else if (typeof customTags === 'function') {\n    tags = customTags(tags.slice());\n  }\n\n  for (let i = 0; i < tags.length; ++i) {\n    const tag = tags[i];\n\n    if (typeof tag === 'string') {\n      const tagObj = knownTags[tag];\n\n      if (!tagObj) {\n        const keys = Object.keys(knownTags).map(key => JSON.stringify(key)).join(', ');\n        throw new Error(`Unknown custom tag \"${tag}\"; use one of ${keys}`);\n      }\n\n      tags[i] = tagObj;\n    }\n  }\n\n  return tags;\n}\n\nconst sortMapEntriesByKey = (a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0;\n\nclass Schema {\n  // TODO: remove in v2\n  // TODO: remove in v2\n  constructor({\n    customTags,\n    merge,\n    schema,\n    sortMapEntries,\n    tags: deprecatedCustomTags\n  }) {\n    this.merge = !!merge;\n    this.name = schema;\n    this.sortMapEntries = sortMapEntries === true ? sortMapEntriesByKey : sortMapEntries || null;\n    if (!customTags && deprecatedCustomTags) warnings.warnOptionDeprecation('tags', 'customTags');\n    this.tags = getSchemaTags(schemas, tags, customTags || deprecatedCustomTags, schema);\n  }\n\n  createNode(value, wrapScalars, tagName, ctx) {\n    const baseCtx = {\n      defaultPrefix: Schema.defaultPrefix,\n      schema: this,\n      wrapScalars\n    };\n    const createCtx = ctx ? Object.assign(ctx, baseCtx) : baseCtx;\n    return createNode(value, tagName, createCtx);\n  }\n\n  createPair(key, value, ctx) {\n    if (!ctx) ctx = {\n      wrapScalars: true\n    };\n    const k = this.createNode(key, ctx.wrapScalars, null, ctx);\n    const v = this.createNode(value, ctx.wrapScalars, null, ctx);\n    return new resolveSeq.Pair(k, v);\n  }\n\n}\n\nPlainValue._defineProperty(Schema, \"defaultPrefix\", PlainValue.defaultTagPrefix);\n\nPlainValue._defineProperty(Schema, \"defaultTags\", PlainValue.defaultTags);\n\nexports.Schema = Schema;\n", "'use strict';\n\nvar PlainValue = require('./PlainValue-ec8e588e.js');\nvar resolveSeq = require('./resolveSeq-d03cb037.js');\nvar Schema = require('./Schema-88e323a7.js');\n\nconst defaultOptions = {\n  anchorPrefix: 'a',\n  customTags: null,\n  indent: 2,\n  indentSeq: true,\n  keepCstNodes: false,\n  keepNodeTypes: true,\n  keepBlobsInJSON: true,\n  mapAsMap: false,\n  maxAliasCount: 100,\n  prettyErrors: false,\n  // TODO Set true in v2\n  simpleKeys: false,\n  version: '1.2'\n};\nconst scalarOptions = {\n  get binary() {\n    return resolveSeq.binaryOptions;\n  },\n\n  set binary(opt) {\n    Object.assign(resolveSeq.binaryOptions, opt);\n  },\n\n  get bool() {\n    return resolveSeq.boolOptions;\n  },\n\n  set bool(opt) {\n    Object.assign(resolveSeq.boolOptions, opt);\n  },\n\n  get int() {\n    return resolveSeq.intOptions;\n  },\n\n  set int(opt) {\n    Object.assign(resolveSeq.intOptions, opt);\n  },\n\n  get null() {\n    return resolveSeq.nullOptions;\n  },\n\n  set null(opt) {\n    Object.assign(resolveSeq.nullOptions, opt);\n  },\n\n  get str() {\n    return resolveSeq.strOptions;\n  },\n\n  set str(opt) {\n    Object.assign(resolveSeq.strOptions, opt);\n  }\n\n};\nconst documentOptions = {\n  '1.0': {\n    schema: 'yaml-1.1',\n    merge: true,\n    tagPrefixes: [{\n      handle: '!',\n      prefix: PlainValue.defaultTagPrefix\n    }, {\n      handle: '!!',\n      prefix: 'tag:private.yaml.org,2002:'\n    }]\n  },\n  1.1: {\n    schema: 'yaml-1.1',\n    merge: true,\n    tagPrefixes: [{\n      handle: '!',\n      prefix: '!'\n    }, {\n      handle: '!!',\n      prefix: PlainValue.defaultTagPrefix\n    }]\n  },\n  1.2: {\n    schema: 'core',\n    merge: false,\n    tagPrefixes: [{\n      handle: '!',\n      prefix: '!'\n    }, {\n      handle: '!!',\n      prefix: PlainValue.defaultTagPrefix\n    }]\n  }\n};\n\nfunction stringifyTag(doc, tag) {\n  if ((doc.version || doc.options.version) === '1.0') {\n    const priv = tag.match(/^tag:private\\.yaml\\.org,2002:([^:/]+)$/);\n    if (priv) return '!' + priv[1];\n    const vocab = tag.match(/^tag:([a-zA-Z0-9-]+)\\.yaml\\.org,2002:(.*)/);\n    return vocab ? `!${vocab[1]}/${vocab[2]}` : `!${tag.replace(/^tag:/, '')}`;\n  }\n\n  let p = doc.tagPrefixes.find(p => tag.indexOf(p.prefix) === 0);\n\n  if (!p) {\n    const dtp = doc.getDefaults().tagPrefixes;\n    p = dtp && dtp.find(p => tag.indexOf(p.prefix) === 0);\n  }\n\n  if (!p) return tag[0] === '!' ? tag : `!<${tag}>`;\n  const suffix = tag.substr(p.prefix.length).replace(/[!,[\\]{}]/g, ch => ({\n    '!': '%21',\n    ',': '%2C',\n    '[': '%5B',\n    ']': '%5D',\n    '{': '%7B',\n    '}': '%7D'\n  })[ch]);\n  return p.handle + suffix;\n}\n\nfunction getTagObject(tags, item) {\n  if (item instanceof resolveSeq.Alias) return resolveSeq.Alias;\n\n  if (item.tag) {\n    const match = tags.filter(t => t.tag === item.tag);\n    if (match.length > 0) return match.find(t => t.format === item.format) || match[0];\n  }\n\n  let tagObj, obj;\n\n  if (item instanceof resolveSeq.Scalar) {\n    obj = item.value; // TODO: deprecate/remove class check\n\n    const match = tags.filter(t => t.identify && t.identify(obj) || t.class && obj instanceof t.class);\n    tagObj = match.find(t => t.format === item.format) || match.find(t => !t.format);\n  } else {\n    obj = item;\n    tagObj = tags.find(t => t.nodeClass && obj instanceof t.nodeClass);\n  }\n\n  if (!tagObj) {\n    const name = obj && obj.constructor ? obj.constructor.name : typeof obj;\n    throw new Error(`Tag not resolved for ${name} value`);\n  }\n\n  return tagObj;\n} // needs to be called before value stringifier to allow for circular anchor refs\n\n\nfunction stringifyProps(node, tagObj, {\n  anchors,\n  doc\n}) {\n  const props = [];\n  const anchor = doc.anchors.getName(node);\n\n  if (anchor) {\n    anchors[anchor] = node;\n    props.push(`&${anchor}`);\n  }\n\n  if (node.tag) {\n    props.push(stringifyTag(doc, node.tag));\n  } else if (!tagObj.default) {\n    props.push(stringifyTag(doc, tagObj.tag));\n  }\n\n  return props.join(' ');\n}\n\nfunction stringify(item, ctx, onComment, onChompKeep) {\n  const {\n    anchors,\n    schema\n  } = ctx.doc;\n  let tagObj;\n\n  if (!(item instanceof resolveSeq.Node)) {\n    const createCtx = {\n      aliasNodes: [],\n      onTagObj: o => tagObj = o,\n      prevObjects: new Map()\n    };\n    item = schema.createNode(item, true, null, createCtx);\n\n    for (const alias of createCtx.aliasNodes) {\n      alias.source = alias.source.node;\n      let name = anchors.getName(alias.source);\n\n      if (!name) {\n        name = anchors.newName();\n        anchors.map[name] = alias.source;\n      }\n    }\n  }\n\n  if (item instanceof resolveSeq.Pair) return item.toString(ctx, onComment, onChompKeep);\n  if (!tagObj) tagObj = getTagObject(schema.tags, item);\n  const props = stringifyProps(item, tagObj, ctx);\n  if (props.length > 0) ctx.indentAtStart = (ctx.indentAtStart || 0) + props.length + 1;\n  const str = typeof tagObj.stringify === 'function' ? tagObj.stringify(item, ctx, onComment, onChompKeep) : item instanceof resolveSeq.Scalar ? resolveSeq.stringifyString(item, ctx, onComment, onChompKeep) : item.toString(ctx, onComment, onChompKeep);\n  if (!props) return str;\n  return item instanceof resolveSeq.Scalar || str[0] === '{' || str[0] === '[' ? `${props} ${str}` : `${props}\\n${ctx.indent}${str}`;\n}\n\nclass Anchors {\n  static validAnchorNode(node) {\n    return node instanceof resolveSeq.Scalar || node instanceof resolveSeq.YAMLSeq || node instanceof resolveSeq.YAMLMap;\n  }\n\n  constructor(prefix) {\n    PlainValue._defineProperty(this, \"map\", Object.create(null));\n\n    this.prefix = prefix;\n  }\n\n  createAlias(node, name) {\n    this.setAnchor(node, name);\n    return new resolveSeq.Alias(node);\n  }\n\n  createMergePair(...sources) {\n    const merge = new resolveSeq.Merge();\n    merge.value.items = sources.map(s => {\n      if (s instanceof resolveSeq.Alias) {\n        if (s.source instanceof resolveSeq.YAMLMap) return s;\n      } else if (s instanceof resolveSeq.YAMLMap) {\n        return this.createAlias(s);\n      }\n\n      throw new Error('Merge sources must be Map nodes or their Aliases');\n    });\n    return merge;\n  }\n\n  getName(node) {\n    const {\n      map\n    } = this;\n    return Object.keys(map).find(a => map[a] === node);\n  }\n\n  getNames() {\n    return Object.keys(this.map);\n  }\n\n  getNode(name) {\n    return this.map[name];\n  }\n\n  newName(prefix) {\n    if (!prefix) prefix = this.prefix;\n    const names = Object.keys(this.map);\n\n    for (let i = 1; true; ++i) {\n      const name = `${prefix}${i}`;\n      if (!names.includes(name)) return name;\n    }\n  } // During parsing, map & aliases contain CST nodes\n\n\n  resolveNodes() {\n    const {\n      map,\n      _cstAliases\n    } = this;\n    Object.keys(map).forEach(a => {\n      map[a] = map[a].resolved;\n    });\n\n    _cstAliases.forEach(a => {\n      a.source = a.source.resolved;\n    });\n\n    delete this._cstAliases;\n  }\n\n  setAnchor(node, name) {\n    if (node != null && !Anchors.validAnchorNode(node)) {\n      throw new Error('Anchors may only be set for Scalar, Seq and Map nodes');\n    }\n\n    if (name && /[\\x00-\\x19\\s,[\\]{}]/.test(name)) {\n      throw new Error('Anchor names must not contain whitespace or control characters');\n    }\n\n    const {\n      map\n    } = this;\n    const prev = node && Object.keys(map).find(a => map[a] === node);\n\n    if (prev) {\n      if (!name) {\n        return prev;\n      } else if (prev !== name) {\n        delete map[prev];\n        map[name] = node;\n      }\n    } else {\n      if (!name) {\n        if (!node) return null;\n        name = this.newName();\n      }\n\n      map[name] = node;\n    }\n\n    return name;\n  }\n\n}\n\nconst visit = (node, tags) => {\n  if (node && typeof node === 'object') {\n    const {\n      tag\n    } = node;\n\n    if (node instanceof resolveSeq.Collection) {\n      if (tag) tags[tag] = true;\n      node.items.forEach(n => visit(n, tags));\n    } else if (node instanceof resolveSeq.Pair) {\n      visit(node.key, tags);\n      visit(node.value, tags);\n    } else if (node instanceof resolveSeq.Scalar) {\n      if (tag) tags[tag] = true;\n    }\n  }\n\n  return tags;\n};\n\nconst listTagNames = node => Object.keys(visit(node, {}));\n\nfunction parseContents(doc, contents) {\n  const comments = {\n    before: [],\n    after: []\n  };\n  let body = undefined;\n  let spaceBefore = false;\n\n  for (const node of contents) {\n    if (node.valueRange) {\n      if (body !== undefined) {\n        const msg = 'Document contains trailing content not separated by a ... or --- line';\n        doc.errors.push(new PlainValue.YAMLSyntaxError(node, msg));\n        break;\n      }\n\n      const res = resolveSeq.resolveNode(doc, node);\n\n      if (spaceBefore) {\n        res.spaceBefore = true;\n        spaceBefore = false;\n      }\n\n      body = res;\n    } else if (node.comment !== null) {\n      const cc = body === undefined ? comments.before : comments.after;\n      cc.push(node.comment);\n    } else if (node.type === PlainValue.Type.BLANK_LINE) {\n      spaceBefore = true;\n\n      if (body === undefined && comments.before.length > 0 && !doc.commentBefore) {\n        // space-separated comments at start are parsed as document comments\n        doc.commentBefore = comments.before.join('\\n');\n        comments.before = [];\n      }\n    }\n  }\n\n  doc.contents = body || null;\n\n  if (!body) {\n    doc.comment = comments.before.concat(comments.after).join('\\n') || null;\n  } else {\n    const cb = comments.before.join('\\n');\n\n    if (cb) {\n      const cbNode = body instanceof resolveSeq.Collection && body.items[0] ? body.items[0] : body;\n      cbNode.commentBefore = cbNode.commentBefore ? `${cb}\\n${cbNode.commentBefore}` : cb;\n    }\n\n    doc.comment = comments.after.join('\\n') || null;\n  }\n}\n\nfunction resolveTagDirective({\n  tagPrefixes\n}, directive) {\n  const [handle, prefix] = directive.parameters;\n\n  if (!handle || !prefix) {\n    const msg = 'Insufficient parameters given for %TAG directive';\n    throw new PlainValue.YAMLSemanticError(directive, msg);\n  }\n\n  if (tagPrefixes.some(p => p.handle === handle)) {\n    const msg = 'The %TAG directive must only be given at most once per handle in the same document.';\n    throw new PlainValue.YAMLSemanticError(directive, msg);\n  }\n\n  return {\n    handle,\n    prefix\n  };\n}\n\nfunction resolveYamlDirective(doc, directive) {\n  let [version] = directive.parameters;\n  if (directive.name === 'YAML:1.0') version = '1.0';\n\n  if (!version) {\n    const msg = 'Insufficient parameters given for %YAML directive';\n    throw new PlainValue.YAMLSemanticError(directive, msg);\n  }\n\n  if (!documentOptions[version]) {\n    const v0 = doc.version || doc.options.version;\n    const msg = `Document will be parsed as YAML ${v0} rather than YAML ${version}`;\n    doc.warnings.push(new PlainValue.YAMLWarning(directive, msg));\n  }\n\n  return version;\n}\n\nfunction parseDirectives(doc, directives, prevDoc) {\n  const directiveComments = [];\n  let hasDirectives = false;\n\n  for (const directive of directives) {\n    const {\n      comment,\n      name\n    } = directive;\n\n    switch (name) {\n      case 'TAG':\n        try {\n          doc.tagPrefixes.push(resolveTagDirective(doc, directive));\n        } catch (error) {\n          doc.errors.push(error);\n        }\n\n        hasDirectives = true;\n        break;\n\n      case 'YAML':\n      case 'YAML:1.0':\n        if (doc.version) {\n          const msg = 'The %YAML directive must only be given at most once per document.';\n          doc.errors.push(new PlainValue.YAMLSemanticError(directive, msg));\n        }\n\n        try {\n          doc.version = resolveYamlDirective(doc, directive);\n        } catch (error) {\n          doc.errors.push(error);\n        }\n\n        hasDirectives = true;\n        break;\n\n      default:\n        if (name) {\n          const msg = `YAML only supports %TAG and %YAML directives, and not %${name}`;\n          doc.warnings.push(new PlainValue.YAMLWarning(directive, msg));\n        }\n\n    }\n\n    if (comment) directiveComments.push(comment);\n  }\n\n  if (prevDoc && !hasDirectives && '1.1' === (doc.version || prevDoc.version || doc.options.version)) {\n    const copyTagPrefix = ({\n      handle,\n      prefix\n    }) => ({\n      handle,\n      prefix\n    });\n\n    doc.tagPrefixes = prevDoc.tagPrefixes.map(copyTagPrefix);\n    doc.version = prevDoc.version;\n  }\n\n  doc.commentBefore = directiveComments.join('\\n') || null;\n}\n\nfunction assertCollection(contents) {\n  if (contents instanceof resolveSeq.Collection) return true;\n  throw new Error('Expected a YAML collection as document contents');\n}\n\nclass Document {\n  constructor(options) {\n    this.anchors = new Anchors(options.anchorPrefix);\n    this.commentBefore = null;\n    this.comment = null;\n    this.contents = null;\n    this.directivesEndMarker = null;\n    this.errors = [];\n    this.options = options;\n    this.schema = null;\n    this.tagPrefixes = [];\n    this.version = null;\n    this.warnings = [];\n  }\n\n  add(value) {\n    assertCollection(this.contents);\n    return this.contents.add(value);\n  }\n\n  addIn(path, value) {\n    assertCollection(this.contents);\n    this.contents.addIn(path, value);\n  }\n\n  delete(key) {\n    assertCollection(this.contents);\n    return this.contents.delete(key);\n  }\n\n  deleteIn(path) {\n    if (resolveSeq.isEmptyPath(path)) {\n      if (this.contents == null) return false;\n      this.contents = null;\n      return true;\n    }\n\n    assertCollection(this.contents);\n    return this.contents.deleteIn(path);\n  }\n\n  getDefaults() {\n    return Document.defaults[this.version] || Document.defaults[this.options.version] || {};\n  }\n\n  get(key, keepScalar) {\n    return this.contents instanceof resolveSeq.Collection ? this.contents.get(key, keepScalar) : undefined;\n  }\n\n  getIn(path, keepScalar) {\n    if (resolveSeq.isEmptyPath(path)) return !keepScalar && this.contents instanceof resolveSeq.Scalar ? this.contents.value : this.contents;\n    return this.contents instanceof resolveSeq.Collection ? this.contents.getIn(path, keepScalar) : undefined;\n  }\n\n  has(key) {\n    return this.contents instanceof resolveSeq.Collection ? this.contents.has(key) : false;\n  }\n\n  hasIn(path) {\n    if (resolveSeq.isEmptyPath(path)) return this.contents !== undefined;\n    return this.contents instanceof resolveSeq.Collection ? this.contents.hasIn(path) : false;\n  }\n\n  set(key, value) {\n    assertCollection(this.contents);\n    this.contents.set(key, value);\n  }\n\n  setIn(path, value) {\n    if (resolveSeq.isEmptyPath(path)) this.contents = value;else {\n      assertCollection(this.contents);\n      this.contents.setIn(path, value);\n    }\n  }\n\n  setSchema(id, customTags) {\n    if (!id && !customTags && this.schema) return;\n    if (typeof id === 'number') id = id.toFixed(1);\n\n    if (id === '1.0' || id === '1.1' || id === '1.2') {\n      if (this.version) this.version = id;else this.options.version = id;\n      delete this.options.schema;\n    } else if (id && typeof id === 'string') {\n      this.options.schema = id;\n    }\n\n    if (Array.isArray(customTags)) this.options.customTags = customTags;\n    const opt = Object.assign({}, this.getDefaults(), this.options);\n    this.schema = new Schema.Schema(opt);\n  }\n\n  parse(node, prevDoc) {\n    if (this.options.keepCstNodes) this.cstNode = node;\n    if (this.options.keepNodeTypes) this.type = 'DOCUMENT';\n    const {\n      directives = [],\n      contents = [],\n      directivesEndMarker,\n      error,\n      valueRange\n    } = node;\n\n    if (error) {\n      if (!error.source) error.source = this;\n      this.errors.push(error);\n    }\n\n    parseDirectives(this, directives, prevDoc);\n    if (directivesEndMarker) this.directivesEndMarker = true;\n    this.range = valueRange ? [valueRange.start, valueRange.end] : null;\n    this.setSchema();\n    this.anchors._cstAliases = [];\n    parseContents(this, contents);\n    this.anchors.resolveNodes();\n\n    if (this.options.prettyErrors) {\n      for (const error of this.errors) if (error instanceof PlainValue.YAMLError) error.makePretty();\n\n      for (const warn of this.warnings) if (warn instanceof PlainValue.YAMLError) warn.makePretty();\n    }\n\n    return this;\n  }\n\n  listNonDefaultTags() {\n    return listTagNames(this.contents).filter(t => t.indexOf(Schema.Schema.defaultPrefix) !== 0);\n  }\n\n  setTagPrefix(handle, prefix) {\n    if (handle[0] !== '!' || handle[handle.length - 1] !== '!') throw new Error('Handle must start and end with !');\n\n    if (prefix) {\n      const prev = this.tagPrefixes.find(p => p.handle === handle);\n      if (prev) prev.prefix = prefix;else this.tagPrefixes.push({\n        handle,\n        prefix\n      });\n    } else {\n      this.tagPrefixes = this.tagPrefixes.filter(p => p.handle !== handle);\n    }\n  }\n\n  toJSON(arg, onAnchor) {\n    const {\n      keepBlobsInJSON,\n      mapAsMap,\n      maxAliasCount\n    } = this.options;\n    const keep = keepBlobsInJSON && (typeof arg !== 'string' || !(this.contents instanceof resolveSeq.Scalar));\n    const ctx = {\n      doc: this,\n      indentStep: '  ',\n      keep,\n      mapAsMap: keep && !!mapAsMap,\n      maxAliasCount,\n      stringify // Requiring directly in Pair would create circular dependencies\n\n    };\n    const anchorNames = Object.keys(this.anchors.map);\n    if (anchorNames.length > 0) ctx.anchors = new Map(anchorNames.map(name => [this.anchors.map[name], {\n      alias: [],\n      aliasCount: 0,\n      count: 1\n    }]));\n    const res = resolveSeq.toJSON(this.contents, arg, ctx);\n    if (typeof onAnchor === 'function' && ctx.anchors) for (const {\n      count,\n      res\n    } of ctx.anchors.values()) onAnchor(res, count);\n    return res;\n  }\n\n  toString() {\n    if (this.errors.length > 0) throw new Error('Document with errors cannot be stringified');\n    const indentSize = this.options.indent;\n\n    if (!Number.isInteger(indentSize) || indentSize <= 0) {\n      const s = JSON.stringify(indentSize);\n      throw new Error(`\"indent\" option must be a positive integer, not ${s}`);\n    }\n\n    this.setSchema();\n    const lines = [];\n    let hasDirectives = false;\n\n    if (this.version) {\n      let vd = '%YAML 1.2';\n\n      if (this.schema.name === 'yaml-1.1') {\n        if (this.version === '1.0') vd = '%YAML:1.0';else if (this.version === '1.1') vd = '%YAML 1.1';\n      }\n\n      lines.push(vd);\n      hasDirectives = true;\n    }\n\n    const tagNames = this.listNonDefaultTags();\n    this.tagPrefixes.forEach(({\n      handle,\n      prefix\n    }) => {\n      if (tagNames.some(t => t.indexOf(prefix) === 0)) {\n        lines.push(`%TAG ${handle} ${prefix}`);\n        hasDirectives = true;\n      }\n    });\n    if (hasDirectives || this.directivesEndMarker) lines.push('---');\n\n    if (this.commentBefore) {\n      if (hasDirectives || !this.directivesEndMarker) lines.unshift('');\n      lines.unshift(this.commentBefore.replace(/^/gm, '#'));\n    }\n\n    const ctx = {\n      anchors: Object.create(null),\n      doc: this,\n      indent: '',\n      indentStep: ' '.repeat(indentSize),\n      stringify // Requiring directly in nodes would create circular dependencies\n\n    };\n    let chompKeep = false;\n    let contentComment = null;\n\n    if (this.contents) {\n      if (this.contents instanceof resolveSeq.Node) {\n        if (this.contents.spaceBefore && (hasDirectives || this.directivesEndMarker)) lines.push('');\n        if (this.contents.commentBefore) lines.push(this.contents.commentBefore.replace(/^/gm, '#')); // top-level block scalars need to be indented if followed by a comment\n\n        ctx.forceBlockIndent = !!this.comment;\n        contentComment = this.contents.comment;\n      }\n\n      const onChompKeep = contentComment ? null : () => chompKeep = true;\n      const body = stringify(this.contents, ctx, () => contentComment = null, onChompKeep);\n      lines.push(resolveSeq.addComment(body, '', contentComment));\n    } else if (this.contents !== undefined) {\n      lines.push(stringify(this.contents, ctx));\n    }\n\n    if (this.comment) {\n      if ((!chompKeep || contentComment) && lines[lines.length - 1] !== '') lines.push('');\n      lines.push(this.comment.replace(/^/gm, '#'));\n    }\n\n    return lines.join('\\n') + '\\n';\n  }\n\n}\n\nPlainValue._defineProperty(Document, \"defaults\", documentOptions);\n\nexports.Document = Document;\nexports.defaultOptions = defaultOptions;\nexports.scalarOptions = scalarOptions;\n", "'use strict';\n\nvar parseCst = require('./parse-cst.js');\nvar Document$1 = require('./Document-9b4560a1.js');\nvar Schema = require('./Schema-88e323a7.js');\nvar PlainValue = require('./PlainValue-ec8e588e.js');\nvar warnings = require('./warnings-1000a372.js');\nrequire('./resolveSeq-d03cb037.js');\n\nfunction createNode(value, wrapScalars = true, tag) {\n  if (tag === undefined && typeof wrapScalars === 'string') {\n    tag = wrapScalars;\n    wrapScalars = true;\n  }\n\n  const options = Object.assign({}, Document$1.Document.defaults[Document$1.defaultOptions.version], Document$1.defaultOptions);\n  const schema = new Schema.Schema(options);\n  return schema.createNode(value, wrapScalars, tag);\n}\n\nclass Document extends Document$1.Document {\n  constructor(options) {\n    super(Object.assign({}, Document$1.defaultOptions, options));\n  }\n\n}\n\nfunction parseAllDocuments(src, options) {\n  const stream = [];\n  let prev;\n\n  for (const cstDoc of parseCst.parse(src)) {\n    const doc = new Document(options);\n    doc.parse(cstDoc, prev);\n    stream.push(doc);\n    prev = doc;\n  }\n\n  return stream;\n}\n\nfunction parseDocument(src, options) {\n  const cst = parseCst.parse(src);\n  const doc = new Document(options).parse(cst[0]);\n\n  if (cst.length > 1) {\n    const errMsg = 'Source contains multiple documents; please use YAML.parseAllDocuments()';\n    doc.errors.unshift(new PlainValue.YAMLSemanticError(cst[1], errMsg));\n  }\n\n  return doc;\n}\n\nfunction parse(src, options) {\n  const doc = parseDocument(src, options);\n  doc.warnings.forEach(warning => warnings.warn(warning));\n  if (doc.errors.length > 0) throw doc.errors[0];\n  return doc.toJSON();\n}\n\nfunction stringify(value, options) {\n  const doc = new Document(options);\n  doc.contents = value;\n  return String(doc);\n}\n\nconst YAML = {\n  createNode,\n  defaultOptions: Document$1.defaultOptions,\n  Document,\n  parse,\n  parseAllDocuments,\n  parseCST: parseCst.parse,\n  parseDocument,\n  scalarOptions: Document$1.scalarOptions,\n  stringify\n};\n\nexports.YAML = YAML;\n", "module.exports = require('./dist').YAML\n", "const yaml = require(\"yaml\");\n\n// see: https://eemeli.org/yaml/v1/#errors\nconst errors = new Set([\n  \"YAMLReferenceError\",\n  \"YAMLSemanticError\",\n  \"YAMLSyntaxError\",\n  \"YAMLWarning\",\n]);\n\nfunction parse(str) {\n  if (typeof str !== \"string\") {\n    return { ok: false, result: undefined };\n  }\n\n  const YAML_SILENCE_WARNINGS_CACHED = global.YAML_SILENCE_WARNINGS;\n  try {\n    // see: https://eemeli.org/yaml/v1/#silencing-warnings\n    global.YAML_SILENCE_WARNINGS = true;\n    return { ok: true, result: yaml.parse(str) };\n  } catch (err) {\n    // Ignore parser errors.\n    if (err && errors.has(err.name)) {\n      return { ok: false, result: undefined };\n    }\n    throw err;\n  } finally {\n    global.YAML_SILENCE_WARNINGS = YAML_SILENCE_WARNINGS_CACHED;\n  }\n}\n\nmodule.exports = {\n  // is_valid is expected to return nothing if input is invalid otherwise\n  // true/false for it being valid YAML.\n  \"yaml.is_valid\": (str) => typeof str === \"string\" ? parse(str).ok : undefined,\n  \"yaml.marshal\": (data) => yaml.stringify(data),\n  \"yaml.unmarshal\": (str) => parse(str).result,\n};\n", "const json = require(\"./json\");\nconst strings = require(\"./strings\");\nconst regex = require(\"./regex\");\nconst yaml = require(\"./yaml\");\n\nmodule.exports = {\n  ...json,\n  ...strings,\n  ...regex,\n  ...yaml,\n};\n", "// Copyright 2018 The OPA Authors.  All rights reserved.\n// Use of this source code is governed by an Apache2\n// license that can be found in the LICENSE file.\nconst builtIns = require(\"./builtins/index\");\n\n/**\n * @param {WebAssembly.Memory} mem\n */\nfunction stringDecoder(mem) {\n  return function (addr) {\n    const i8 = new Int8Array(mem.buffer);\n    let s = \"\";\n    while (i8[addr] !== 0) {\n      s += String.fromCharCode(i8[addr++]);\n    }\n    return s;\n  };\n}\n\n/**\n * Stringifies and loads an object into OPA's Memory\n * @param {WebAssembly.Instance} wasmInstance\n * @param {WebAssembly.Memory} memory\n * @param {any | ArrayBuffer} value data as `object`, literal primitive or ArrayBuffer (last is assumed to be a well-formed stringified JSON)\n * @returns {number}\n */\nfunction _loadJSON(wasmInstance, memory, value) {\n  if (value === undefined) {\n    return 0;\n  }\n\n  let valueBuf;\n  if (value instanceof ArrayBuffer) {\n    valueBuf = new Uint8Array(value);\n  } else {\n    const valueAsText = JSON.stringify(value);\n    valueBuf = new TextEncoder().encode(valueAsText);\n  }\n\n  const valueBufLen = valueBuf.byteLength;\n  const rawAddr = wasmInstance.exports.opa_malloc(valueBufLen);\n  const memoryBuffer = new Uint8Array(memory.buffer);\n  memoryBuffer.set(valueBuf, rawAddr);\n\n  const parsedAddr = wasmInstance.exports.opa_json_parse(rawAddr, valueBufLen);\n\n  if (parsedAddr === 0) {\n    throw \"failed to parse json value\";\n  }\n  return parsedAddr;\n}\n\n/**\n * Dumps and parses a JSON object from OPA's Memory\n * @param {WebAssembly.Instance} wasmInstance\n * @param {WebAssembly.Memory} memory\n * @param {number} addr\n * @returns {object}\n */\nfunction _dumpJSON(wasmInstance, memory, addr) {\n  const rawAddr = wasmInstance.exports.opa_json_dump(addr);\n  return _dumpJSONRaw(memory, rawAddr);\n}\n\n/**\n * Parses a JSON object from wasm instance's memory\n * @param {WebAssembly.Memory} memory\n * @param {number} addr\n * @returns {object}\n */\nfunction _dumpJSONRaw(memory, addr) {\n  const buf = new Uint8Array(memory.buffer);\n\n  let idx = addr;\n\n  while (buf[idx] !== 0) {\n    idx++;\n  }\n\n  const utf8View = new Uint8Array(memory.buffer, addr, idx - addr);\n  const jsonAsText = new TextDecoder().decode(utf8View);\n\n  return JSON.parse(jsonAsText);\n}\n\nconst builtinFuncs = builtIns;\n\n/**\n * _builtinCall dispatches the built-in function. The built-in function\n * arguments are loaded from Wasm and back in using JSON serialization.\n * @param {WebAssembly.Instance} wasmInstance\n * @param {WebAssembly.Memory} memory\n * @param {{ [builtinId: number]: string }} builtins\n * @param {{ [builtinName: string]: Function }} customBuiltins\n * @param {string} builtin_id\n */\nfunction _builtinCall(\n  wasmInstance,\n  memory,\n  builtins,\n  customBuiltins,\n  builtinId,\n) {\n  const builtInName = builtins[builtinId];\n  const impl = builtinFuncs[builtInName] || customBuiltins[builtInName];\n\n  if (impl === undefined) {\n    throw {\n      message: \"not implemented: built-in function \" +\n        builtinId +\n        \": \" +\n        builtins[builtinId],\n    };\n  }\n\n  const argArray = Array.prototype.slice.apply(arguments);\n  const args = [];\n\n  for (let i = 5; i < argArray.length; i++) {\n    const jsArg = _dumpJSON(wasmInstance, memory, argArray[i]);\n    args.push(jsArg);\n  }\n\n  const result = impl(...args);\n\n  return _loadJSON(wasmInstance, memory, result);\n}\n\n/**\n * _importObject builds the WebAssembly.Imports\n * @param {Object} env\n * @param {WebAssembly.Memory} memory\n * @param {{ [builtinName: string]: Function }} customBuiltins\n * @returns {WebAssembly.Imports}\n */\nfunction _importObject(env, memory, customBuiltins) {\n  const addr2string = stringDecoder(memory);\n\n  return {\n    env: {\n      memory,\n      opa_abort: function (addr) {\n        throw addr2string(addr);\n      },\n      opa_println: function (addr) {\n        console.log(addr2string(addr));\n      },\n      opa_builtin0: function (builtinId, _ctx) {\n        return _builtinCall(\n          env.instance,\n          memory,\n          env.builtins,\n          customBuiltins,\n          builtinId,\n        );\n      },\n      opa_builtin1: function (builtinId, _ctx, arg1) {\n        return _builtinCall(\n          env.instance,\n          memory,\n          env.builtins,\n          customBuiltins,\n          builtinId,\n          arg1,\n        );\n      },\n      opa_builtin2: function (builtinId, _ctx, arg1, arg2) {\n        return _builtinCall(\n          env.instance,\n          memory,\n          env.builtins,\n          customBuiltins,\n          builtinId,\n          arg1,\n          arg2,\n        );\n      },\n      opa_builtin3: function (builtinId, _ctx, arg1, arg2, arg3) {\n        return _builtinCall(\n          env.instance,\n          memory,\n          env.builtins,\n          customBuiltins,\n          builtinId,\n          arg1,\n          arg2,\n          arg3,\n        );\n      },\n      opa_builtin4: function (builtinId, _ctx, arg1, arg2, arg3, arg4) {\n        return _builtinCall(\n          env.instance,\n          memory,\n          env.builtins,\n          customBuiltins,\n          builtinId,\n          arg1,\n          arg2,\n          arg3,\n          arg4,\n        );\n      },\n    },\n  };\n}\n\n/**\n * _preparePolicy checks the ABI version and loads the built-in functions\n * @param {Object} env\n * @param {WebAssembly.WebAssemblyInstantiatedSource | WebAssembly.Instance} wasm\n * @param {WebAssembly.Memory} memory\n * @returns { policy: WebAssembly.WebAssemblyInstantiatedSource | WebAssembly.Instance, minorVersion: number }}\n */\nfunction _preparePolicy(env, wasm, memory) {\n  env.instance = wasm.instance ? wasm.instance : wasm;\n\n  // Note: On Node 10.x this value is a number on Node 12.x and up it is\n  // an object with numberic `value` property.\n  const abiVersionGlobal = env.instance.exports.opa_wasm_abi_version;\n  if (abiVersionGlobal !== undefined) {\n    const abiVersion = typeof abiVersionGlobal === \"number\"\n      ? abiVersionGlobal\n      : abiVersionGlobal.value;\n    if (abiVersion !== 1) {\n      throw `unsupported ABI version ${abiVersion}`;\n    }\n  } else {\n    console.error(\"opa_wasm_abi_version undefined\"); // logs to stderr\n  }\n\n  const abiMinorVersionGlobal = env.instance.exports.opa_wasm_abi_minor_version;\n  let abiMinorVersion;\n  if (abiMinorVersionGlobal !== undefined) {\n    abiMinorVersion = typeof abiMinorVersionGlobal === \"number\"\n      ? abiMinorVersionGlobal\n      : abiMinorVersionGlobal.value;\n  } else {\n    console.error(\"opa_wasm_abi_minor_version undefined\");\n  }\n\n  const builtins = _dumpJSON(\n    env.instance,\n    memory,\n    env.instance.exports.builtins(),\n  );\n\n  /** @type {typeof builtIns} */\n  env.builtins = {};\n\n  for (const key of Object.keys(builtins)) {\n    env.builtins[builtins[key]] = key;\n  }\n\n  return { policy: wasm, minorVersion: abiMinorVersion };\n}\n\n/**\n * _loadPolicy can take in either an ArrayBuffer or WebAssembly.Module\n * as its first argument, a WebAssembly.Memory for the second parameter,\n * and an object mapping string names to additional builtin functions for\n * the third parameter.\n * It will return a Promise, depending on the input type the promise\n * resolves to both a compiled WebAssembly.Module and its first WebAssembly.Instance\n * or to the WebAssemblyInstance.\n * @param {BufferSource | WebAssembly.Module} policyWasm\n * @param {WebAssembly.Memory} memory\n * @param {{ [builtinName: string]: Function }} customBuiltins\n * @returns {Promise<{ policy: WebAssembly.WebAssemblyInstantiatedSource | WebAssembly.Instance, minorVersion: number }>}\n */\nasync function _loadPolicy(policyWasm, memory, customBuiltins) {\n  const env = {};\n\n  const wasm = await WebAssembly.instantiate(\n    policyWasm,\n    _importObject(env, memory, customBuiltins),\n  );\n\n  return _preparePolicy(env, wasm, memory);\n}\n\n/**\n * _loadPolicySync can take in either an ArrayBuffer or WebAssembly.Module\n * as its first argument, a WebAssembly.Memory for the second parameter,\n * and an object mapping string names to additional builtin functions for\n * the third parameter.\n * It will return a compiled WebAssembly.Module and its first WebAssembly.Instance.\n * @param {BufferSource | WebAssembly.Module} policyWasm\n * @param {WebAssembly.Memory} memory\n * @param {{ [builtinName: string]: Function }} customBuiltins\n * @returns {Promise<{ policy: WebAssembly.Instance, minorVersion: number }>}\n */\nfunction _loadPolicySync(policyWasm, memory, customBuiltins) {\n  const env = {};\n\n  if (\n    policyWasm instanceof ArrayBuffer ||\n    policyWasm.buffer instanceof ArrayBuffer\n  ) {\n    policyWasm = new WebAssembly.Module(policyWasm);\n  }\n\n  const wasm = new WebAssembly.Instance(\n    policyWasm,\n    _importObject(env, memory, customBuiltins),\n  );\n\n  return _preparePolicy(env, wasm, memory);\n}\n\n/**\n * LoadedPolicy is a wrapper around a WebAssembly.Instance and WebAssembly.Memory\n * for a compiled Rego policy. There are helpers to run the wasm instance and\n * handle the output from the policy wasm.\n */\nclass LoadedPolicy {\n  /**\n   * Loads and initializes a compiled Rego policy.\n   * @param {WebAssembly.WebAssemblyInstantiatedSource} policy\n   * @param {WebAssembly.Memory} memory\n   */\n  constructor(policy, memory, minorVersion) {\n    this.minorVersion = minorVersion;\n    this.mem = memory;\n\n    // Depending on how the wasm was instantiated \"policy\" might be a\n    // WebAssembly Instance or be a wrapper around the Module and\n    // Instance. We only care about the Instance.\n    this.wasmInstance = policy.instance ? policy.instance : policy;\n\n    this.dataAddr = _loadJSON(this.wasmInstance, this.mem, {});\n    this.baseHeapPtr = this.wasmInstance.exports.opa_heap_ptr_get();\n    this.dataHeapPtr = this.baseHeapPtr;\n    this.entrypoints = _dumpJSON(\n      this.wasmInstance,\n      this.mem,\n      this.wasmInstance.exports.entrypoints(),\n    );\n  }\n\n  /**\n   * Evaluates the loaded policy with the given input and\n   * return the result set. This should be re-used for multiple evaluations\n   * of the same policy with different inputs.\n   *\n   * To call a non-default entrypoint in your WASM specify it as the second\n   * param. A list of entrypoints can be accessed with the `this.entrypoints`\n   * property.\n   * @param {any | ArrayBuffer} input input to be evaluated in form of `object`, literal primitive or ArrayBuffer (last is assumed to be a well-formed stringified JSON)\n   * @param {number | string} entrypoint ID or name of the entrypoint to call (optional)\n   */\n  evaluate(input, entrypoint = 0) {\n    // determine entrypoint ID\n    if (typeof entrypoint === \"number\") {\n      // used as-is\n    } else if (typeof entrypoint === \"string\") {\n      if (Object.prototype.hasOwnProperty.call(this.entrypoints, entrypoint)) {\n        entrypoint = this.entrypoints[entrypoint];\n      } else {\n        throw `entrypoint ${entrypoint} is not valid in this instance`;\n      }\n    } else {\n      throw `entrypoint value is an invalid type, must be either string or number`;\n    }\n\n    // ABI 1.2 fastpath\n    if (this.minorVersion >= 2) {\n      // write input into memory, adjust heap pointer\n      let inputBuf = null;\n      let inputLen = 0;\n      let inputAddr = 0;\n      if (input) {\n        if (input instanceof ArrayBuffer) {\n          inputBuf = new Uint8Array(input);\n        } else {\n          const inputAsText = JSON.stringify(input);\n          inputBuf = new TextEncoder().encode(inputAsText);\n        }\n\n        inputAddr = this.dataHeapPtr;\n        inputLen = inputBuf.byteLength;\n        const delta = inputAddr + inputLen - this.mem.buffer.byteLength;\n        if (delta > 0) {\n          const pages = roundup(delta);\n          this.mem.grow(pages);\n        }\n        const buf = new Uint8Array(this.mem.buffer);\n        buf.set(inputBuf, this.dataHeapPtr);\n      }\n\n      // opa_eval will update the Instance heap pointer to the value below\n      const heapPtr = this.dataHeapPtr + inputLen;\n\n      const ret = this.wasmInstance.exports.opa_eval(\n        0,\n        entrypoint,\n        this.dataAddr,\n        inputAddr,\n        inputLen,\n        heapPtr,\n        0,\n      );\n      return _dumpJSONRaw(this.mem, ret);\n    }\n\n    // Reset the heap pointer before each evaluation\n    this.wasmInstance.exports.opa_heap_ptr_set(this.dataHeapPtr);\n\n    // Load the input data\n    const inputAddr = _loadJSON(this.wasmInstance, this.mem, input);\n\n    // Setup the evaluation context\n    const ctxAddr = this.wasmInstance.exports.opa_eval_ctx_new();\n    this.wasmInstance.exports.opa_eval_ctx_set_input(ctxAddr, inputAddr);\n    this.wasmInstance.exports.opa_eval_ctx_set_data(ctxAddr, this.dataAddr);\n    this.wasmInstance.exports.opa_eval_ctx_set_entrypoint(ctxAddr, entrypoint);\n\n    // Actually evaluate the policy\n    this.wasmInstance.exports.eval(ctxAddr);\n\n    // Retrieve the result\n    const resultAddr = this.wasmInstance.exports.opa_eval_ctx_get_result(\n      ctxAddr,\n    );\n    return _dumpJSON(this.wasmInstance, this.mem, resultAddr);\n  }\n\n  /**\n   * evalBool will evaluate the policy and return a boolean answer\n   * depending on the return code from the policy evaluation.\n   * @deprecated Use `evaluate` instead.\n   * @param {object} input\n   */\n  evalBool(input) {\n    const rs = this.evaluate(input);\n    return rs && rs.length === 1 && rs[0] === true;\n  }\n\n  /**\n   * Loads data for use in subsequent evaluations.\n   * @param {object | ArrayBuffer} data  data in form of `object` or ArrayBuffer (last is assumed to be a well-formed stringified JSON)\n   */\n  setData(data) {\n    this.wasmInstance.exports.opa_heap_ptr_set(this.baseHeapPtr);\n    this.dataAddr = _loadJSON(this.wasmInstance, this.mem, data);\n    this.dataHeapPtr = this.wasmInstance.exports.opa_heap_ptr_get();\n  }\n}\n\nfunction roundup(bytes) {\n  const pageSize = 64 * 1024;\n  return Math.ceil(bytes / pageSize);\n}\n\nmodule.exports = {\n  /**\n   * Takes in either an ArrayBuffer or WebAssembly.Module\n   * and will return a Promise of a LoadedPolicy object which\n   * can be used to evaluate the policy.\n   *\n   * To set custom memory size specify number of memory pages\n   * as second param.\n   * Defaults to 5 pages (320KB).\n   * @param {BufferSource | WebAssembly.Module} regoWasm\n   * @param {number | WebAssembly.MemoryDescriptor} memoryDescriptor For backwards-compatibility, a 'number' argument is taken to be the initial memory size.\n   * @param {{ [builtinName: string]: Function }} customBuiltins A map from string names to builtin functions\n   * @returns {Promise<LoadedPolicy>}\n   */\n  async loadPolicy(regoWasm, memoryDescriptor = {}, customBuiltins = {}) {\n    // back-compat, second arg used to be a number: 'memorySize', with default of 5\n    if (typeof memoryDescriptor === \"number\") {\n      memoryDescriptor = { initial: memoryDescriptor };\n    }\n    memoryDescriptor.initial = memoryDescriptor.initial || 5;\n\n    const memory = new WebAssembly.Memory(memoryDescriptor);\n    const { policy, minorVersion } = await _loadPolicy(\n      regoWasm,\n      memory,\n      customBuiltins,\n    );\n    return new LoadedPolicy(policy, memory, minorVersion);\n  },\n\n  /**\n   * Takes in either an ArrayBuffer or WebAssembly.Module\n   * and will return a LoadedPolicy object which can be\n   * used to evaluate the policy.\n   *\n   * This cannot be used from the main thread in a browser.\n   * You must use the `loadPolicy` function instead, or call\n   * from a worker thread.\n   *\n   * To set custom memory size specify number of memory pages\n   * as second param.\n   * Defaults to 5 pages (320KB).\n   * @param {BufferSource | WebAssembly.Module} regoWasm\n   * @param {number | WebAssembly.MemoryDescriptor} memoryDescriptor For backwards-compatibility, a 'number' argument is taken to be the initial memory size.\n   * @param {{ [builtinName: string]: Function }} customBuiltins A map from string names to builtin functions\n   * @returns {LoadedPolicy}\n   */\n  loadPolicySync(regoWasm, memoryDescriptor = {}, customBuiltins = {}) {\n    // back-compat, second arg used to be a number: 'memorySize', with default of 5\n    if (typeof memoryDescriptor === \"number\") {\n      memoryDescriptor = { initial: memoryDescriptor };\n    }\n    memoryDescriptor.initial = memoryDescriptor.initial || 5;\n\n    const memory = new WebAssembly.Memory(memoryDescriptor);\n    const { policy, minorVersion } = _loadPolicySync(\n      regoWasm,\n      memory,\n      customBuiltins,\n    );\n    return new LoadedPolicy(policy, memory, minorVersion);\n  },\n};\n"],
  "mappings": "8DAAA,IAAAA,GAAAC,EAAA,CAAAC,GAAAC,KAAA,UAASC,GAAYC,EAAK,CACxB,GAAI,OAAOA,GAAQ,SAGnB,GAAI,CACF,YAAK,MAAMA,CAAG,EACP,EACT,OAASC,EAAP,CACA,GAAIA,aAAe,YACjB,MAAO,GAET,MAAMA,CACR,CACF,CAEAH,GAAO,QAAU,CACf,gBAAiBC,EACnB,ICjBA,IAAAG,GAAAC,EAAAC,IAAA,EAEC,UAAW,CACR,aAEA,IAAIC,EAAK,CACL,WAAY,OACZ,SAAU,OACV,SAAU,OACV,cAAe,OACf,OAAQ,UACR,YAAa,eACb,KAAM,MACN,SAAU,OACV,KAAM,YACN,OAAQ,WACR,YAAa,2FACb,IAAK,sBACL,WAAY,wBACZ,aAAc,aACd,KAAM,OACV,EAEA,SAASC,EAAQC,EAAK,CAElB,OAAOC,EAAeC,EAAcF,CAAG,EAAG,SAAS,CACvD,CAEA,SAASG,EAASC,EAAKC,EAAM,CACzB,OAAON,EAAQ,MAAM,KAAM,CAACK,CAAG,EAAE,OAAOC,GAAQ,CAAC,CAAC,CAAC,CACvD,CAEA,SAASJ,EAAeK,EAAYD,EAAM,CACtC,IAAIE,EAAS,EAAGC,EAAcF,EAAW,OAAQG,EAAKC,EAAS,GAAIC,EAAGC,EAAGC,EAAIC,EAAKC,EAAeC,EAAYC,EAAaC,EAC1H,IAAKP,EAAI,EAAGA,EAAIH,EAAaG,IACzB,GAAI,OAAOL,EAAWK,IAAO,SACzBD,GAAUJ,EAAWK,WAEhB,OAAOL,EAAWK,IAAO,SAAU,CAExC,GADAE,EAAKP,EAAWK,GACZE,EAAG,KAEH,IADAJ,EAAMJ,EAAKE,GACNK,EAAI,EAAGA,EAAIC,EAAG,KAAK,OAAQD,IAAK,CACjC,GAAIH,GAAO,KACP,MAAM,IAAI,MAAMV,EAAQ,gEAAiEc,EAAG,KAAKD,GAAIC,EAAG,KAAKD,EAAE,EAAE,CAAC,EAEtHH,EAAMA,EAAII,EAAG,KAAKD,GACtB,MAEKC,EAAG,SACRJ,EAAMJ,EAAKQ,EAAG,UAGdJ,EAAMJ,EAAKE,KAOf,GAJIT,EAAG,SAAS,KAAKe,EAAG,IAAI,GAAKf,EAAG,cAAc,KAAKe,EAAG,IAAI,GAAKJ,aAAe,WAC9EA,EAAMA,EAAI,GAGVX,EAAG,YAAY,KAAKe,EAAG,IAAI,GAAM,OAAOJ,GAAQ,UAAY,MAAMA,CAAG,EACrE,MAAM,IAAI,UAAUV,EAAQ,0CAA2CU,CAAG,CAAC,EAO/E,OAJIX,EAAG,OAAO,KAAKe,EAAG,IAAI,IACtBI,EAAcR,GAAO,GAGjBI,EAAG,UACF,IACDJ,EAAM,SAASA,EAAK,EAAE,EAAE,SAAS,CAAC,EAClC,UACC,IACDA,EAAM,OAAO,aAAa,SAASA,EAAK,EAAE,CAAC,EAC3C,UACC,QACA,IACDA,EAAM,SAASA,EAAK,EAAE,EACtB,UACC,IACDA,EAAM,KAAK,UAAUA,EAAK,KAAMI,EAAG,MAAQ,SAASA,EAAG,KAAK,EAAI,CAAC,EACjE,UACC,IACDJ,EAAMI,EAAG,UAAY,WAAWJ,CAAG,EAAE,cAAcI,EAAG,SAAS,EAAI,WAAWJ,CAAG,EAAE,cAAc,EACjG,UACC,IACDA,EAAMI,EAAG,UAAY,WAAWJ,CAAG,EAAE,QAAQI,EAAG,SAAS,EAAI,WAAWJ,CAAG,EAC3E,UACC,IACDA,EAAMI,EAAG,UAAY,OAAO,OAAOJ,EAAI,YAAYI,EAAG,SAAS,CAAC,CAAC,EAAI,WAAWJ,CAAG,EACnF,UACC,IACDA,GAAO,SAASA,EAAK,EAAE,IAAM,GAAG,SAAS,CAAC,EAC1C,UACC,IACDA,EAAM,OAAOA,CAAG,EAChBA,EAAOI,EAAG,UAAYJ,EAAI,UAAU,EAAGI,EAAG,SAAS,EAAIJ,EACvD,UACC,IACDA,EAAM,OAAO,CAAC,CAACA,CAAG,EAClBA,EAAOI,EAAG,UAAYJ,EAAI,UAAU,EAAGI,EAAG,SAAS,EAAIJ,EACvD,UACC,IACDA,EAAM,OAAO,UAAU,SAAS,KAAKA,CAAG,EAAE,MAAM,EAAG,EAAE,EAAE,YAAY,EACnEA,EAAOI,EAAG,UAAYJ,EAAI,UAAU,EAAGI,EAAG,SAAS,EAAIJ,EACvD,UACC,IACDA,EAAM,SAASA,EAAK,EAAE,IAAM,EAC5B,UACC,IACDA,EAAMA,EAAI,QAAQ,EAClBA,EAAOI,EAAG,UAAYJ,EAAI,UAAU,EAAGI,EAAG,SAAS,EAAIJ,EACvD,UACC,IACDA,GAAO,SAASA,EAAK,EAAE,IAAM,GAAG,SAAS,EAAE,EAC3C,UACC,IACDA,GAAO,SAASA,EAAK,EAAE,IAAM,GAAG,SAAS,EAAE,EAAE,YAAY,EACzD,MAEJX,EAAG,KAAK,KAAKe,EAAG,IAAI,EACpBH,GAAUD,GAGNX,EAAG,OAAO,KAAKe,EAAG,IAAI,IAAM,CAACI,GAAeJ,EAAG,OAC/CK,EAAOD,EAAc,IAAM,IAC3BR,EAAMA,EAAI,SAAS,EAAE,QAAQX,EAAG,KAAM,EAAE,GAGxCoB,EAAO,GAEXH,EAAgBF,EAAG,SAAWA,EAAG,WAAa,IAAM,IAAMA,EAAG,SAAS,OAAO,CAAC,EAAI,IAClFG,EAAaH,EAAG,OAASK,EAAOT,GAAK,OACrCK,EAAMD,EAAG,OAASG,EAAa,EAAID,EAAc,OAAOC,CAAU,EAAU,GAC5EN,GAAUG,EAAG,MAAQK,EAAOT,EAAMK,EAAOC,IAAkB,IAAMG,EAAOJ,EAAML,EAAMK,EAAMI,EAAOT,EAEzG,CAEJ,OAAOC,CACX,CAEA,IAAIS,EAAgB,OAAO,OAAO,IAAI,EAEtC,SAASjB,EAAcE,EAAK,CACxB,GAAIe,EAAcf,GACd,OAAOe,EAAcf,GAIzB,QADIgB,EAAOhB,EAAKiB,EAAOf,EAAa,CAAC,EAAGgB,EAAY,EAC7CF,GAAM,CACT,IAAKC,EAAQvB,EAAG,KAAK,KAAKsB,CAAI,KAAO,KACjCd,EAAW,KAAKe,EAAM,EAAE,WAElBA,EAAQvB,EAAG,OAAO,KAAKsB,CAAI,KAAO,KACxCd,EAAW,KAAK,GAAG,WAEbe,EAAQvB,EAAG,YAAY,KAAKsB,CAAI,KAAO,KAAM,CACnD,GAAIC,EAAM,GAAI,CACVC,GAAa,EACb,IAAIC,EAAa,CAAC,EAAGC,EAAoBH,EAAM,GAAII,EAAc,CAAC,EAClE,IAAKA,EAAc3B,EAAG,IAAI,KAAK0B,CAAiB,KAAO,KAEnD,IADAD,EAAW,KAAKE,EAAY,EAAE,GACtBD,EAAoBA,EAAkB,UAAUC,EAAY,GAAG,MAAM,KAAO,IAChF,IAAKA,EAAc3B,EAAG,WAAW,KAAK0B,CAAiB,KAAO,KAC1DD,EAAW,KAAKE,EAAY,EAAE,WAExBA,EAAc3B,EAAG,aAAa,KAAK0B,CAAiB,KAAO,KACjED,EAAW,KAAKE,EAAY,EAAE,MAG9B,OAAM,IAAI,YAAY,8CAA8C,MAK5E,OAAM,IAAI,YAAY,8CAA8C,EAExEJ,EAAM,GAAKE,CACf,MAEID,GAAa,EAEjB,GAAIA,IAAc,EACd,MAAM,IAAI,MAAM,2EAA2E,EAG/FhB,EAAW,KACP,CACI,YAAae,EAAM,GACnB,SAAaA,EAAM,GACnB,KAAaA,EAAM,GACnB,KAAaA,EAAM,GACnB,SAAaA,EAAM,GACnB,MAAaA,EAAM,GACnB,MAAaA,EAAM,GACnB,UAAaA,EAAM,GACnB,KAAaA,EAAM,EACvB,CACJ,CACJ,KAEI,OAAM,IAAI,YAAY,kCAAkC,EAE5DD,EAAOA,EAAK,UAAUC,EAAM,GAAG,MAAM,CACzC,CACA,OAAOF,EAAcf,GAAOE,CAChC,CAMI,OAAOT,GAAY,MACnBA,GAAQ,QAAaE,EACrBF,GAAQ,SAAcM,GAEtB,OAAO,OAAW,MAClB,OAAO,QAAaJ,EACpB,OAAO,SAAcI,EAEjB,OAAO,QAAW,YAAc,OAAO,KACvC,OAAO,UAAW,CACd,MAAO,CACH,QAAWJ,EACX,SAAYI,CAChB,CACJ,CAAC,EAIb,GAAE,ICtOF,IAAAuB,GAAAC,EAAA,CAAAC,GAAAC,KAAA,KAAMC,GAAW,KAAsB,SAEjCC,GAAU,CAACC,EAAGC,IAAWH,GAASE,EAAGC,CAAM,EAEjDJ,GAAO,QAAU,CAAE,QAAAE,EAAQ,ICJ3B,IAAAG,GAAAC,EAAA,CAAAC,GAAAC,KAAA,KAAMC,GAAa,CAACC,EAASC,IAAMA,EAAE,MAAM,OAAOD,CAAO,CAAC,EAE1DF,GAAO,QAAU,CAAE,cAAeC,EAAW,ICF7C,IAAAG,EAAAC,EAAAC,GAAA,cAEA,IAAMC,EAAO,CACX,OAAQ,IACR,QAAS,IACT,IAAK,IACL,eAAgB,IAChB,aAAc,GAChB,EACMC,GAAO,CACX,MAAO,QACP,WAAY,aACZ,aAAc,eACd,cAAe,gBACf,QAAS,UACT,UAAW,YACX,SAAU,WACV,SAAU,WACV,SAAU,WACV,IAAK,MACL,QAAS,UACT,UAAW,YACX,MAAO,QACP,aAAc,eACd,aAAc,eACd,IAAK,MACL,SAAU,UACZ,EACMC,GAAmB,qBACnBC,GAAc,CAClB,IAAK,wBACL,IAAK,wBACL,IAAK,uBACP,EAEA,SAASC,GAAeC,EAAK,CAC3B,IAAMC,EAAK,CAAC,CAAC,EACTC,EAASF,EAAI,QAAQ;AAAA,CAAI,EAE7B,KAAOE,IAAW,IAChBA,GAAU,EACVD,EAAG,KAAKC,CAAM,EACdA,EAASF,EAAI,QAAQ;AAAA,EAAME,CAAM,EAGnC,OAAOD,CACT,CAEA,SAASE,GAAWC,EAAK,CACvB,IAAIC,EAAYL,EAEhB,OAAI,OAAOI,GAAQ,UACjBC,EAAaN,GAAeK,CAAG,EAC/BJ,EAAMI,IAEF,MAAM,QAAQA,CAAG,IAAGA,EAAMA,EAAI,IAE9BA,GAAOA,EAAI,UACRA,EAAI,aAAYA,EAAI,WAAaL,GAAeK,EAAI,QAAQ,GAAG,GACpEC,EAAaD,EAAI,WACjBJ,EAAMI,EAAI,QAAQ,MAIf,CACL,WAAAC,EACA,IAAAL,CACF,CACF,CAuBA,SAASM,GAAWJ,EAAQE,EAAK,CAC/B,GAAI,OAAOF,GAAW,UAAYA,EAAS,EAAG,OAAO,KACrD,GAAM,CACJ,WAAAG,EACA,IAAAL,CACF,EAAIG,GAAWC,CAAG,EAClB,GAAI,CAACC,GAAc,CAACL,GAAOE,EAASF,EAAI,OAAQ,OAAO,KAEvD,QAAS,EAAI,EAAG,EAAIK,EAAW,OAAQ,EAAE,EAAG,CAC1C,IAAME,EAAQF,EAAW,GAEzB,GAAIH,EAASK,EACX,MAAO,CACL,KAAM,EACN,IAAKL,EAASG,EAAW,EAAI,GAAK,CACpC,EAGF,GAAIH,IAAWK,EAAO,MAAO,CAC3B,KAAM,EAAI,EACV,IAAK,CACP,CACF,CAEA,IAAMC,EAAOH,EAAW,OACxB,MAAO,CACL,KAAAG,EACA,IAAKN,EAASG,EAAWG,EAAO,GAAK,CACvC,CACF,CAeA,SAASC,GAAQD,EAAMJ,EAAK,CAC1B,GAAM,CACJ,WAAAC,EACA,IAAAL,CACF,EAAIG,GAAWC,CAAG,EAClB,GAAI,CAACC,GAAc,EAAEG,GAAQ,IAAMA,EAAOH,EAAW,OAAQ,OAAO,KACpE,IAAME,EAAQF,EAAWG,EAAO,GAC5BE,EAAML,EAAWG,GAErB,KAAOE,GAAOA,EAAMH,GAASP,EAAIU,EAAM,KAAO;AAAA,GAAM,EAAEA,EAEtD,OAAOV,EAAI,MAAMO,EAAOG,CAAG,CAC7B,CAkBA,SAASC,GAAiB,CACxB,MAAAJ,EACA,IAAAG,CACF,EAAGN,EAAKQ,EAAW,GAAI,CACrB,IAAIZ,EAAMS,GAAQF,EAAM,KAAMH,CAAG,EACjC,GAAI,CAACJ,EAAK,OAAO,KACjB,GAAI,CACF,IAAAa,CACF,EAAIN,EAEJ,GAAIP,EAAI,OAASY,EACf,GAAIC,GAAOD,EAAW,GACpBZ,EAAMA,EAAI,OAAO,EAAGY,EAAW,CAAC,EAAI,aAC/B,CACL,IAAME,EAAY,KAAK,MAAMF,EAAW,CAAC,EACrCZ,EAAI,OAASa,EAAMC,IAAWd,EAAMA,EAAI,OAAO,EAAGa,EAAMC,EAAY,CAAC,EAAI,UAC7ED,GAAOb,EAAI,OAASY,EACpBZ,EAAM,SAAMA,EAAI,OAAO,EAAIY,CAAQ,CACrC,CAGF,IAAIG,EAAS,EACTC,EAAS,GAETN,IACEA,EAAI,OAASH,EAAM,MAAQM,GAAOH,EAAI,IAAMH,EAAM,MAAQK,EAAW,EACvEG,EAASL,EAAI,IAAMH,EAAM,KAEzBQ,EAAS,KAAK,IAAIf,EAAI,OAAS,EAAGY,CAAQ,EAAIC,EAC9CG,EAAS,WAIb,IAAMd,EAASW,EAAM,EAAI,IAAI,OAAOA,EAAM,CAAC,EAAI,GACzCI,EAAM,IAAI,OAAOF,CAAM,EAC7B,MAAO,GAAGf;AAAA,EAAQE,IAASe,IAAMD,GACnC,CAEA,IAAME,EAAN,KAAY,CACV,OAAO,KAAKC,EAAM,CAChB,OAAO,IAAID,EAAMC,EAAK,MAAOA,EAAK,GAAG,CACvC,CAEA,YAAYZ,EAAOG,EAAK,CACtB,KAAK,MAAQH,EACb,KAAK,IAAMG,GAAOH,CACpB,CAEA,SAAU,CACR,OAAO,OAAO,KAAK,OAAU,UAAY,CAAC,KAAK,KAAO,KAAK,KAAO,KAAK,KACzE,CAWA,aAAaa,EAAIlB,EAAQ,CACvB,GAAM,CACJ,MAAAK,EACA,IAAAG,CACF,EAAI,KAEJ,GAAIU,EAAG,SAAW,GAAKV,GAAOU,EAAG,GAC/B,YAAK,UAAYb,EACjB,KAAK,QAAUG,EACRR,EAGT,IAAI,EAAIA,EAER,KAAO,EAAIkB,EAAG,QACR,EAAAA,EAAG,GAAKb,IAAkB,EAAE,EAGlC,KAAK,UAAYA,EAAQ,EACzB,IAAMc,EAAa,EAEnB,KAAO,EAAID,EAAG,QAER,EAAAA,EAAG,IAAMV,IAAgB,EAAE,EAGjC,YAAK,QAAUA,EAAM,EACdW,CACT,CAEF,EAIMC,EAAN,KAAW,CACT,OAAO,oBAAoBtB,EAAKE,EAAQqB,EAAK,CAC3C,GAAIA,EAAIA,EAAI,OAAS,KAAO;AAAA,EAAM,OAAOA,EACzC,IAAMC,EAAOF,EAAK,gBAAgBtB,EAAKE,CAAM,EAC7C,OAAOsB,GAAQxB,EAAI,QAAUA,EAAIwB,KAAU;AAAA,EAAOD,EAAM;AAAA,EAAOA,CACjE,CAGA,OAAO,mBAAmBvB,EAAKE,EAAQuB,EAAK,CAC1C,IAAMC,EAAM1B,EAAIE,GAChB,GAAI,CAACwB,EAAK,MAAO,GACjB,IAAMC,EAAO3B,EAAIE,EAAS,GAC1B,GAAIyB,GAAQA,IAAS;AAAA,EAAM,MAAO,GAElC,GAAIF,GACF,GAAIC,IAAQD,EAAK,MAAO,WAEpBC,IAAQ/B,EAAK,gBAAkB+B,IAAQ/B,EAAK,aAAc,MAAO,GAGvE,IAAMiC,EAAM5B,EAAIE,EAAS,GACnB2B,EAAM7B,EAAIE,EAAS,GACzB,GAAI0B,IAAQF,GAAOG,IAAQH,EAAK,MAAO,GACvC,IAAMI,EAAM9B,EAAIE,EAAS,GACzB,MAAO,CAAC4B,GAAOA,IAAQ;AAAA,GAAQA,IAAQ,KAAQA,IAAQ,GACzD,CAEA,OAAO,gBAAgB9B,EAAKE,EAAQ,CAClC,IAAI6B,EAAK/B,EAAIE,GACP8B,EAAaD,IAAO,IACpBE,EAAQD,EAAa,CAAC;AAAA,EAAM,IAAM,IAAK,GAAG,EAAI,CAAC;AAAA,EAAM,IAAM,IAAK,IAAK,IAAK,IAAK,IAAK,GAAG,EAE7F,KAAOD,GAAME,EAAM,QAAQF,CAAE,IAAM,IAAIA,EAAK/B,EAAIE,GAAU,GAE1D,OAAI8B,GAAcD,IAAO,MAAK7B,GAAU,GACjCA,CACT,CAEA,OAAO,YAAYF,EAAKE,EAAQ,CAC9B,IAAI6B,EAAK/B,EAAIE,GAEb,KAAO6B,IAAO,KAAKA,EAAK/B,EAAIE,GAAU,GAEtC,OAAOA,CACT,CAEA,OAAO,UAAUF,EAAKE,EAAQ,CAC5B,IAAI6B,EAAK/B,EAAIE,GAEb,KAAO6B,GAAMA,IAAO;AAAA,GAAMA,EAAK/B,EAAIE,GAAU,GAE7C,OAAOA,CACT,CAEA,OAAO,gBAAgBF,EAAKE,EAAQ,CAClC,IAAI6B,EAAK/B,EAAIE,GAEb,KAAO6B,IAAO,KAAQA,IAAO,KAAKA,EAAK/B,EAAIE,GAAU,GAErD,OAAOA,CACT,CAEA,OAAO,YAAYF,EAAKE,EAAQ,CAC9B,IAAI6B,EAAK/B,EAAIE,EAAS,GACtB,GAAI6B,IAAO;AAAA,EAAM,OAAO7B,EAExB,KAAO6B,GAAMA,IAAO;AAAA,GAAMA,EAAK/B,EAAIE,GAAU,GAE7C,OAAOA,EAAS,CAClB,CAYA,OAAO,iBAAiBF,EAAKkC,EAAQC,EAAW,CAC9C,IAAMC,EAAQd,EAAK,YAAYtB,EAAKmC,CAAS,EAE7C,GAAIC,EAAQD,EAAYD,EACtB,OAAOE,EACF,CACL,IAAMC,EAAQf,EAAK,gBAAgBtB,EAAKoC,CAAK,EACvCL,EAAK/B,EAAIqC,GACf,GAAI,CAACN,GAAMA,IAAO;AAAA,EAAM,OAAOM,CACjC,CAEA,OAAO,IACT,CAEA,OAAO,QAAQrC,EAAKE,EAAQoC,EAAY,CACtC,IAAMP,EAAK/B,EAAIE,GACf,OAAO6B,IAAO;AAAA,GAAQA,IAAO,KAAQA,IAAO,KAAOO,GAAc,CAACP,CACpE,CAEA,OAAO,mBAAmBA,EAAIQ,EAAYC,EAAmB,CAC3D,MAAI,CAACT,GAAMQ,EAAa,EAAU,GAC9BA,EAAa,EAAU,GACpBC,GAAqBT,IAAO,GACrC,CAGA,OAAO,gBAAgB/B,EAAKE,EAAQ,CAClC,IAAM6B,EAAK/B,EAAIE,GACf,OAAQ6B,EAAcA,IAAO;AAAA,GAAQ/B,EAAIE,EAAS,KAAO;AAAA,EAAOA,EAAS,EAAIoB,EAAK,gBAAgBtB,EAAKE,CAAM,EAAhGA,CACf,CAIA,OAAO,YAAYF,EAAKE,EAAQgC,EAAQ,CACtC,IAAIO,EAAU,EACVC,EAAQ,GACRC,EAAO,GACPZ,EAAK/B,EAAIE,EAAS,GAEtB,KAAO6B,IAAO,KAAOA,IAAO,KAAQA,IAAO;AAAA,GAAM,CAC/C,OAAQA,OACD;AAAA,EACHU,EAAU,EACVvC,GAAU,EACVyC,GAAQ;AAAA,EACR,UAEG,IACCF,GAAWP,IAAQQ,EAAQ,IAC/BxC,EAASoB,EAAK,gBAAgBtB,EAAKE,EAAS,CAAC,EAAI,EACjD,UAEG,IACHuC,GAAW,EACXvC,GAAU,EACV,MAGJ6B,EAAK/B,EAAIE,EAAS,EACpB,CAEA,OAAKyC,IAAMA,EAAO,KACdZ,GAAMU,GAAWP,IAAQQ,EAAQ,IAC9B,CACL,KAAAC,EACA,OAAAzC,EACA,MAAAwC,CACF,CACF,CAEA,YAAYE,EAAMC,EAAOC,EAAS,CAChC,OAAO,eAAe,KAAM,UAAW,CACrC,MAAOA,GAAW,KAClB,SAAU,EACZ,CAAC,EACD,KAAK,MAAQ,KACb,KAAK,MAAQ,KACb,KAAK,WAAa,KAClB,KAAK,MAAQD,GAAS,CAAC,EACvB,KAAK,KAAOD,EACZ,KAAK,MAAQ,IACf,CAEA,aAAaG,EAAKC,EAAKC,EAAS,CAC9B,GAAI,CAAC,KAAK,QAAS,OAAO,KAC1B,GAAM,CACJ,IAAAjD,CACF,EAAI,KAAK,QACHkD,EAAO,KAAK,MAAMH,GACxB,OAAOG,GAAQlD,EAAIkD,EAAK,SAAWF,EAAMhD,EAAI,MAAMkD,EAAK,OAASD,EAAU,EAAI,GAAIC,EAAK,GAAG,EAAI,IACjG,CAEA,IAAI,QAAS,CACX,QAASC,EAAI,EAAGA,EAAI,KAAK,MAAM,OAAQ,EAAEA,EAAG,CAC1C,IAAMC,EAAS,KAAK,aAAaD,EAAGxD,EAAK,OAAQ,EAAI,EACrD,GAAIyD,GAAU,KAAM,OAAOA,CAC7B,CAEA,OAAO,IACT,CAEA,IAAI,SAAU,CACZ,IAAMC,EAAW,CAAC,EAElB,QAASF,EAAI,EAAGA,EAAI,KAAK,MAAM,OAAQ,EAAEA,EAAG,CAC1C,IAAMG,EAAU,KAAK,aAAaH,EAAGxD,EAAK,QAAS,EAAI,EACnD2D,GAAW,MAAMD,EAAS,KAAKC,CAAO,CAC5C,CAEA,OAAOD,EAAS,OAAS,EAAIA,EAAS,KAAK;AAAA,CAAI,EAAI,IACrD,CAEA,6BAA6B9C,EAAO,CAClC,GAAM,CACJ,IAAAP,CACF,EAAI,KAAK,QAET,GADI,KAAK,QAAUO,IAAU,KAAK,OAAO,KACrC,CAAC,KAAK,WAAY,MAAO,GAC7B,GAAM,CACJ,IAAAG,CACF,EAAI,KAAK,WACT,OAAOH,IAAUG,GAAOY,EAAK,QAAQtB,EAAKU,EAAM,CAAC,CACnD,CAEA,IAAI,YAAa,CACf,GAAI,KAAK,QAAS,CAChB,GAAM,CACJ,IAAAV,CACF,EAAI,KAAK,QAET,QAASmD,EAAI,EAAGA,EAAI,KAAK,MAAM,OAAQ,EAAEA,EACvC,GAAInD,EAAI,KAAK,MAAMmD,GAAG,SAAWxD,EAAK,QAAS,MAAO,EAE1D,CAEA,MAAO,EACT,CAEA,IAAI,UAAW,CACb,GAAI,KAAK,QAAS,CAChB,GAAM,CACJ,IAAAK,CACF,EAAI,KAAK,QAET,QAASmD,EAAI,EAAGA,EAAI,KAAK,MAAM,OAAQ,EAAEA,EACvC,GAAInD,EAAI,KAAK,MAAMmD,GAAG,SAAWxD,EAAK,QAAS,MAAO,EAE1D,CAEA,MAAO,EACT,CAEA,IAAI,uBAAwB,CAC1B,MAAO,EACT,CAEA,IAAI,UAAW,CAEb,MADsB,CAACC,GAAK,SAAUA,GAAK,SAAUA,GAAK,aAAcA,GAAK,YAAY,EACpE,QAAQ,KAAK,IAAI,IAAM,EAC9C,CAEA,IAAI,gBAAiB,CACnB,GAAI,CAAC,KAAK,OAAS,CAAC,KAAK,QAAS,OAClC,IAAMW,EAAQD,GAAW,KAAK,MAAM,MAAO,KAAK,QAAQ,IAAI,EAC5D,GAAI,CAACC,EAAO,OACZ,IAAMG,EAAMJ,GAAW,KAAK,MAAM,IAAK,KAAK,QAAQ,IAAI,EACxD,MAAO,CACL,MAAAC,EACA,IAAAG,CACF,CACF,CAEA,IAAI,UAAW,CACb,GAAI,CAAC,KAAK,YAAc,CAAC,KAAK,QAAS,OAAO,KAC9C,GAAM,CACJ,MAAAH,EACA,IAAAG,CACF,EAAI,KAAK,WACT,OAAO,KAAK,QAAQ,IAAI,MAAMH,EAAOG,CAAG,CAC1C,CAEA,IAAI,KAAM,CACR,QAASyC,EAAI,EAAGA,EAAI,KAAK,MAAM,OAAQ,EAAEA,EAAG,CAC1C,IAAMI,EAAM,KAAK,aAAaJ,EAAGxD,EAAK,IAAK,EAAK,EAEhD,GAAI4D,GAAO,KAAM,CACf,GAAIA,EAAI,KAAO,IACb,MAAO,CACL,SAAUA,EAAI,MAAM,EAAG,EAAE,CAC3B,EACK,CAEL,GAAM,CAACC,EAAGC,EAAQC,CAAM,EAAIH,EAAI,MAAM,gBAAgB,EACtD,MAAO,CACL,OAAAE,EACA,OAAAC,CACF,CACF,CACF,CACF,CAEA,OAAO,IACT,CAEA,IAAI,2BAA4B,CAC9B,GAAI,CAAC,KAAK,YAAc,CAAC,KAAK,QAAS,MAAO,GAC9C,GAAM,CACJ,MAAAnD,EACA,IAAAG,CACF,EAAI,KAAK,WACH,CACJ,IAAAV,CACF,EAAI,KAAK,QAET,QAASmD,EAAI5C,EAAO4C,EAAIzC,EAAK,EAAEyC,EAC7B,GAAInD,EAAImD,KAAO;AAAA,EAAM,MAAO,GAG9B,MAAO,EACT,CAEA,aAAa5C,EAAO,CAClB,GAAM,CACJ,IAAAP,CACF,EAAI,KAAK,QAET,GAAIA,EAAIO,KAAWZ,EAAK,QAAS,CAC/B,IAAMe,EAAMY,EAAK,UAAUtB,EAAKO,EAAQ,CAAC,EACnCoD,EAAe,IAAIzC,EAAMX,EAAOG,CAAG,EACzC,YAAK,MAAM,KAAKiD,CAAY,EACrBjD,CACT,CAEA,OAAOH,CACT,CAWA,cAAca,EAAIlB,EAAQ,CACxB,OAAI,KAAK,QAAOA,EAAS,KAAK,MAAM,aAAakB,EAAIlB,CAAM,GACvD,KAAK,YAAY,KAAK,WAAW,aAAakB,EAAIlB,CAAM,EAC5D,KAAK,MAAM,QAAQgD,GAAQA,EAAK,aAAa9B,EAAIlB,CAAM,CAAC,EACjDA,CACT,CAEA,UAAW,CACT,GAAM,CACJ,QAAS,CACP,IAAAF,CACF,EACA,MAAA4D,EACA,MAAAC,CACF,EAAI,KACJ,GAAIA,GAAS,KAAM,OAAOA,EAC1B,IAAMtC,EAAMvB,EAAI,MAAM4D,EAAM,MAAOA,EAAM,GAAG,EAC5C,OAAOtC,EAAK,oBAAoBtB,EAAK4D,EAAM,IAAKrC,CAAG,CACrD,CAEF,EAEMuC,EAAN,cAAwB,KAAM,CAC5B,YAAYC,EAAMC,EAAQC,EAAS,CACjC,GAAI,CAACA,GAAW,EAAED,aAAkB1C,GAAO,MAAM,IAAI,MAAM,6BAA6ByC,GAAM,EAC9F,MAAM,EACN,KAAK,KAAOA,EACZ,KAAK,QAAUE,EACf,KAAK,OAASD,CAChB,CAEA,YAAa,CACX,GAAI,CAAC,KAAK,OAAQ,OAClB,KAAK,SAAW,KAAK,OAAO,KAC5B,IAAM5D,EAAM,KAAK,OAAO,SAAW,KAAK,OAAO,QAAQ,KAEvD,GAAI,OAAO,KAAK,QAAW,SAAU,CACnC,KAAK,MAAQ,IAAIc,EAAM,KAAK,OAAQ,KAAK,OAAS,CAAC,EACnD,IAAMX,EAAQH,GAAOE,GAAW,KAAK,OAAQF,CAAG,EAEhD,GAAIG,EAAO,CACT,IAAMG,EAAM,CACV,KAAMH,EAAM,KACZ,IAAKA,EAAM,IAAM,CACnB,EACA,KAAK,QAAU,CACb,MAAAA,EACA,IAAAG,CACF,CACF,CAEA,OAAO,KAAK,MACd,MACE,KAAK,MAAQ,KAAK,OAAO,MACzB,KAAK,QAAU,KAAK,OAAO,eAG7B,GAAI,KAAK,QAAS,CAChB,GAAM,CACJ,KAAAF,EACA,IAAAK,CACF,EAAI,KAAK,QAAQ,MACjB,KAAK,SAAW,YAAYL,aAAgBK,IAC5C,IAAMqD,EAAM9D,GAAOO,GAAiB,KAAK,QAASP,CAAG,EACjD8D,IAAK,KAAK,SAAW;AAAA;AAAA,EAAQA;AAAA,EACnC,CAEA,OAAO,KAAK,MACd,CAEF,EACMC,GAAN,cAAiCL,CAAU,CACzC,YAAYE,EAAQC,EAAS,CAC3B,MAAM,qBAAsBD,EAAQC,CAAO,CAC7C,CAEF,EACMG,GAAN,cAAgCN,CAAU,CACxC,YAAYE,EAAQC,EAAS,CAC3B,MAAM,oBAAqBD,EAAQC,CAAO,CAC5C,CAEF,EACMI,GAAN,cAA8BP,CAAU,CACtC,YAAYE,EAAQC,EAAS,CAC3B,MAAM,kBAAmBD,EAAQC,CAAO,CAC1C,CAEF,EACMK,GAAN,cAA0BR,CAAU,CAClC,YAAYE,EAAQC,EAAS,CAC3B,MAAM,cAAeD,EAAQC,CAAO,CACtC,CAEF,EAEA,SAASM,GAAgBC,EAAKxB,EAAKa,EAAO,CACxC,OAAIb,KAAOwB,EACT,OAAO,eAAeA,EAAKxB,EAAK,CAC9B,MAAOa,EACP,WAAY,GACZ,aAAc,GACd,SAAU,EACZ,CAAC,EAEDW,EAAIxB,GAAOa,EAGNW,CACT,CAEA,IAAMC,GAAN,cAAyBnD,CAAK,CAC5B,OAAO,UAAUtB,EAAKO,EAAOmE,EAAQ,CACnC,IAAI3C,EAAK/B,EAAIO,GACTL,EAASK,EAEb,KAAOwB,GAAMA,IAAO;AAAA,GACd,EAAA2C,IAAW3C,IAAO,KAAOA,IAAO,KAAOA,IAAO,KAAOA,IAAO,KAAOA,IAAO,OADtD,CAExB,IAAMP,EAAOxB,EAAIE,EAAS,GAE1B,GADI6B,IAAO,MAAQ,CAACP,GAAQA,IAAS;AAAA,GAAQA,IAAS,KAAQA,IAAS,KAAOkD,GAAUlD,IAAS,OAC5FO,IAAO,KAAOA,IAAO,MAASP,IAAS,IAAK,MACjDtB,GAAU,EACV6B,EAAKP,CACP,CAEA,OAAOtB,CACT,CAEA,IAAI,UAAW,CACb,GAAI,CAAC,KAAK,YAAc,CAAC,KAAK,QAAS,OAAO,KAC9C,GAAI,CACF,MAAAK,EACA,IAAAG,CACF,EAAI,KAAK,WACH,CACJ,IAAAV,CACF,EAAI,KAAK,QACL+B,EAAK/B,EAAIU,EAAM,GAEnB,KAAOH,EAAQG,IAAQqB,IAAO;AAAA,GAAQA,IAAO,KAAQA,IAAO,MAAMA,EAAK/B,EAAI,EAAEU,EAAM,GAEnF,IAAIa,EAAM,GAEV,QAAS4B,EAAI5C,EAAO4C,EAAIzC,EAAK,EAAEyC,EAAG,CAChC,IAAMpB,EAAK/B,EAAImD,GAEf,GAAIpB,IAAO;AAAA,EAAM,CACf,GAAM,CACJ,KAAAY,EACA,OAAAzC,CACF,EAAIoB,EAAK,YAAYtB,EAAKmD,EAAG,EAAE,EAC/B5B,GAAOoB,EACPQ,EAAIjD,CACN,SAAW6B,IAAO,KAAOA,IAAO,IAAM,CAEpC,IAAM4C,EAAUxB,EACZ3B,EAAOxB,EAAImD,EAAI,GAEnB,KAAOA,EAAIzC,IAAQc,IAAS,KAAOA,IAAS,MAC1C2B,GAAK,EACL3B,EAAOxB,EAAImD,EAAI,GAGb3B,IAAS;AAAA,IAAMD,GAAO4B,EAAIwB,EAAU3E,EAAI,MAAM2E,EAASxB,EAAI,CAAC,EAAIpB,EACtE,MACER,GAAOQ,CAEX,CAEA,IAAML,EAAM1B,EAAIO,GAEhB,OAAQmB,OACD,IACH,CACE,IAAMkD,EAAM,gDAEZ,MAAO,CACL,OAFa,CAAC,IAAIR,GAAkB,KAAMQ,CAAG,CAAC,EAG9C,IAAArD,CACF,CACF,KAEG,QACA,IACH,CACE,IAAMqD,EAAM,oDAAoDlD,IAEhE,MAAO,CACL,OAFa,CAAC,IAAI0C,GAAkB,KAAMQ,CAAG,CAAC,EAG9C,IAAArD,CACF,CACF,SAGA,OAAOA,EAEb,CAEA,gBAAgBhB,EAAO,CACrB,GAAM,CACJ,OAAA2B,EACA,OAAAwC,EACA,IAAA1E,CACF,EAAI,KAAK,QACLE,EAASK,EACTsE,EAAWtE,EAEf,QAASwB,EAAK/B,EAAIE,GAAS6B,IAAO;AAAA,GAC5B,CAAAT,EAAK,mBAAmBtB,EAAKE,EAAS,CAAC,EADL6B,EAAK/B,EAAIE,GAAS,CAExD,IAAMQ,EAAMY,EAAK,iBAAiBtB,EAAKkC,EAAQhC,EAAS,CAAC,EACzD,GAAIQ,IAAQ,MAAQV,EAAIU,KAAS,IAAK,MAElCV,EAAIU,KAAS;AAAA,EACfR,EAASQ,GAETmE,EAAWJ,GAAW,UAAUzE,EAAKU,EAAKgE,CAAM,EAChDxE,EAAS2E,EAEb,CAEA,OAAI,KAAK,WAAW,QAAQ,IAAG,KAAK,WAAW,MAAQtE,GACvD,KAAK,WAAW,IAAMsE,EACfA,CACT,CA4BA,MAAM/B,EAASvC,EAAO,CACpB,KAAK,QAAUuC,EACf,GAAM,CACJ,OAAA4B,EACA,IAAA1E,CACF,EAAI8C,EACA5C,EAASK,EACPwB,EAAK/B,EAAIE,GAEf,OAAI6B,GAAMA,IAAO,KAAOA,IAAO;AAAA,IAC7B7B,EAASuE,GAAW,UAAUzE,EAAKO,EAAOmE,CAAM,GAGlD,KAAK,WAAa,IAAIxD,EAAMX,EAAOL,CAAM,EACzCA,EAASoB,EAAK,gBAAgBtB,EAAKE,CAAM,EACzCA,EAAS,KAAK,aAAaA,CAAM,GAE7B,CAAC,KAAK,YAAc,KAAK,WAAW,QAAQ,KAC9CA,EAAS,KAAK,gBAAgBA,CAAM,GAG/BA,CACT,CAEF,EAEAR,EAAQ,KAAOC,EACfD,EAAQ,KAAO4B,EACf5B,EAAQ,WAAa+E,GACrB/E,EAAQ,MAAQwB,EAChBxB,EAAQ,KAAOE,GACfF,EAAQ,UAAYoE,EACpBpE,EAAQ,mBAAqByE,GAC7BzE,EAAQ,kBAAoB0E,GAC5B1E,EAAQ,gBAAkB2E,GAC1B3E,EAAQ,YAAc4E,GACtB5E,EAAQ,gBAAkB6E,GAC1B7E,EAAQ,iBAAmBG,GAC3BH,EAAQ,YAAcI,KC32BtB,IAAAgF,GAAAC,EAAAC,IAAA,cAEA,IAAIC,EAAa,IAEXC,EAAN,cAAwBD,EAAW,IAAK,CACtC,aAAc,CACZ,MAAMA,EAAW,KAAK,UAAU,CAClC,CAIA,IAAI,uBAAwB,CAG1B,MAAO,EACT,CAUA,MAAME,EAASC,EAAO,CACpB,YAAK,QAAUD,EACf,KAAK,MAAQ,IAAIF,EAAW,MAAMG,EAAOA,EAAQ,CAAC,EAC3CA,EAAQ,CACjB,CAEF,EAEMC,GAAN,cAA6BJ,EAAW,IAAK,CAC3C,YAAYK,EAAMC,EAAO,CACvB,MAAMD,EAAMC,CAAK,EACjB,KAAK,KAAO,IACd,CAEA,IAAI,uBAAwB,CAC1B,MAAO,CAAC,CAAC,KAAK,MAAQ,KAAK,KAAK,qBAClC,CAQA,MAAMJ,EAASC,EAAO,CACpB,KAAK,QAAUD,EACf,GAAM,CACJ,UAAAK,EACA,IAAAC,CACF,EAAIN,EACA,CACF,YAAAO,EACA,UAAAC,CACF,EAAIR,EACA,CAACO,GAAe,KAAK,OAAST,EAAW,KAAK,WAAU,KAAK,MAAQ,IAAIA,EAAW,kBAAkB,KAAM,iEAAiE,GACjL,IAAMW,EAASF,EAAcN,EAAQO,EAAYR,EAAQ,OACrDU,EAASZ,EAAW,KAAK,gBAAgBQ,EAAKL,EAAQ,CAAC,EACvDU,EAAKL,EAAII,GACPE,EAAgBD,IAAO,IACvBE,EAAW,CAAC,EACdC,EAAY,KAEhB,KAAOH,IAAO;AAAA,GAAQA,IAAO,KAAK,CAChC,GAAIA,IAAO,IAAK,CACd,IAAMI,EAAMjB,EAAW,KAAK,UAAUQ,EAAKI,EAAS,CAAC,EACrDG,EAAS,KAAK,IAAIf,EAAW,MAAMY,EAAQK,CAAG,CAAC,EAC/CL,EAASK,CACX,KAAO,CACLR,EAAc,GACdC,EAAYE,EAAS,EACrB,IAAMM,EAAQlB,EAAW,KAAK,gBAAgBQ,EAAKE,CAAS,EAExDF,EAAIU,KAAW;AAAA,GAAQH,EAAS,SAAW,IAC7CC,EAAY,IAAIf,EAChBS,EAAYM,EAAU,MAAM,CAC1B,IAAAR,CACF,EAAGE,CAAS,GAGdE,EAASZ,EAAW,KAAK,YAAYQ,EAAKE,CAAS,CACrD,CAEAG,EAAKL,EAAII,EACX,CAcA,GAZIZ,EAAW,KAAK,mBAAmBa,EAAID,GAAUF,EAAYC,GAAS,KAAK,OAASX,EAAW,KAAK,QAAQ,EAC9G,KAAK,KAAOO,EAAU,CACpB,YAAAE,EACA,aAAc,GACd,OAAAE,EACA,UAAAD,EACA,OAAQ,IACV,EAAGE,CAAM,EACAC,GAAMH,EAAYP,EAAQ,IACnCS,EAASF,EAAY,GAGnB,KAAK,KAAM,CACb,GAAIM,EAAW,CAIb,IAAMG,EAAQjB,EAAQ,OAAO,OAASA,EAAQ,OAAO,SACjDiB,GAAOA,EAAM,KAAKH,CAAS,CACjC,CAEID,EAAS,QAAQ,MAAM,UAAU,KAAK,MAAM,KAAK,MAAOA,CAAQ,EACpEH,EAAS,KAAK,KAAK,MAAM,GAC3B,SACME,EAAe,CACjB,IAAMM,EAAIL,EAAS,GACnB,KAAK,MAAM,KAAKK,CAAC,EACjBR,EAASQ,EAAE,GACb,MACER,EAASZ,EAAW,KAAK,UAAUQ,EAAKL,EAAQ,CAAC,EAIrD,IAAMc,EAAM,KAAK,KAAO,KAAK,KAAK,WAAW,IAAML,EACnD,YAAK,WAAa,IAAIZ,EAAW,MAAMG,EAAOc,CAAG,EAC1CL,CACT,CAEA,cAAcS,EAAIT,EAAQ,CACxB,OAAAA,EAAS,MAAM,cAAcS,EAAIT,CAAM,EAChC,KAAK,KAAO,KAAK,KAAK,cAAcS,EAAIT,CAAM,EAAIA,CAC3D,CAEA,UAAW,CACT,GAAM,CACJ,QAAS,CACP,IAAAJ,CACF,EACA,KAAAc,EACA,MAAAC,EACA,MAAAC,CACF,EAAI,KACJ,GAAIA,GAAS,KAAM,OAAOA,EAC1B,IAAMC,EAAMH,EAAOd,EAAI,MAAMe,EAAM,MAAOD,EAAK,MAAM,KAAK,EAAI,OAAOA,CAAI,EAAId,EAAI,MAAMe,EAAM,MAAOA,EAAM,GAAG,EAC7G,OAAOvB,EAAW,KAAK,oBAAoBQ,EAAKe,EAAM,IAAKE,CAAG,CAChE,CAEF,EAEMC,EAAN,cAAsB1B,EAAW,IAAK,CACpC,aAAc,CACZ,MAAMA,EAAW,KAAK,OAAO,CAC/B,CAUA,MAAME,EAASC,EAAO,CACpB,KAAK,QAAUD,EACf,IAAMU,EAAS,KAAK,aAAaT,CAAK,EACtC,YAAK,MAAQ,IAAIH,EAAW,MAAMG,EAAOS,CAAM,EACxCA,CACT,CAEF,EAEA,SAASe,GAA0BL,EAAM,CACvC,IAAIM,EAAQN,EAEZ,KAAOM,aAAiBxB,IAAgBwB,EAAQA,EAAM,KAEtD,GAAI,EAAEA,aAAiBC,GAAa,OAAO,KAC3C,IAAMC,EAAMF,EAAM,MAAM,OACpBG,EAAK,GAET,QAASC,EAAIF,EAAM,EAAGE,GAAK,EAAG,EAAEA,EAAG,CACjC,IAAMC,EAAIL,EAAM,MAAMI,GAEtB,GAAIC,EAAE,OAASjC,EAAW,KAAK,QAAS,CAEtC,GAAM,CACJ,OAAAW,EACA,UAAAD,CACF,EAAIuB,EAAE,QACN,GAAItB,EAAS,GAAKsB,EAAE,MAAM,OAASvB,EAAYC,EAAQ,MACvDoB,EAAKC,CACP,SAAWC,EAAE,OAASjC,EAAW,KAAK,WAAY+B,EAAKC,MAAO,MAChE,CAEA,GAAID,IAAO,GAAI,OAAO,KACtB,IAAMG,EAAKN,EAAM,MAAM,OAAOG,EAAID,EAAMC,CAAE,EACpCI,EAAUD,EAAG,GAAG,MAAM,MAE5B,KACEN,EAAM,MAAM,IAAMO,EACdP,EAAM,YAAcA,EAAM,WAAW,IAAMO,IAASP,EAAM,WAAW,IAAMO,GAC3EP,IAAUN,GACdM,EAAQA,EAAM,QAAQ,OAGxB,OAAOM,CACT,CACA,IAAML,EAAN,cAAyB7B,EAAW,IAAK,CACvC,OAAO,qBAAqBQ,EAAKI,EAAQD,EAAQ,CAC/C,IAAMD,EAAYV,EAAW,KAAK,UAAUQ,EAAKI,CAAM,EAAI,EAC3DA,EAASZ,EAAW,KAAK,gBAAgBQ,EAAKE,CAAS,EACvD,IAAMG,EAAKL,EAAII,GACf,OAAKC,EACDD,GAAUF,EAAYC,EAAe,GACrCE,IAAO,KAAOA,IAAO;AAAA,EAAa,GAC/BgB,EAAW,qBAAqBrB,EAAKI,EAAQD,CAAM,EAH1C,EAIlB,CAEA,YAAYyB,EAAW,CACrB,MAAMA,EAAU,OAASpC,EAAW,KAAK,SAAWA,EAAW,KAAK,IAAMA,EAAW,KAAK,GAAG,EAE7F,QAASgC,EAAII,EAAU,MAAM,OAAS,EAAGJ,GAAK,EAAG,EAAEA,EACjD,GAAII,EAAU,MAAMJ,GAAG,MAAQI,EAAU,QAAQ,UAAW,CAE1D,KAAK,MAAQA,EAAU,MAAM,MAAM,EAAGJ,EAAI,CAAC,EAC3CI,EAAU,MAAQA,EAAU,MAAM,MAAMJ,EAAI,CAAC,EAC7C,IAAMK,EAAYD,EAAU,MAAM,IAAMA,EAAU,WAClDA,EAAU,MAAM,MAAQC,EAAU,MAClC,KACF,CAGF,KAAK,MAAQ,CAACD,CAAS,EACvB,IAAME,EAAKX,GAA0BS,CAAS,EAC1CE,GAAI,MAAM,UAAU,KAAK,MAAM,KAAK,MAAOA,CAAE,CACnD,CAEA,IAAI,uBAAwB,CAC1B,OAAO,KAAK,MAAM,OAAS,CAC7B,CAQA,MAAMpC,EAASC,EAAO,CACpB,KAAK,QAAUD,EACf,GAAM,CACJ,UAAAK,EACA,IAAAC,CACF,EAAIN,EAGAQ,EAAYV,EAAW,KAAK,YAAYQ,EAAKL,CAAK,EAChDiC,EAAY,KAAK,MAAM,GAG7BA,EAAU,QAAQ,OAAS,KAC3B,KAAK,WAAapC,EAAW,MAAM,KAAKoC,EAAU,UAAU,EAC5D,IAAMzB,EAASyB,EAAU,MAAM,MAAQA,EAAU,QAAQ,UACrDxB,EAAST,EACbS,EAASZ,EAAW,KAAK,gBAAgBQ,EAAKI,CAAM,EACpD,IAAIC,EAAKL,EAAII,GACTH,EAAcT,EAAW,KAAK,gBAAgBQ,EAAKE,CAAS,IAAME,EAClE2B,EAA4B,GAEhC,KAAO1B,GAAI,CACT,KAAOA,IAAO;AAAA,GAAQA,IAAO,KAAK,CAChC,GAAIJ,GAAeI,IAAO;AAAA,GAAQ,CAAC0B,EAA2B,CAC5D,IAAMvB,EAAY,IAAIf,EAMtB,GALAW,EAASI,EAAU,MAAM,CACvB,IAAAR,CACF,EAAGI,CAAM,EACT,KAAK,WAAW,IAAMA,EAElBA,GAAUJ,EAAI,OAAQ,CACxBK,EAAK,KACL,KACF,CAEA,KAAK,MAAM,KAAKG,CAAS,EACzBJ,GAAU,CACZ,SAAWC,IAAO,IAAK,CACrB,GAAID,EAASF,EAAYC,GAAU,CAACkB,EAAW,qBAAqBrB,EAAKI,EAAQD,CAAM,EACrF,OAAOC,EAGT,IAAM4B,EAAU,IAAId,EASpB,GARAd,EAAS4B,EAAQ,MAAM,CACrB,OAAA7B,EACA,UAAAD,EACA,IAAAF,CACF,EAAGI,CAAM,EACT,KAAK,MAAM,KAAK4B,CAAO,EACvB,KAAK,WAAW,IAAM5B,EAElBA,GAAUJ,EAAI,OAAQ,CACxBK,EAAK,KACL,KACF,CACF,CAKA,GAHAH,EAAYE,EAAS,EACrBA,EAASZ,EAAW,KAAK,YAAYQ,EAAKE,CAAS,EAE/CV,EAAW,KAAK,QAAQQ,EAAKI,CAAM,EAAG,CACxC,IAAMM,EAAQlB,EAAW,KAAK,gBAAgBQ,EAAKI,CAAM,EACnD6B,EAAOjC,EAAIU,IAEb,CAACuB,GAAQA,IAAS;AAAA,GAAQA,IAAS,OACrC7B,EAASM,EAEb,CAEAL,EAAKL,EAAII,GACTH,EAAc,EAChB,CAEA,GAAI,CAACI,EACH,MAGF,GAAID,IAAWF,EAAYC,IAAWF,GAAeI,IAAO,MAC1D,GAAID,EAASF,EAAYC,EAAQ,CAC3BD,EAAYP,IAAOS,EAASF,GAChC,KACF,SAAW,CAAC,KAAK,MAAO,CACtB,IAAMgC,EAAM,qDACZ,KAAK,MAAQ,IAAI1C,EAAW,gBAAgB,KAAM0C,CAAG,CACvD,EAGF,GAAIN,EAAU,OAASpC,EAAW,KAAK,UACrC,GAAIa,IAAO,IAAK,CACVH,EAAYP,IAAOS,EAASF,GAChC,KACF,UACSG,IAAO,KAAO,CAAC,KAAK,MAAO,CAEpC,IAAM4B,EAAOjC,EAAII,EAAS,GAE1B,GAAI,CAAC6B,GAAQA,IAAS;AAAA,GAAQA,IAAS,KAAQA,IAAS,IAAK,CAC3D,IAAMC,EAAM,uDACZ,KAAK,MAAQ,IAAI1C,EAAW,gBAAgB,KAAM0C,CAAG,CACvD,CACF,CAEA,IAAMpB,EAAOf,EAAU,CACrB,YAAAE,EACA,aAAc,GACd,OAAAE,EACA,UAAAD,EACA,OAAQ,IACV,EAAGE,CAAM,EACT,GAAI,CAACU,EAAM,OAAOV,EAWlB,GATA,KAAK,MAAM,KAAKU,CAAI,EACpB,KAAK,WAAW,IAAMA,EAAK,WAAW,IACtCV,EAASZ,EAAW,KAAK,gBAAgBQ,EAAKc,EAAK,MAAM,GAAG,EAC5DT,EAAKL,EAAII,GACTH,EAAc,GACd8B,EAA4BjB,EAAK,sBAI7BT,EAAI,CACN,IAAI8B,EAAK/B,EAAS,EACdgC,EAAOpC,EAAImC,GAEf,KAAOC,IAAS,KAAOA,IAAS,KAAMA,EAAOpC,EAAI,EAAEmC,GAE/CC,IAAS;AAAA,IACXlC,EAAYiC,EAAK,EACjBlC,EAAc,GAElB,CAEA,IAAM6B,EAAKX,GAA0BL,CAAI,EACrCgB,GAAI,MAAM,UAAU,KAAK,MAAM,KAAK,MAAOA,CAAE,CACnD,CAEA,OAAO1B,CACT,CAEA,cAAcS,EAAIT,EAAQ,CACxB,OAAAA,EAAS,MAAM,cAAcS,EAAIT,CAAM,EACvC,KAAK,MAAM,QAAQU,GAAQ,CACzBV,EAASU,EAAK,cAAcD,EAAIT,CAAM,CACxC,CAAC,EACMA,CACT,CAEA,UAAW,CACT,GAAM,CACJ,QAAS,CACP,IAAAJ,CACF,EACA,MAAAW,EACA,MAAAI,EACA,MAAAC,CACF,EAAI,KACJ,GAAIA,GAAS,KAAM,OAAOA,EAC1B,IAAIC,EAAMjB,EAAI,MAAMe,EAAM,MAAOJ,EAAM,GAAG,MAAM,KAAK,EAAI,OAAOA,EAAM,EAAE,EAExE,QAASa,EAAI,EAAGA,EAAIb,EAAM,OAAQ,EAAEa,EAAG,CACrC,IAAMa,EAAO1B,EAAMa,GACb,CACJ,YAAAvB,EACA,OAAAE,CACF,EAAIkC,EAAK,QACT,GAAIpC,EAAa,QAASuB,EAAI,EAAGA,EAAIrB,EAAQ,EAAEqB,EAAGP,GAAO,IACzDA,GAAO,OAAOoB,CAAI,CACpB,CAEA,OAAO7C,EAAW,KAAK,oBAAoBQ,EAAKe,EAAM,IAAKE,CAAG,CAChE,CAEF,EAEMqB,GAAN,cAAwB9C,EAAW,IAAK,CACtC,aAAc,CACZ,MAAMA,EAAW,KAAK,SAAS,EAC/B,KAAK,KAAO,IACd,CAEA,IAAI,YAAa,CACf,IAAM+C,EAAM,KAAK,SACjB,OAAOA,EAAMA,EAAI,KAAK,EAAE,MAAM,QAAQ,EAAI,CAAC,CAC7C,CAEA,UAAU5C,EAAO,CACf,GAAM,CACJ,IAAAK,CACF,EAAI,KAAK,QACLI,EAAST,EACTU,EAAKL,EAAII,GAEb,KAAOC,GAAMA,IAAO;AAAA,GAAQA,IAAO,KAAQA,IAAO,KAAKA,EAAKL,EAAII,GAAU,GAE1E,YAAK,KAAOJ,EAAI,MAAML,EAAOS,CAAM,EAC5BA,CACT,CAEA,gBAAgBT,EAAO,CACrB,GAAM,CACJ,IAAAK,CACF,EAAI,KAAK,QACLI,EAAST,EACTU,EAAKL,EAAII,GAEb,KAAOC,GAAMA,IAAO;AAAA,GAAQA,IAAO,KAAKA,EAAKL,EAAII,GAAU,GAE3D,YAAK,WAAa,IAAIZ,EAAW,MAAMG,EAAOS,CAAM,EAC7CA,CACT,CAEA,MAAMV,EAASC,EAAO,CACpB,KAAK,QAAUD,EACf,IAAIU,EAAS,KAAK,UAAUT,EAAQ,CAAC,EACrC,OAAAS,EAAS,KAAK,gBAAgBA,CAAM,EACpCA,EAAS,KAAK,aAAaA,CAAM,EACjC,KAAK,MAAQ,IAAIZ,EAAW,MAAMG,EAAOS,CAAM,EACxCA,CACT,CAEF,EAEMoC,GAAN,cAAuBhD,EAAW,IAAK,CACrC,OAAO,2BAA2BQ,EAAKL,EAAO,CAC5C,IAAMS,EAASZ,EAAW,KAAK,gBAAgBQ,EAAKL,CAAK,EACnDU,EAAKL,EAAII,GACf,OAAOC,IAAO,KAAOA,IAAO;AAAA,EAAOD,EAAST,CAC9C,CAEA,aAAc,CACZ,MAAMH,EAAW,KAAK,QAAQ,EAC9B,KAAK,WAAa,KAClB,KAAK,SAAW,KAChB,KAAK,oBAAsB,KAC3B,KAAK,kBAAoB,IAC3B,CAEA,gBAAgBG,EAAO,CACrB,GAAM,CACJ,IAAAK,CACF,EAAI,KAAK,QACT,KAAK,WAAa,CAAC,EACnB,IAAIC,EAAc,GACdwC,EAAgB,GAChBrC,EAAST,EAEb,KAAO,CAACH,EAAW,KAAK,mBAAmBQ,EAAKI,EAAQZ,EAAW,KAAK,cAAc,GAGpF,OAFAY,EAASoC,GAAS,2BAA2BxC,EAAKI,CAAM,EAEhDJ,EAAII,QACL;AAAA,EACH,GAAIH,EAAa,CACf,IAAMO,EAAY,IAAIf,EACtBW,EAASI,EAAU,MAAM,CACvB,IAAAR,CACF,EAAGI,CAAM,EAELA,EAASJ,EAAI,QACf,KAAK,WAAW,KAAKQ,CAAS,CAElC,MACEJ,GAAU,EACVH,EAAc,GAGhB,UAEG,IACH,CACE,IAAM+B,EAAU,IAAId,EACpBd,EAAS4B,EAAQ,MAAM,CACrB,IAAAhC,CACF,EAAGI,CAAM,EACT,KAAK,WAAW,KAAK4B,CAAO,EAC5B/B,EAAc,EAChB,CACA,UAEG,IACH,CACE,IAAMyC,EAAY,IAAIJ,GACtBlC,EAASsC,EAAU,MAAM,CACvB,OAAQ,KACR,IAAA1C,CACF,EAAGI,CAAM,EACT,KAAK,WAAW,KAAKsC,CAAS,EAC9BD,EAAgB,GAChBxC,EAAc,EAChB,CACA,cAGA,OAAIwC,EACF,KAAK,MAAQ,IAAIjD,EAAW,kBAAkB,KAAM,uCAAuC,EAClF,KAAK,WAAW,OAAS,IAClC,KAAK,SAAW,KAAK,WACrB,KAAK,WAAa,CAAC,GAGdY,EAIb,OAAIJ,EAAII,IACN,KAAK,oBAAsB,IAAIZ,EAAW,MAAMY,EAAQA,EAAS,CAAC,EAC3DA,EAAS,IAGdqC,EACF,KAAK,MAAQ,IAAIjD,EAAW,kBAAkB,KAAM,uCAAuC,EAClF,KAAK,WAAW,OAAS,IAClC,KAAK,SAAW,KAAK,WACrB,KAAK,WAAa,CAAC,GAGdY,EACT,CAEA,cAAcT,EAAO,CACnB,GAAM,CACJ,UAAAI,EACA,IAAAC,CACF,EAAI,KAAK,QACJ,KAAK,WAAU,KAAK,SAAW,CAAC,GACrC,IAAIE,EAAYP,EAEhB,KAAOK,EAAIE,EAAY,KAAO,KAAKA,GAAa,EAEhD,IAAIE,EAASZ,EAAW,KAAK,gBAAgBQ,EAAKL,CAAK,EACnDM,EAAcC,IAAcP,EAGhC,IAFA,KAAK,WAAa,IAAIH,EAAW,MAAMY,CAAM,EAEtC,CAACZ,EAAW,KAAK,mBAAmBQ,EAAKI,EAAQZ,EAAW,KAAK,YAAY,GAAG,CACrF,OAAQQ,EAAII,QACL;AAAA,EACH,GAAIH,EAAa,CACf,IAAMO,EAAY,IAAIf,EACtBW,EAASI,EAAU,MAAM,CACvB,IAAAR,CACF,EAAGI,CAAM,EAELA,EAASJ,EAAI,QACf,KAAK,SAAS,KAAKQ,CAAS,CAEhC,MACEJ,GAAU,EACVH,EAAc,GAGhBC,EAAYE,EACZ,UAEG,IACH,CACE,IAAM4B,EAAU,IAAId,EACpBd,EAAS4B,EAAQ,MAAM,CACrB,IAAAhC,CACF,EAAGI,CAAM,EACT,KAAK,SAAS,KAAK4B,CAAO,EAC1B/B,EAAc,EAChB,CACA,cAGA,CACE,IAAM0C,EAAOnD,EAAW,KAAK,YAAYQ,EAAKI,CAAM,EAS9CU,EAAOf,EARG,CACd,YAAAE,EACA,OAAQ,GACR,OAAQ,GACR,aAAc,GACd,UAAAC,EACA,OAAQ,IACV,EACgCyC,CAAI,EACpC,GAAI,CAAC7B,EAAM,OAAO,KAAK,WAAW,IAAM6B,EAExC,KAAK,SAAS,KAAK7B,CAAI,EACvBV,EAASU,EAAK,MAAM,IACpBb,EAAc,GACd,IAAM6B,EAAKX,GAA0BL,CAAI,EACrCgB,GAAI,MAAM,UAAU,KAAK,MAAM,KAAK,SAAUA,CAAE,CACtD,EAGJ1B,EAASoC,GAAS,2BAA2BxC,EAAKI,CAAM,CAC1D,CAIA,GAFA,KAAK,WAAW,IAAMA,EAElBJ,EAAII,KACN,KAAK,kBAAoB,IAAIZ,EAAW,MAAMY,EAAQA,EAAS,CAAC,EAChEA,GAAU,EAENJ,EAAII,IAAS,CAGf,GAFAA,EAASZ,EAAW,KAAK,gBAAgBQ,EAAKI,CAAM,EAEhDJ,EAAII,KAAY,IAAK,CACvB,IAAM4B,EAAU,IAAId,EACpBd,EAAS4B,EAAQ,MAAM,CACrB,IAAAhC,CACF,EAAGI,CAAM,EACT,KAAK,SAAS,KAAK4B,CAAO,CAC5B,CAEA,OAAQhC,EAAII,QACL;AAAA,EACHA,GAAU,EACV,WAEG,OACH,cAGA,KAAK,MAAQ,IAAIZ,EAAW,gBAAgB,KAAM,2DAA2D,EAEnH,CAGF,OAAOY,CACT,CAQA,MAAMV,EAASC,EAAO,CACpBD,EAAQ,KAAO,KACf,KAAK,QAAUA,EACf,GAAM,CACJ,IAAAM,CACF,EAAIN,EACAU,EAASJ,EAAI,WAAWL,CAAK,IAAM,MAASA,EAAQ,EAAIA,EAE5D,OAAAS,EAAS,KAAK,gBAAgBA,CAAM,EACpCA,EAAS,KAAK,cAAcA,CAAM,EAC3BA,CACT,CAEA,cAAcS,EAAIT,EAAQ,CACxB,OAAAA,EAAS,MAAM,cAAcS,EAAIT,CAAM,EACvC,KAAK,WAAW,QAAQU,GAAQ,CAC9BV,EAASU,EAAK,cAAcD,EAAIT,CAAM,CACxC,CAAC,EACG,KAAK,sBAAqBA,EAAS,KAAK,oBAAoB,aAAaS,EAAIT,CAAM,GACvF,KAAK,SAAS,QAAQU,GAAQ,CAC5BV,EAASU,EAAK,cAAcD,EAAIT,CAAM,CACxC,CAAC,EACG,KAAK,oBAAmBA,EAAS,KAAK,kBAAkB,aAAaS,EAAIT,CAAM,GAC5EA,CACT,CAEA,UAAW,CACT,GAAM,CACJ,SAAAwC,EACA,WAAAC,EACA,MAAA7B,CACF,EAAI,KACJ,GAAIA,GAAS,KAAM,OAAOA,EAC1B,IAAIC,EAAM4B,EAAW,KAAK,EAAE,EAE5B,OAAID,EAAS,OAAS,KAChBC,EAAW,OAAS,GAAKD,EAAS,GAAG,OAASpD,EAAW,KAAK,WAASyB,GAAO;AAAA,GAClFA,GAAO2B,EAAS,KAAK,EAAE,GAGrB3B,EAAIA,EAAI,OAAS,KAAO;AAAA,IAAMA,GAAO;AAAA,GAClCA,CACT,CAEF,EAEM6B,GAAN,cAAoBtD,EAAW,IAAK,CAQlC,MAAME,EAASC,EAAO,CACpB,KAAK,QAAUD,EACf,GAAM,CACJ,IAAAM,CACF,EAAIN,EACAU,EAASZ,EAAW,KAAK,gBAAgBQ,EAAKL,EAAQ,CAAC,EAC3D,YAAK,WAAa,IAAIH,EAAW,MAAMG,EAAQ,EAAGS,CAAM,EACxDA,EAASZ,EAAW,KAAK,gBAAgBQ,EAAKI,CAAM,EACpDA,EAAS,KAAK,aAAaA,CAAM,EAC1BA,CACT,CAEF,EAEM2C,EAAQ,CACZ,KAAM,OACN,KAAM,OACN,MAAO,OACT,EACMC,GAAN,cAAyBxD,EAAW,IAAK,CACvC,YAAYK,EAAMC,EAAO,CACvB,MAAMD,EAAMC,CAAK,EACjB,KAAK,YAAc,KACnB,KAAK,SAAWiD,EAAM,KACtB,KAAK,OAAS,IAChB,CAEA,IAAI,uBAAwB,CAC1B,OAAO,KAAK,WAAaA,EAAM,IACjC,CAEA,IAAI,UAAW,CACb,GAAI,CAAC,KAAK,YAAc,CAAC,KAAK,QAAS,OAAO,KAC9C,GAAI,CACF,MAAApD,EACA,IAAAc,CACF,EAAI,KAAK,WACH,CACJ,OAAAN,EACA,IAAAH,CACF,EAAI,KAAK,QACT,GAAI,KAAK,WAAW,QAAQ,EAAG,MAAO,GACtC,IAAIiD,EAAc,KACd5C,EAAKL,EAAIS,EAAM,GAEnB,KAAOJ,IAAO;AAAA,GAAQA,IAAO,KAAQA,IAAO,KAAK,CAG/C,GAFAI,GAAO,EAEHA,GAAOd,EAAO,CAChB,GAAI,KAAK,WAAaoD,EAAM,KAAM,MAAW,MAAO,EACtD,CAEI1C,IAAO;AAAA,IAAM4C,EAAcxC,GAC/BJ,EAAKL,EAAIS,EAAM,EACjB,CAEA,IAAIyC,EAAYzC,EAAM,EAElBwC,IACE,KAAK,WAAaF,EAAM,MAC1BG,EAAYD,EACZxC,EAAM,KAAK,WAAW,KAEtBA,EAAMwC,GAIV,IAAME,EAAKhD,EAAS,KAAK,YACnBiD,EAAS,KAAK,OAAS5D,EAAW,KAAK,aACzC6D,EAAU,GACVpC,EAAM,GACNqC,EAAM,GACNC,EAAmB,GAEvB,QAAS/B,EAAI7B,EAAO6B,EAAIf,EAAK,EAAEe,EAAG,CAChC,QAASgC,EAAI,EAAGA,EAAIL,GACdnD,EAAIwB,KAAO,IADO,EAAEgC,EAExBhC,GAAK,EAGP,IAAMnB,EAAKL,EAAIwB,GAEf,GAAInB,IAAO;AAAA,EACLiD,IAAQ;AAAA,EAAMrC,GAAO;AAAA,EAAUqC,EAAM;AAAA,MACpC,CACL,IAAMG,EAAUjE,EAAW,KAAK,UAAUQ,EAAKwB,CAAC,EAC1CkC,EAAO1D,EAAI,MAAMwB,EAAGiC,CAAO,EACjCjC,EAAIiC,EAEAL,IAAW/C,IAAO,KAAOA,IAAO,MAASmB,EAAI0B,GAC3CI,IAAQ,IAAKA,EAAM;AAAA,EAAc,CAACC,GAAoB,CAACF,GAAWC,IAAQ;AAAA,IAAMA,EAAM;AAAA;AAAA,GAC1FrC,GAAOqC,EAAMI,EAEbJ,EAAMG,EAAUhD,GAAOT,EAAIyD,IAAY,GACvCF,EAAmB,KAEnBtC,GAAOqC,EAAMI,EACbJ,EAAMF,GAAU5B,EAAI0B,EAAY,IAAM;AAAA,EACtCK,EAAmB,IAGjBF,GAAWK,IAAS,KAAIL,EAAU,GACxC,CACF,CAEA,OAAO,KAAK,WAAaN,EAAM,MAAQ9B,EAAMA,EAAM;AAAA,CACrD,CAEA,iBAAiBtB,EAAO,CACtB,GAAM,CACJ,IAAAK,CACF,EAAI,KAAK,QACLI,EAAST,EAAQ,EACjBwD,EAAK,GAET,OAAa,CACX,IAAM9C,EAAKL,EAAII,GAEf,OAAQC,OACD,IACH,KAAK,SAAW0C,EAAM,MACtB,UAEG,IACH,KAAK,SAAWA,EAAM,KACtB,UAEG,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,IACHI,GAAM9C,EACN,cAGA,YAAK,YAAc,OAAO8C,CAAE,GAAK,KACjC,KAAK,OAAS,IAAI3D,EAAW,MAAMG,EAAOS,CAAM,EACzCA,EAGXA,GAAU,CACZ,CACF,CAEA,gBAAgBT,EAAO,CACrB,GAAM,CACJ,OAAAQ,EACA,IAAAH,CACF,EAAI,KAAK,QACH2D,EAAW,CAAC,CAAC,KAAK,YACpBvD,EAAST,EACTiE,EAAWjE,EACXkE,EAAiB,EAErB,QAASxD,EAAKL,EAAII,GAASC,IAAO;AAAA,IAChCD,GAAU,EACN,CAAAZ,EAAW,KAAK,mBAAmBQ,EAAKI,CAAM,GAFZC,EAAKL,EAAII,GAAS,CAGxD,IAAMK,EAAMjB,EAAW,KAAK,iBAAiBQ,EAAKG,EAAQC,CAAM,EAEhE,GAAIK,IAAQ,KAAM,MAClB,IAAMJ,EAAKL,EAAIS,GACTqD,EAAarD,GAAOL,EAASD,GAEnC,GAAK,KAAK,aAcH,GAAIE,GAAMA,IAAO;AAAA,GAAQyD,EAAa,KAAK,YAAa,CAC7D,GAAI9D,EAAIS,KAAS,IAAK,MAEtB,GAAI,CAAC,KAAK,MAAO,CAEf,IAAMyB,EAAM,sDADAyB,EAAW,iCAAmC,eAE1D,KAAK,MAAQ,IAAInE,EAAW,kBAAkB,KAAM0C,CAAG,CACzD,CACF,UApBMlC,EAAIS,KAAS;AAAA,EAAM,CAErB,GAAIqD,EAAaD,EAAgB,CAC/B,IAAM3B,EAAM,kGACZ,KAAK,MAAQ,IAAI1C,EAAW,kBAAkB,KAAM0C,CAAG,CACzD,CAEA,KAAK,YAAc4B,CACrB,MAAWA,EAAaD,IAEtBA,EAAiBC,GAYjB9D,EAAIS,KAAS;AAAA,EACfL,EAASK,EAETL,EAASwD,EAAWpE,EAAW,KAAK,UAAUQ,EAAKS,CAAG,CAE1D,CAEA,OAAI,KAAK,WAAasC,EAAM,OAC1B3C,EAASJ,EAAI4D,GAAYA,EAAW,EAAIA,GAG1C,KAAK,WAAa,IAAIpE,EAAW,MAAMG,EAAQ,EAAGS,CAAM,EACjDA,CACT,CAuBA,MAAMV,EAASC,EAAO,CACpB,KAAK,QAAUD,EACf,GAAM,CACJ,IAAAM,CACF,EAAIN,EACAU,EAAS,KAAK,iBAAiBT,CAAK,EACxC,OAAAS,EAASZ,EAAW,KAAK,gBAAgBQ,EAAKI,CAAM,EACpDA,EAAS,KAAK,aAAaA,CAAM,EACjCA,EAAS,KAAK,gBAAgBA,CAAM,EAC7BA,CACT,CAEA,cAAcS,EAAIT,EAAQ,CACxB,OAAAA,EAAS,MAAM,cAAcS,EAAIT,CAAM,EAChC,KAAK,OAAS,KAAK,OAAO,aAAaS,EAAIT,CAAM,EAAIA,CAC9D,CAEF,EAEM2D,GAAN,cAA6BvE,EAAW,IAAK,CAC3C,YAAYK,EAAMC,EAAO,CACvB,MAAMD,EAAMC,CAAK,EACjB,KAAK,MAAQ,IACf,CAEA,mBAAmBkE,EAAM,KAAK,MAAM,OAAQ,CAC1C,IAAMlD,EAAO,KAAK,MAAMkD,EAAM,GAC9B,MAAO,CAAC,CAAClD,IAASA,EAAK,UAAYA,EAAK,OAAStB,EAAW,KAAK,SAAW,KAAK,mBAAmBwE,EAAM,CAAC,EAC7G,CAQA,MAAMtE,EAASC,EAAO,CACpB,KAAK,QAAUD,EACf,GAAM,CACJ,UAAAK,EACA,IAAAC,CACF,EAAIN,EACA,CACF,OAAAS,EACA,UAAAD,CACF,EAAIR,EACAuE,EAAOjE,EAAIL,GAEf,KAAK,MAAQ,CAAC,CACZ,KAAAsE,EACA,OAAQtE,CACV,CAAC,EACD,IAAIS,EAASZ,EAAW,KAAK,gBAAgBQ,EAAKL,EAAQ,CAAC,EAG3D,IAFAsE,EAAOjE,EAAII,GAEJ6D,GAAQA,IAAS,KAAOA,IAAS,KAAK,CAC3C,OAAQA,OACD;AAAA,EACH,CACE/D,EAAYE,EAAS,EACrB,IAAMM,EAAQlB,EAAW,KAAK,gBAAgBQ,EAAKE,CAAS,EAE5D,GAAIF,EAAIU,KAAW;AAAA,EAAM,CACvB,IAAMF,EAAY,IAAIf,EACtBS,EAAYM,EAAU,MAAM,CAC1B,IAAAR,CACF,EAAGE,CAAS,EACZ,KAAK,MAAM,KAAKM,CAAS,CAC3B,CAIA,GAFAJ,EAASZ,EAAW,KAAK,YAAYQ,EAAKE,CAAS,EAE/CE,GAAUF,EAAYC,IACxB8D,EAAOjE,EAAII,GAEPA,EAASF,EAAYC,GAAU8D,IAAS,KAAOA,IAAS,KAAK,CAC/D,IAAM/B,EAAM,8CACZ,KAAK,MAAQ,IAAI1C,EAAW,kBAAkB,KAAM0C,CAAG,CACzD,CAEJ,CACA,UAEG,IAED,KAAK,MAAM,KAAK,CACd,KAAA+B,EACA,OAAA7D,CACF,CAAC,EACDA,GAAU,EAEZ,UAEG,IACH,CACE,IAAM4B,EAAU,IAAId,EACpBd,EAAS4B,EAAQ,MAAM,CACrB,IAAAhC,CACF,EAAGI,CAAM,EACT,KAAK,MAAM,KAAK4B,CAAO,CACzB,CACA,UAEG,QACA,IACH,CACE,IAAMC,EAAOjC,EAAII,EAAS,GAE1B,GAAI6B,IAAS;AAAA,GAAQA,IAAS,KAAQA,IAAS,KAAOA,IAAS,KAC/DgC,IAAS,KAAO,KAAK,mBAAmB,EAAG,CACzC,KAAK,MAAM,KAAK,CACd,KAAAA,EACA,OAAA7D,CACF,CAAC,EACDA,GAAU,EACV,KACF,CACF,SAIA,CACE,IAAMU,EAAOf,EAAU,CACrB,YAAa,GACb,aAAc,GACd,OAAQ,GACR,OAAQ,GACR,UAAAG,EACA,OAAQ,IACV,EAAGE,CAAM,EAET,GAAI,CAACU,EAEH,YAAK,WAAa,IAAItB,EAAW,MAAMG,EAAOS,CAAM,EAC7CA,EAGT,KAAK,MAAM,KAAKU,CAAI,EACpBV,EAASZ,EAAW,KAAK,gBAAgBQ,EAAKc,EAAK,MAAM,GAAG,CAC9D,EAGJV,EAASZ,EAAW,KAAK,gBAAgBQ,EAAKI,CAAM,EACpD6D,EAAOjE,EAAII,EACb,CAEA,YAAK,WAAa,IAAIZ,EAAW,MAAMG,EAAOS,EAAS,CAAC,EAEpD6D,IACF,KAAK,MAAM,KAAK,CACd,KAAAA,EACA,OAAA7D,CACF,CAAC,EACDA,EAASZ,EAAW,KAAK,gBAAgBQ,EAAKI,EAAS,CAAC,EACxDA,EAAS,KAAK,aAAaA,CAAM,GAG5BA,CACT,CAEA,cAAcS,EAAIT,EAAQ,CACxB,OAAAA,EAAS,MAAM,cAAcS,EAAIT,CAAM,EACvC,KAAK,MAAM,QAAQU,GAAQ,CACzB,GAAIA,aAAgBtB,EAAW,KAC7BY,EAASU,EAAK,cAAcD,EAAIT,CAAM,UAC7BS,EAAG,SAAW,EACvBC,EAAK,WAAaA,EAAK,WAClB,CACL,IAAIU,EAAIpB,EAER,KAAOoB,EAAIX,EAAG,QACR,EAAAA,EAAGW,GAAKV,EAAK,SAAmB,EAAEU,EAGxCV,EAAK,WAAaA,EAAK,OAASU,EAChCpB,EAASoB,CACX,CACF,CAAC,EACMpB,CACT,CAEA,UAAW,CACT,GAAM,CACJ,QAAS,CACP,IAAAJ,CACF,EACA,MAAAW,EACA,MAAAI,EACA,MAAAC,CACF,EAAI,KACJ,GAAIA,GAAS,KAAM,OAAOA,EAC1B,IAAMkD,EAAQvD,EAAM,OAAO0B,GAAQA,aAAgB7C,EAAW,IAAI,EAC9DyB,EAAM,GACNU,EAAUZ,EAAM,MACpB,OAAAmD,EAAM,QAAQpD,GAAQ,CACpB,IAAMqD,EAASnE,EAAI,MAAM2B,EAASb,EAAK,MAAM,KAAK,EAClDa,EAAUb,EAAK,MAAM,IACrBG,GAAOkD,EAAS,OAAOrD,CAAI,EAEvBG,EAAIA,EAAI,OAAS,KAAO;AAAA,GAAQjB,EAAI2B,EAAU,KAAO;AAAA,GAAQ3B,EAAI2B,KAAa;AAAA,IAIhFA,GAAW,EAEf,CAAC,EACDV,GAAOjB,EAAI,MAAM2B,EAASZ,EAAM,GAAG,EAC5BvB,EAAW,KAAK,oBAAoBQ,EAAKe,EAAM,IAAKE,CAAG,CAChE,CAEF,EAEMmD,GAAN,cAA0B5E,EAAW,IAAK,CACxC,OAAO,WAAWQ,EAAKI,EAAQ,CAC7B,IAAIC,EAAKL,EAAII,GAEb,KAAOC,GAAMA,IAAO,KAClBD,GAAUC,IAAO,KAAO,EAAI,EAC5BA,EAAKL,EAAII,GAGX,OAAOA,EAAS,CAClB,CAMA,IAAI,UAAW,CACb,GAAI,CAAC,KAAK,YAAc,CAAC,KAAK,QAAS,OAAO,KAC9C,IAAMiE,EAAS,CAAC,EACV,CACJ,MAAA1E,EACA,IAAAc,CACF,EAAI,KAAK,WACH,CACJ,OAAAN,EACA,IAAAH,CACF,EAAI,KAAK,QACLA,EAAIS,EAAM,KAAO,KAAK4D,EAAO,KAAK,IAAI7E,EAAW,gBAAgB,KAAM,wBAAwB,CAAC,EAGpG,IAAIyB,EAAM,GAEV,QAASO,EAAI7B,EAAQ,EAAG6B,EAAIf,EAAM,EAAG,EAAEe,EAAG,CACxC,IAAMnB,EAAKL,EAAIwB,GAEf,GAAInB,IAAO;AAAA,EAAM,CACXb,EAAW,KAAK,mBAAmBQ,EAAKwB,EAAI,CAAC,GAAG6C,EAAO,KAAK,IAAI7E,EAAW,kBAAkB,KAAM,mEAAmE,CAAC,EAC3K,GAAM,CACJ,KAAA8E,EACA,OAAAlE,EACA,MAAAmE,CACF,EAAI/E,EAAW,KAAK,YAAYQ,EAAKwB,EAAGrB,CAAM,EAC9Cc,GAAOqD,EACP9C,EAAIpB,EACAmE,GAAOF,EAAO,KAAK,IAAI7E,EAAW,kBAAkB,KAAM,mEAAmE,CAAC,CACpI,SAAWa,IAAO,KAGhB,OAFAmB,GAAK,EAEGxB,EAAIwB,QACL,IACHP,GAAO,KACP,UAGG,IACHA,GAAO,OACP,UAGG,IACHA,GAAO,KACP,UAGG,IACHA,GAAO,OACP,UAGG,IACHA,GAAO,KACP,UAGG,IACHA,GAAO;AAAA,EACP,UAGG,IACHA,GAAO,KACP,UAGG,IACHA,GAAO,IACP,UAGG,IACHA,GAAO,KACP,UAGG,IACHA,GAAO,OACP,UAGG,IACHA,GAAO,OACP,UAGG,IACHA,GAAO,SACP,UAGG,IACHA,GAAO,SACP,UAGG,IACHA,GAAO,IACP,UAEG,IACHA,GAAO,IACP,UAEG,IACHA,GAAO,IACP,UAEG,KACHA,GAAO,KACP,UAEG,IACHA,GAAO,IACP,UAEG,IACHA,GAAO,KAAK,cAAcO,EAAI,EAAG,EAAG6C,CAAM,EAC1C7C,GAAK,EACL,UAEG,IACHP,GAAO,KAAK,cAAcO,EAAI,EAAG,EAAG6C,CAAM,EAC1C7C,GAAK,EACL,UAEG,IACHP,GAAO,KAAK,cAAcO,EAAI,EAAG,EAAG6C,CAAM,EAC1C7C,GAAK,EACL,UAEG;AAAA,EAEH,KAAOxB,EAAIwB,EAAI,KAAO,KAAOxB,EAAIwB,EAAI,KAAO,KAAMA,GAAK,EAEvD,cAGA6C,EAAO,KAAK,IAAI7E,EAAW,gBAAgB,KAAM,2BAA2BQ,EAAI,OAAOwB,EAAI,EAAG,CAAC,GAAG,CAAC,EACnGP,GAAO,KAAOjB,EAAIwB,WAEbnB,IAAO,KAAOA,IAAO,IAAM,CAEpC,IAAMmE,EAAUhD,EACZS,EAAOjC,EAAIwB,EAAI,GAEnB,KAAOS,IAAS,KAAOA,IAAS,KAC9BT,GAAK,EACLS,EAAOjC,EAAIwB,EAAI,GAGbS,IAAS;AAAA,IAAMhB,GAAOO,EAAIgD,EAAUxE,EAAI,MAAMwE,EAAShD,EAAI,CAAC,EAAInB,EACtE,MACEY,GAAOZ,CAEX,CAEA,OAAOgE,EAAO,OAAS,EAAI,CACzB,OAAAA,EACA,IAAApD,CACF,EAAIA,CACN,CAEA,cAAcb,EAAQqE,EAAQJ,EAAQ,CACpC,GAAM,CACJ,IAAArE,CACF,EAAI,KAAK,QACH0E,EAAK1E,EAAI,OAAOI,EAAQqE,CAAM,EAE9BE,EADKD,EAAG,SAAWD,GAAU,iBAAiB,KAAKC,CAAE,EACzC,SAASA,EAAI,EAAE,EAAI,IAErC,OAAI,MAAMC,CAAI,GACZN,EAAO,KAAK,IAAI7E,EAAW,gBAAgB,KAAM,2BAA2BQ,EAAI,OAAOI,EAAS,EAAGqE,EAAS,CAAC,GAAG,CAAC,EAC1GzE,EAAI,OAAOI,EAAS,EAAGqE,EAAS,CAAC,GAGnC,OAAO,cAAcE,CAAI,CAClC,CAUA,MAAMjF,EAASC,EAAO,CACpB,KAAK,QAAUD,EACf,GAAM,CACJ,IAAAM,CACF,EAAIN,EACAU,EAASgE,GAAY,WAAWpE,EAAKL,EAAQ,CAAC,EAClD,YAAK,WAAa,IAAIH,EAAW,MAAMG,EAAOS,CAAM,EACpDA,EAASZ,EAAW,KAAK,gBAAgBQ,EAAKI,CAAM,EACpDA,EAAS,KAAK,aAAaA,CAAM,EAC1BA,CACT,CAEF,EAEMwE,GAAN,cAA0BpF,EAAW,IAAK,CACxC,OAAO,WAAWQ,EAAKI,EAAQ,CAC7B,IAAIC,EAAKL,EAAII,GAEb,KAAOC,GACL,GAAIA,IAAO,IAAK,CACd,GAAIL,EAAII,EAAS,KAAO,IAAK,MAC7BC,EAAKL,EAAII,GAAU,EACrB,MACEC,EAAKL,EAAII,GAAU,GAIvB,OAAOA,EAAS,CAClB,CAMA,IAAI,UAAW,CACb,GAAI,CAAC,KAAK,YAAc,CAAC,KAAK,QAAS,OAAO,KAC9C,IAAMiE,EAAS,CAAC,EACV,CACJ,MAAA1E,EACA,IAAAc,CACF,EAAI,KAAK,WACH,CACJ,OAAAN,EACA,IAAAH,CACF,EAAI,KAAK,QACLA,EAAIS,EAAM,KAAO,KAAK4D,EAAO,KAAK,IAAI7E,EAAW,gBAAgB,KAAM,wBAAwB,CAAC,EACpG,IAAIyB,EAAM,GAEV,QAASO,EAAI7B,EAAQ,EAAG6B,EAAIf,EAAM,EAAG,EAAEe,EAAG,CACxC,IAAMnB,EAAKL,EAAIwB,GAEf,GAAInB,IAAO;AAAA,EAAM,CACXb,EAAW,KAAK,mBAAmBQ,EAAKwB,EAAI,CAAC,GAAG6C,EAAO,KAAK,IAAI7E,EAAW,kBAAkB,KAAM,mEAAmE,CAAC,EAC3K,GAAM,CACJ,KAAA8E,EACA,OAAAlE,EACA,MAAAmE,CACF,EAAI/E,EAAW,KAAK,YAAYQ,EAAKwB,EAAGrB,CAAM,EAC9Cc,GAAOqD,EACP9C,EAAIpB,EACAmE,GAAOF,EAAO,KAAK,IAAI7E,EAAW,kBAAkB,KAAM,mEAAmE,CAAC,CACpI,SAAWa,IAAO,IAChBY,GAAOZ,EACPmB,GAAK,EACDxB,EAAIwB,KAAO,KAAK6C,EAAO,KAAK,IAAI7E,EAAW,gBAAgB,KAAM,iDAAiD,CAAC,UAC9Ga,IAAO,KAAOA,IAAO,IAAM,CAEpC,IAAMmE,EAAUhD,EACZS,EAAOjC,EAAIwB,EAAI,GAEnB,KAAOS,IAAS,KAAOA,IAAS,KAC9BT,GAAK,EACLS,EAAOjC,EAAIwB,EAAI,GAGbS,IAAS;AAAA,IAAMhB,GAAOO,EAAIgD,EAAUxE,EAAI,MAAMwE,EAAShD,EAAI,CAAC,EAAInB,EACtE,MACEY,GAAOZ,CAEX,CAEA,OAAOgE,EAAO,OAAS,EAAI,CACzB,OAAAA,EACA,IAAApD,CACF,EAAIA,CACN,CAUA,MAAMvB,EAASC,EAAO,CACpB,KAAK,QAAUD,EACf,GAAM,CACJ,IAAAM,CACF,EAAIN,EACAU,EAASwE,GAAY,WAAW5E,EAAKL,EAAQ,CAAC,EAClD,YAAK,WAAa,IAAIH,EAAW,MAAMG,EAAOS,CAAM,EACpDA,EAASZ,EAAW,KAAK,gBAAgBQ,EAAKI,CAAM,EACpDA,EAAS,KAAK,aAAaA,CAAM,EAC1BA,CACT,CAEF,EAEA,SAASyE,GAAchF,EAAMC,EAAO,CAClC,OAAQD,QACDL,EAAW,KAAK,MACnB,OAAO,IAAIsD,GAAMjD,EAAMC,CAAK,OAEzBN,EAAW,KAAK,kBAChBA,EAAW,KAAK,cACnB,OAAO,IAAIwD,GAAWnD,EAAMC,CAAK,OAE9BN,EAAW,KAAK,cAChBA,EAAW,KAAK,SACnB,OAAO,IAAIuE,GAAelE,EAAMC,CAAK,OAElCN,EAAW,KAAK,aAChBA,EAAW,KAAK,eAChBA,EAAW,KAAK,SACnB,OAAO,IAAII,GAAeC,EAAMC,CAAK,OAElCN,EAAW,KAAK,aAChBA,EAAW,KAAK,MACnB,OAAO,IAAIA,EAAW,WAAWK,EAAMC,CAAK,OAEzCN,EAAW,KAAK,aACnB,OAAO,IAAI4E,GAAYvE,EAAMC,CAAK,OAE/BN,EAAW,KAAK,aACnB,OAAO,IAAIoF,GAAY/E,EAAMC,CAAK,UAKlC,OAAO,KAGb,CAYA,IAAMgF,EAAN,KAAmB,CACjB,OAAO,UAAU9E,EAAKI,EAAQ2E,EAAQ,CACpC,OAAQ/E,EAAII,QACL,IACH,OAAOZ,EAAW,KAAK,UAEpB,IACH,OAAOA,EAAW,KAAK,iBAEpB,IACH,OAAOA,EAAW,KAAK,kBAEpB,IACH,OAAOA,EAAW,KAAK,aAEpB,IACH,OAAOA,EAAW,KAAK,aAEpB,IACH,MAAO,CAACuF,GAAUvF,EAAW,KAAK,QAAQQ,EAAKI,EAAS,EAAG,EAAI,EAAIZ,EAAW,KAAK,QAAUA,EAAW,KAAK,UAE1G,IACH,MAAO,CAACuF,GAAUvF,EAAW,KAAK,QAAQQ,EAAKI,EAAS,EAAG,EAAI,EAAIZ,EAAW,KAAK,UAAYA,EAAW,KAAK,UAE5G,IACH,MAAO,CAACuF,GAAUvF,EAAW,KAAK,QAAQQ,EAAKI,EAAS,EAAG,EAAI,EAAIZ,EAAW,KAAK,SAAWA,EAAW,KAAK,UAE3G,IACH,OAAOA,EAAW,KAAK,iBAEpB,IACH,OAAOA,EAAW,KAAK,qBAGvB,OAAOA,EAAW,KAAK,MAE7B,CAEA,YAAYwF,EAAO,CAAC,EAAG,CACrB,YAAA/E,EACA,aAAAgF,EACA,OAAAF,EACA,OAAA5E,EACA,UAAAD,EACA,OAAAgF,CACF,EAAI,CAAC,EAAG,CACN1F,EAAW,gBAAgB,KAAM,YAAa,CAAC2F,EAASxF,IAAU,CAChE,GAAIH,EAAW,KAAK,mBAAmB,KAAK,IAAKG,CAAK,EAAG,OAAO,KAChE,IAAMD,EAAU,IAAIoF,EAAa,KAAMK,CAAO,EACxC,CACJ,MAAArF,EACA,KAAAD,EACA,WAAAuF,CACF,EAAI1F,EAAQ,WAAWC,CAAK,EACtBmB,EAAO+D,GAAchF,EAAMC,CAAK,EAClCM,EAASU,EAAK,MAAMpB,EAAS0F,CAAU,EAa3C,GAZAtE,EAAK,MAAQ,IAAItB,EAAW,MAAMG,EAAOS,CAAM,EAG3CA,GAAUT,IAGZmB,EAAK,MAAQ,IAAI,MAAM,mCAAmC,EAC1DA,EAAK,MAAM,SAAWV,EACtBU,EAAK,MAAM,OAASA,EACpBA,EAAK,MAAM,IAAMnB,EAAQ,GAGvBD,EAAQ,qBAAqBoB,CAAI,EAAG,CAClC,CAACA,EAAK,OAAS,CAACpB,EAAQ,aAAeA,EAAQ,OAAO,OAASF,EAAW,KAAK,WACjFsB,EAAK,MAAQ,IAAItB,EAAW,gBAAgBsB,EAAM,uFAAuF,GAG3I,IAAMuE,EAAa,IAAIhE,EAAWP,CAAI,EACtC,OAAAV,EAASiF,EAAW,MAAM,IAAIP,EAAapF,CAAO,EAAGU,CAAM,EAC3DiF,EAAW,MAAQ,IAAI7F,EAAW,MAAMG,EAAOS,CAAM,EAC9CiF,CACT,CAEA,OAAOvE,CACT,CAAC,EAED,KAAK,YAAcb,IAAoC+E,EAAK,aAAe,IAC3E,KAAK,aAAeC,IAAsCD,EAAK,cAAgB,IAC/E,KAAK,OAASD,IAA0BC,EAAK,QAAU,IACvD,KAAK,OAAS7E,GAA0B6E,EAAK,OAC7C,KAAK,UAAY9E,GAAgC8E,EAAK,UACtD,KAAK,OAASE,IAA0BF,EAAK,QAAU,CAAC,GACxD,KAAK,KAAOA,EAAK,KACjB,KAAK,IAAMA,EAAK,GAClB,CAEA,qBAAqBlE,EAAM,CACzB,GAAM,CACJ,aAAAmE,EACA,OAAAF,EACA,IAAA/E,CACF,EAAI,KACJ,GAAIiF,GAAgBF,EAAQ,MAAO,GACnC,GAAIjE,aAAgBlB,GAAgB,MAAO,GAE3C,IAAIQ,EAASU,EAAK,MAAM,IACxB,OAAId,EAAII,KAAY;AAAA,GAAQJ,EAAII,EAAS,KAAO;AAAA,EAAa,IAC7DA,EAASZ,EAAW,KAAK,gBAAgBQ,EAAKI,CAAM,EAC7CJ,EAAII,KAAY,IACzB,CAIA,WAAWA,EAAQ,CACjB,GAAM,CACJ,OAAA2E,EACA,OAAAG,EACA,IAAAlF,CACF,EAAI,KACEF,EAAQ,CAAC,EACXwF,EAAe,GACnBlF,EAAS,KAAK,YAAcZ,EAAW,KAAK,YAAYQ,EAAKI,CAAM,EAAIZ,EAAW,KAAK,gBAAgBQ,EAAKI,CAAM,EAClH,IAAIC,EAAKL,EAAII,GAEb,KAAOC,IAAOb,EAAW,KAAK,QAAUa,IAAOb,EAAW,KAAK,SAAWa,IAAOb,EAAW,KAAK,KAAOa,IAAO;AAAA,GAAM,CACnH,GAAIA,IAAO;AAAA,EAAM,CACf,IAAIkF,EAAQnF,EACRF,EAEJ,GACEA,EAAYqF,EAAQ,EACpBA,EAAQ/F,EAAW,KAAK,YAAYQ,EAAKE,CAAS,QAC3CF,EAAIuF,KAAW;AAAA,GAExB,IAAMC,EAAaD,GAASrF,EAAY,KAAK,QACvCuF,EAAsBP,EAAO,OAAS1F,EAAW,KAAK,UAAY0F,EAAO,QAAQ,YACvF,GAAIlF,EAAIuF,KAAW,KAAO,CAAC/F,EAAW,KAAK,mBAAmBQ,EAAIuF,GAAQC,EAAY,CAACC,CAAmB,EAAG,MAC7G,KAAK,YAAc,GACnB,KAAK,UAAYvF,EACjBoF,EAAe,GACflF,EAASmF,CACX,SAAWlF,IAAOb,EAAW,KAAK,QAAS,CACzC,IAAMiB,EAAMjB,EAAW,KAAK,UAAUQ,EAAKI,EAAS,CAAC,EACrDN,EAAM,KAAK,IAAIN,EAAW,MAAMY,EAAQK,CAAG,CAAC,EAC5CL,EAASK,CACX,KAAO,CACL,IAAIA,EAAMjB,EAAW,KAAK,gBAAgBQ,EAAKI,EAAS,CAAC,EAErDC,IAAOb,EAAW,KAAK,KAAOQ,EAAIS,KAAS,KAAO,yDAAyD,KAAKT,EAAI,MAAMI,EAAS,EAAGK,EAAM,EAAE,CAAC,IAKjJA,EAAMjB,EAAW,KAAK,gBAAgBQ,EAAKS,EAAM,CAAC,GAGpDX,EAAM,KAAK,IAAIN,EAAW,MAAMY,EAAQK,CAAG,CAAC,EAC5C6E,EAAe,GACflF,EAASZ,EAAW,KAAK,gBAAgBQ,EAAKS,CAAG,CACnD,CAEAJ,EAAKL,EAAII,EACX,CAGIkF,GAAgBjF,IAAO,KAAOb,EAAW,KAAK,QAAQQ,EAAKI,EAAS,EAAG,EAAI,IAAGA,GAAU,GAC5F,IAAMP,EAAOiF,EAAa,UAAU9E,EAAKI,EAAQ2E,CAAM,EACvD,MAAO,CACL,MAAAjF,EACA,KAAAD,EACA,WAAYO,CACd,CACF,CASF,EAGA,SAASsF,GAAM1F,EAAK,CAClB,IAAMa,EAAK,CAAC,EAERb,EAAI,QAAQ,IAAI,IAAM,KACxBA,EAAMA,EAAI,QAAQ,SAAU,CAAC2F,EAAOvF,KAC9BuF,EAAM,OAAS,GAAG9E,EAAG,KAAKT,CAAM,EAC7B;AAAA,EACR,GAGH,IAAMwF,EAAY,CAAC,EACfxF,EAAS,EAEb,EAAG,CACD,IAAMyF,EAAM,IAAIrD,GACV9C,EAAU,IAAIoF,EAAa,CAC/B,IAAA9E,CACF,CAAC,EACDI,EAASyF,EAAI,MAAMnG,EAASU,CAAM,EAClCwF,EAAU,KAAKC,CAAG,CACpB,OAASzF,EAASJ,EAAI,QAEtB,OAAA4F,EAAU,cAAgB,IAAM,CAC9B,GAAI/E,EAAG,SAAW,EAAG,MAAO,GAE5B,QAAS,EAAI,EAAG,EAAIA,EAAG,OAAQ,EAAE,EAAGA,EAAG,IAAM,EAE7C,IAAIiF,EAAW,EAEf,QAAS,EAAI,EAAG,EAAIF,EAAU,OAAQ,EAAE,EACtCE,EAAWF,EAAU,GAAG,cAAc/E,EAAIiF,CAAQ,EAGpD,OAAAjF,EAAG,OAAO,EAAGA,EAAG,MAAM,EACf,EACT,EAEA+E,EAAU,SAAW,IAAMA,EAAU,KAAK;AAAA,CAAO,EAE1CA,CACT,CAEArG,GAAQ,MAAQmG,KCxtDhB,IAAAK,GAAAC,EAAAC,GAAA,cAEA,IAAIC,EAAa,IAEjB,SAASC,GAAiBC,EAAKC,EAAQC,EAAS,CAC9C,OAAKA,EAEE,IADIA,EAAQ,QAAQ,YAAa,KAAKD,IAAS;AAAA,EACpCA,IAASD,IAFNA,CAGvB,CACA,SAASG,GAAWH,EAAKC,EAAQC,EAAS,CACxC,OAAQA,EAAgBA,EAAQ,QAAQ;AAAA,CAAI,IAAM,GAAK,GAAGF,MAAQE,IAAY,GAAGF;AAAA,EAAUE,EAAQ,QAAQ,MAAO,GAAGD,GAAU,KAAK,EAAlHD,CACpB,CAEA,IAAMI,EAAN,KAAW,CAAC,EAEZ,SAASC,EAAOC,EAAOC,EAAKC,EAAK,CAC/B,GAAI,MAAM,QAAQF,CAAK,EAAG,OAAOA,EAAM,IAAI,CAACG,EAAGC,IAAML,EAAOI,EAAG,OAAOC,CAAC,EAAGF,CAAG,CAAC,EAE9E,GAAIF,GAAS,OAAOA,EAAM,QAAW,WAAY,CAC/C,IAAMK,EAASH,GAAOA,EAAI,SAAWA,EAAI,QAAQ,IAAIF,CAAK,EACtDK,IAAQH,EAAI,SAAWI,GAAO,CAChCD,EAAO,IAAMC,EACb,OAAOJ,EAAI,QACb,GACA,IAAMI,EAAMN,EAAM,OAAOC,EAAKC,CAAG,EACjC,OAAIG,GAAUH,EAAI,UAAUA,EAAI,SAASI,CAAG,EACrCA,CACT,CAEA,OAAK,CAACJ,GAAO,CAACA,EAAI,OAAS,OAAOF,GAAU,SAAiB,OAAOA,CAAK,EAClEA,CACT,CAEA,IAAMO,EAAN,cAAqBT,CAAK,CACxB,YAAYE,EAAO,CACjB,MAAM,EACN,KAAK,MAAQA,CACf,CAEA,OAAOC,EAAKC,EAAK,CACf,OAAOA,GAAOA,EAAI,KAAO,KAAK,MAAQH,EAAO,KAAK,MAAOE,EAAKC,CAAG,CACnE,CAEA,UAAW,CACT,OAAO,OAAO,KAAK,KAAK,CAC1B,CAEF,EAEA,SAASM,GAAmBC,EAAQC,EAAMV,EAAO,CAC/C,IAAIG,EAAIH,EAER,QAASI,EAAIM,EAAK,OAAS,EAAGN,GAAK,EAAG,EAAEA,EAAG,CACzC,IAAMO,EAAID,EAAKN,GAEf,GAAI,OAAO,UAAUO,CAAC,GAAKA,GAAK,EAAG,CACjC,IAAMC,EAAI,CAAC,EACXA,EAAED,GAAKR,EACPA,EAAIS,CACN,KAAO,CACL,IAAM,EAAI,CAAC,EACX,OAAO,eAAe,EAAGD,EAAG,CAC1B,MAAOR,EACP,SAAU,GACV,WAAY,GACZ,aAAc,EAChB,CAAC,EACDA,EAAI,CACN,CACF,CAEA,OAAOM,EAAO,WAAWN,EAAG,EAAK,CACnC,CAGA,IAAMU,GAAcH,GAAQA,GAAQ,MAAQ,OAAOA,GAAS,UAAYA,EAAK,OAAO,UAAU,EAAE,KAAK,EAAE,KACjGI,EAAN,cAAyBhB,CAAK,CAC5B,YAAYW,EAAQ,CAClB,MAAM,EAENjB,EAAW,gBAAgB,KAAM,QAAS,CAAC,CAAC,EAE5C,KAAK,OAASiB,CAChB,CAEA,MAAMC,EAAMV,EAAO,CACjB,GAAIa,GAAYH,CAAI,EAAG,KAAK,IAAIV,CAAK,MAAO,CAC1C,GAAM,CAACe,KAAQC,CAAI,EAAIN,EACjBO,EAAO,KAAK,IAAIF,EAAK,EAAI,EAC/B,GAAIE,aAAgBH,EAAYG,EAAK,MAAMD,EAAMhB,CAAK,UAAWiB,IAAS,QAAa,KAAK,OAAQ,KAAK,IAAIF,EAAKP,GAAmB,KAAK,OAAQQ,EAAMhB,CAAK,CAAC,MAAO,OAAM,IAAI,MAAM,+BAA+Be,sBAAwBC,GAAM,CACpP,CACF,CAEA,SAAS,CAACD,KAAQC,CAAI,EAAG,CACvB,GAAIA,EAAK,SAAW,EAAG,OAAO,KAAK,OAAOD,CAAG,EAC7C,IAAME,EAAO,KAAK,IAAIF,EAAK,EAAI,EAC/B,GAAIE,aAAgBH,EAAY,OAAOG,EAAK,SAASD,CAAI,EAAO,MAAM,IAAI,MAAM,+BAA+BD,sBAAwBC,GAAM,CAC/I,CAEA,MAAM,CAACD,KAAQC,CAAI,EAAGE,EAAY,CAChC,IAAMD,EAAO,KAAK,IAAIF,EAAK,EAAI,EAC/B,OAAIC,EAAK,SAAW,EAAU,CAACE,GAAcD,aAAgBV,EAASU,EAAK,MAAQA,EAAiBA,aAAgBH,EAAaG,EAAK,MAAMD,EAAME,CAAU,EAAI,MAClK,CAEA,kBAAmB,CACjB,OAAO,KAAK,MAAM,MAAMD,GAAQ,CAC9B,GAAI,CAACA,GAAQA,EAAK,OAAS,OAAQ,MAAO,GAC1C,IAAME,EAAIF,EAAK,MACf,OAAOE,GAAK,MAAQA,aAAaZ,GAAUY,EAAE,OAAS,MAAQ,CAACA,EAAE,eAAiB,CAACA,EAAE,SAAW,CAACA,EAAE,GACrG,CAAC,CACH,CAEA,MAAM,CAACJ,KAAQC,CAAI,EAAG,CACpB,GAAIA,EAAK,SAAW,EAAG,OAAO,KAAK,IAAID,CAAG,EAC1C,IAAME,EAAO,KAAK,IAAIF,EAAK,EAAI,EAC/B,OAAOE,aAAgBH,EAAaG,EAAK,MAAMD,CAAI,EAAI,EACzD,CAEA,MAAM,CAACD,KAAQC,CAAI,EAAGhB,EAAO,CAC3B,GAAIgB,EAAK,SAAW,EAClB,KAAK,IAAID,EAAKf,CAAK,MACd,CACL,IAAMiB,EAAO,KAAK,IAAIF,EAAK,EAAI,EAC/B,GAAIE,aAAgBH,EAAYG,EAAK,MAAMD,EAAMhB,CAAK,UAAWiB,IAAS,QAAa,KAAK,OAAQ,KAAK,IAAIF,EAAKP,GAAmB,KAAK,OAAQQ,EAAMhB,CAAK,CAAC,MAAO,OAAM,IAAI,MAAM,+BAA+Be,sBAAwBC,GAAM,CACpP,CACF,CAKA,QAAS,CACP,OAAO,IACT,CAEA,SAASd,EAAK,CACZ,UAAAkB,EACA,UAAAC,EACA,MAAAC,EACA,WAAAC,CACF,EAAGC,EAAWC,EAAa,CACzB,GAAM,CACJ,OAAA9B,EACA,WAAA+B,EACA,UAAAC,CACF,EAAIzB,EACE0B,EAAS,KAAK,OAASpC,EAAW,KAAK,UAAY,KAAK,OAASA,EAAW,KAAK,UAAYU,EAAI,OACnG0B,IAAQL,GAAcG,GAC1B,IAAMG,EAAgBP,GAAS,KAAK,iBAAiB,EACrDpB,EAAM,OAAO,OAAO,CAAC,EAAGA,EAAK,CAC3B,cAAA2B,EACA,OAAQN,EACR,OAAAK,EACA,KAAM,IACR,CAAC,EACD,IAAIE,EAAY,GACZC,EAAqB,GACnBC,EAAQ,KAAK,MAAM,OAAO,CAACA,EAAOC,EAAM7B,IAAM,CAClD,IAAIR,EAEAqC,IACE,CAACH,GAAaG,EAAK,aAAaD,EAAM,KAAK,CAC7C,KAAM,UACN,IAAK,EACP,CAAC,EACGC,EAAK,eAAeA,EAAK,cAAc,MAAM,QAAQ,EAAE,QAAQC,IAAQ,CACzEF,EAAM,KAAK,CACT,KAAM,UACN,IAAK,IAAIE,IACX,CAAC,CACH,CAAC,EACGD,EAAK,UAASrC,EAAUqC,EAAK,SAC7BL,IAAW,CAACE,GAAaG,EAAK,aAAeA,EAAK,eAAiBA,EAAK,SAAWA,EAAK,MAAQA,EAAK,IAAI,eAAiBA,EAAK,IAAI,UAAYA,EAAK,QAAUA,EAAK,MAAM,eAAiBA,EAAK,MAAM,YAAWF,EAAqB,KAG3OD,EAAY,GACZ,IAAIpC,EAAMiC,EAAUM,EAAM/B,EAAK,IAAMN,EAAU,KAAM,IAAMkC,EAAY,EAAI,EAC3E,OAAIF,GAAU,CAACG,GAAsBrC,EAAI,SAAS;AAAA,CAAI,IAAGqC,EAAqB,IAC1EH,GAAUxB,EAAI,KAAK,MAAM,OAAS,IAAGV,GAAO,KAChDA,EAAMG,GAAWH,EAAK6B,EAAY3B,CAAO,EACrCkC,IAAclC,GAAWgC,KAASE,EAAY,IAClDE,EAAM,KAAK,CACT,KAAM,OACN,IAAAtC,CACF,CAAC,EACMsC,CACT,EAAG,CAAC,CAAC,EACDtC,EAEJ,GAAIsC,EAAM,SAAW,EACnBtC,EAAM2B,EAAU,MAAQA,EAAU,YACzBO,EAAQ,CACjB,GAAM,CACJ,MAAAO,EACA,IAAAC,CACF,EAAIf,EACEgB,EAAUL,EAAM,IAAIb,GAAKA,EAAE,GAAG,EAEpC,GAAIY,GAAsBM,EAAQ,OAAO,CAACC,EAAK5C,IAAQ4C,EAAM5C,EAAI,OAAS,EAAG,CAAC,EAAIoB,EAAW,8BAA+B,CAC1HpB,EAAMyC,EAEN,QAAWI,KAAKF,EACd3C,GAAO6C,EAAI;AAAA,EAAKb,IAAa/B,IAAS4C,IAAM;AAAA,EAG9C7C,GAAO;AAAA,EAAKC,IAASyC,GACvB,MACE1C,EAAM,GAAGyC,KAASE,EAAQ,KAAK,GAAG,KAAKD,GAE3C,KAAO,CACL,IAAMC,EAAUL,EAAM,IAAIZ,CAAS,EACnC1B,EAAM2C,EAAQ,MAAM,EAEpB,QAAWE,KAAKF,EAAS3C,GAAO6C,EAAI;AAAA,EAAK5C,IAAS4C,IAAM;AAAA,CAC1D,CAEA,OAAI,KAAK,SACP7C,GAAO;AAAA,EAAO,KAAK,QAAQ,QAAQ,MAAO,GAAGC,IAAS,EAClD6B,GAAWA,EAAU,GAChBM,GAAaL,GAAaA,EAAY,EAE1C/B,CACT,CAEF,EAEAF,EAAW,gBAAgBsB,EAAY,gCAAiC,EAAE,EAE1E,SAAS0B,GAAYzB,EAAK,CACxB,IAAI0B,EAAM1B,aAAeR,EAASQ,EAAI,MAAQA,EAC9C,OAAI0B,GAAO,OAAOA,GAAQ,WAAUA,EAAM,OAAOA,CAAG,GAC7C,OAAO,UAAUA,CAAG,GAAKA,GAAO,EAAIA,EAAM,IACnD,CAEA,IAAMC,EAAN,cAAsB5B,CAAW,CAC/B,IAAId,EAAO,CACT,KAAK,MAAM,KAAKA,CAAK,CACvB,CAEA,OAAOe,EAAK,CACV,IAAM0B,EAAMD,GAAYzB,CAAG,EAC3B,OAAI,OAAO0B,GAAQ,SAAiB,GACxB,KAAK,MAAM,OAAOA,EAAK,CAAC,EACzB,OAAS,CACtB,CAEA,IAAI1B,EAAKG,EAAY,CACnB,IAAMuB,EAAMD,GAAYzB,CAAG,EAC3B,GAAI,OAAO0B,GAAQ,SAAU,OAC7B,IAAME,EAAK,KAAK,MAAMF,GACtB,MAAO,CAACvB,GAAcyB,aAAcpC,EAASoC,EAAG,MAAQA,CAC1D,CAEA,IAAI5B,EAAK,CACP,IAAM0B,EAAMD,GAAYzB,CAAG,EAC3B,OAAO,OAAO0B,GAAQ,UAAYA,EAAM,KAAK,MAAM,MACrD,CAEA,IAAI1B,EAAKf,EAAO,CACd,IAAMyC,EAAMD,GAAYzB,CAAG,EAC3B,GAAI,OAAO0B,GAAQ,SAAU,MAAM,IAAI,MAAM,+BAA+B1B,IAAM,EAClF,KAAK,MAAM0B,GAAOzC,CACpB,CAEA,OAAO4C,EAAG1C,EAAK,CACb,IAAM2C,EAAM,CAAC,EACT3C,GAAOA,EAAI,UAAUA,EAAI,SAAS2C,CAAG,EACzC,IAAIzC,EAAI,EAER,QAAW6B,KAAQ,KAAK,MAAOY,EAAI,KAAK9C,EAAOkC,EAAM,OAAO7B,GAAG,EAAGF,CAAG,CAAC,EAEtE,OAAO2C,CACT,CAEA,SAAS3C,EAAKsB,EAAWC,EAAa,CACpC,OAAKvB,EACE,MAAM,SAASA,EAAK,CACzB,UAAWiB,GAAKA,EAAE,OAAS,UAAYA,EAAE,IAAM,KAAKA,EAAE,MACtD,UAAW,CACT,MAAO,IACP,IAAK,GACP,EACA,MAAO,GACP,YAAajB,EAAI,QAAU,IAAM,IACnC,EAAGsB,EAAWC,CAAW,EATR,KAAK,UAAU,IAAI,CAUtC,CAEF,EAEMqB,GAAe,CAAC/B,EAAKgC,EAAO7C,IAC5B6C,IAAU,KAAa,GACvB,OAAOA,GAAU,SAAiB,OAAOA,CAAK,EAC9ChC,aAAejB,GAAQI,GAAOA,EAAI,IAAYa,EAAI,SAAS,CAC7D,QAAS,OAAO,OAAO,IAAI,EAC3B,IAAKb,EAAI,IACT,OAAQ,GACR,WAAYA,EAAI,WAChB,OAAQ,GACR,eAAgB,GAChB,UAAWA,EAAI,SACjB,CAAC,EACM,KAAK,UAAU6C,CAAK,EAGvBC,EAAN,cAAmBlD,CAAK,CACtB,YAAYiB,EAAKf,EAAQ,KAAM,CAC7B,MAAM,EACN,KAAK,IAAMe,EACX,KAAK,MAAQf,EACb,KAAK,KAAOgD,EAAK,KAAK,IACxB,CAEA,IAAI,eAAgB,CAClB,OAAO,KAAK,eAAelD,EAAO,KAAK,IAAI,cAAgB,MAC7D,CAEA,IAAI,cAAcmD,EAAI,CAEpB,GADI,KAAK,KAAO,OAAM,KAAK,IAAM,IAAI1C,EAAO,IAAI,GAC5C,KAAK,eAAeT,EAAM,KAAK,IAAI,cAAgBmD,MAAQ,CAC7D,IAAMC,EAAM,gGACZ,MAAM,IAAI,MAAMA,CAAG,CACrB,CACF,CAEA,WAAWhD,EAAKiD,EAAK,CACnB,IAAMpC,EAAMhB,EAAO,KAAK,IAAK,GAAIG,CAAG,EAEpC,GAAIiD,aAAe,IAAK,CACtB,IAAMnD,EAAQD,EAAO,KAAK,MAAOgB,EAAKb,CAAG,EACzCiD,EAAI,IAAIpC,EAAKf,CAAK,CACpB,SAAWmD,aAAe,IACxBA,EAAI,IAAIpC,CAAG,MACN,CACL,IAAMqC,EAAYN,GAAa,KAAK,IAAK/B,EAAKb,CAAG,EAC3CF,EAAQD,EAAO,KAAK,MAAOqD,EAAWlD,CAAG,EAC3CkD,KAAaD,EAAK,OAAO,eAAeA,EAAKC,EAAW,CAC1D,MAAApD,EACA,SAAU,GACV,WAAY,GACZ,aAAc,EAChB,CAAC,EAAOmD,EAAIC,GAAapD,CAC3B,CAEA,OAAOmD,CACT,CAEA,OAAOP,EAAG1C,EAAK,CACb,IAAMmD,EAAOnD,GAAOA,EAAI,SAAW,IAAI,IAAQ,CAAC,EAChD,OAAO,KAAK,WAAWA,EAAKmD,CAAI,CAClC,CAEA,SAASnD,EAAKsB,EAAWC,EAAa,CACpC,GAAI,CAACvB,GAAO,CAACA,EAAI,IAAK,OAAO,KAAK,UAAU,IAAI,EAChD,GAAM,CACJ,OAAQoD,EACR,UAAAC,EACA,WAAAC,CACF,EAAItD,EAAI,IAAI,QACR,CACF,IAAAa,EACA,MAAAf,CACF,EAAI,KACAyD,EAAa1C,aAAejB,GAAQiB,EAAI,QAE5C,GAAIyC,EAAY,CACd,GAAIC,EACF,MAAM,IAAI,MAAM,kDAAkD,EAGpE,GAAI1C,aAAeD,EAAY,CAC7B,IAAMoC,EAAM,6DACZ,MAAM,IAAI,MAAMA,CAAG,CACrB,CACF,CAEA,IAAIQ,EAAc,CAACF,IAAe,CAACzC,GAAO0C,IAAe1C,aAAejB,EAAOiB,aAAeD,GAAcC,EAAI,OAASvB,EAAW,KAAK,cAAgBuB,EAAI,OAASvB,EAAW,KAAK,cAAgB,OAAOuB,GAAQ,WAC/M,CACJ,IAAA4C,EACA,OAAAhE,EACA,WAAA+B,EACA,UAAAC,CACF,EAAIzB,EACJA,EAAM,OAAO,OAAO,CAAC,EAAGA,EAAK,CAC3B,YAAa,CAACwD,EACd,OAAQ/D,EAAS+B,CACnB,CAAC,EACD,IAAII,EAAY,GACZpC,EAAMiC,EAAUZ,EAAKb,EAAK,IAAMuD,EAAa,KAAM,IAAM3B,EAAY,EAAI,EAG7E,GAFApC,EAAMG,GAAWH,EAAKQ,EAAI,OAAQuD,CAAU,EAExC,CAACC,GAAehE,EAAI,OAAS,KAAM,CACrC,GAAI8D,EAAY,MAAM,IAAI,MAAM,8EAA8E,EAC9GE,EAAc,EAChB,CAEA,GAAIxD,EAAI,eAAiB,CAACsD,EACxB,OAAI,KAAK,SACP9D,EAAMG,GAAWH,EAAKQ,EAAI,OAAQ,KAAK,OAAO,EAC1CsB,GAAWA,EAAU,GAChBM,GAAa,CAAC2B,GAAchC,GAAaA,EAAY,EAEzDvB,EAAI,QAAU,CAACwD,EAAchE,EAAM,KAAKA,IAGjDA,EAAMgE,EAAc,KAAKhE;AAAA,EAAQC,KAAY,GAAGD,KAE5C,KAAK,UAEPA,EAAMG,GAAWH,EAAKQ,EAAI,OAAQ,KAAK,OAAO,EAC1CsB,GAAWA,EAAU,GAG3B,IAAIoC,EAAM,GACNC,EAAe,KAEf7D,aAAiBF,GACfE,EAAM,cAAa4D,EAAM;AAAA,GAEzB5D,EAAM,gBAER4D,GAAO;AAAA,EADI5D,EAAM,cAAc,QAAQ,MAAO,GAAGE,EAAI,SAAS,KAIhE2D,EAAe7D,EAAM,SACZA,GAAS,OAAOA,GAAU,WACnCA,EAAQ2D,EAAI,OAAO,WAAW3D,EAAO,EAAI,GAG3CE,EAAI,YAAc,GACd,CAACwD,GAAe,CAAC,KAAK,SAAW1D,aAAiBO,IAAQL,EAAI,cAAgBR,EAAI,OAAS,GAC/FoC,EAAY,GAER,CAACyB,GAAaD,GAAc,GAAK,CAACpD,EAAI,QAAU,CAACwD,GAAe1D,aAAiB0C,GAAW1C,EAAM,OAASR,EAAW,KAAK,UAAY,CAACQ,EAAM,KAAO,CAAC2D,EAAI,QAAQ,QAAQ3D,CAAK,IAEjLE,EAAI,OAASA,EAAI,OAAO,OAAO,CAAC,GAGlC,IAAM4D,EAAWnC,EAAU3B,EAAOE,EAAK,IAAM2D,EAAe,KAAM,IAAM/B,EAAY,EAAI,EACpFiC,EAAK,IAET,OAAIH,GAAO,KAAK,QACdG,EAAK,GAAGH;AAAA,EAAQ1D,EAAI,SACX,CAACwD,GAAe1D,aAAiBc,GAEtC,EADSgD,EAAS,KAAO,KAAOA,EAAS,KAAO,MACvCA,EAAS,SAAS;AAAA,CAAI,KAAGC,EAAK;AAAA,EAAK7D,EAAI,UAC3C4D,EAAS,KAAO;AAAA,IAAMC,EAAK,IAElCjC,GAAa,CAAC+B,GAAgBpC,GAAaA,EAAY,EACpD5B,GAAWH,EAAMqE,EAAKD,EAAU5D,EAAI,OAAQ2D,CAAY,CACjE,CAEF,EAEArE,EAAW,gBAAgBwD,EAAM,OAAQ,CACvC,KAAM,OACN,WAAY,YACd,CAAC,EAED,IAAMgB,GAAgB,CAAC/C,EAAMgD,IAAY,CACvC,GAAIhD,aAAgBiD,EAAO,CACzB,IAAM7D,EAAS4D,EAAQ,IAAIhD,EAAK,MAAM,EACtC,OAAOZ,EAAO,MAAQA,EAAO,UAC/B,SAAWY,aAAgBH,EAAY,CACrC,IAAIqD,EAAQ,EAEZ,QAAWlC,KAAQhB,EAAK,MAAO,CAC7B,IAAMmD,EAAIJ,GAAc/B,EAAMgC,CAAO,EACjCG,EAAID,IAAOA,EAAQC,EACzB,CAEA,OAAOD,CACT,SAAWlD,aAAgB+B,EAAM,CAC/B,IAAMqB,EAAKL,GAAc/C,EAAK,IAAKgD,CAAO,EACpCK,EAAKN,GAAc/C,EAAK,MAAOgD,CAAO,EAC5C,OAAO,KAAK,IAAII,EAAIC,CAAE,CACxB,CAEA,MAAO,EACT,EAEMJ,EAAN,cAAoBpE,CAAK,CACvB,OAAO,UAAU,CACf,MAAAyE,EACA,OAAAC,CACF,EAAG,CACD,QAAAP,EACA,IAAAN,EACA,YAAAc,EACA,eAAAC,CACF,EAAG,CACD,IAAIrE,EAAS,OAAO,KAAK4D,CAAO,EAAE,KAAKrD,GAAKqD,EAAQrD,KAAO4D,CAAM,EAEjE,GADI,CAACnE,GAAUqE,IAAgBrE,EAASsD,EAAI,QAAQ,QAAQa,CAAM,GAAKb,EAAI,QAAQ,QAAQ,GACvFtD,EAAQ,MAAO,IAAIA,IAASoE,EAAc,IAAM,KACpD,IAAMvB,EAAMS,EAAI,QAAQ,QAAQa,CAAM,EAAI,uCAAyC,uCACnF,MAAM,IAAI,MAAM,GAAGtB,MAAQqB,IAAQ,CACrC,CAEA,YAAYC,EAAQ,CAClB,MAAM,EACN,KAAK,OAASA,EACd,KAAK,KAAOhF,EAAW,KAAK,KAC9B,CAEA,IAAI,IAAImF,EAAG,CACT,MAAM,IAAI,MAAM,8BAA8B,CAChD,CAEA,OAAO1E,EAAKC,EAAK,CACf,GAAI,CAACA,EAAK,OAAOH,EAAO,KAAK,OAAQE,EAAKC,CAAG,EAC7C,GAAM,CACJ,QAAA+D,EACA,cAAAW,CACF,EAAI1E,EACEG,EAAS4D,EAAQ,IAAI,KAAK,MAAM,EAGtC,GAAI,CAAC5D,GAAUA,EAAO,MAAQ,OAAW,CACvC,IAAM6C,EAAM,yDACZ,MAAI,KAAK,QAAe,IAAI1D,EAAW,mBAAmB,KAAK,QAAS0D,CAAG,EAAa,IAAI,eAAeA,CAAG,CAChH,CAEA,GAAI0B,GAAiB,IACnBvE,EAAO,OAAS,EACZA,EAAO,aAAe,IAAGA,EAAO,WAAa2D,GAAc,KAAK,OAAQC,CAAO,GAE/E5D,EAAO,MAAQA,EAAO,WAAauE,GAAe,CACpD,IAAM1B,EAAM,+DACZ,MAAI,KAAK,QAAe,IAAI1D,EAAW,mBAAmB,KAAK,QAAS0D,CAAG,EAAa,IAAI,eAAeA,CAAG,CAChH,CAGF,OAAO7C,EAAO,GAChB,CAIA,SAASH,EAAK,CACZ,OAAOgE,EAAM,UAAU,KAAMhE,CAAG,CAClC,CAEF,EAEAV,EAAW,gBAAgB0E,EAAO,UAAW,EAAI,EAEjD,SAASW,GAASC,EAAO/D,EAAK,CAC5B,IAAMJ,EAAII,aAAeR,EAASQ,EAAI,MAAQA,EAE9C,QAAW4B,KAAMmC,EACf,GAAInC,aAAcK,IACZL,EAAG,MAAQ5B,GAAO4B,EAAG,MAAQhC,GAC7BgC,EAAG,KAAOA,EAAG,IAAI,QAAUhC,GAAG,OAAOgC,CAK/C,CACA,IAAMoC,GAAN,cAAsBjE,CAAW,CAC/B,IAAIuC,EAAM2B,EAAW,CACd3B,EAAuCA,aAAgBL,IAAOK,EAAO,IAAIL,EAAKK,EAAK,KAAOA,EAAMA,EAAK,KAAK,GAApGA,EAAO,IAAIL,EAAKK,CAAI,EAC/B,IAAM4B,EAAOJ,GAAS,KAAK,MAAOxB,EAAK,GAAG,EACpC6B,EAAc,KAAK,QAAU,KAAK,OAAO,eAE/C,GAAID,EACF,GAAID,EAAWC,EAAK,MAAQ5B,EAAK,UAAW,OAAM,IAAI,MAAM,OAAOA,EAAK,iBAAiB,UAChF6B,EAAa,CACtB,IAAM,EAAI,KAAK,MAAM,UAAUjD,GAAQiD,EAAY7B,EAAMpB,CAAI,EAAI,CAAC,EAC9D,IAAM,GAAI,KAAK,MAAM,KAAKoB,CAAI,EAAO,KAAK,MAAM,OAAO,EAAG,EAAGA,CAAI,CACvE,MACE,KAAK,MAAM,KAAKA,CAAI,CAExB,CAEA,OAAOtC,EAAK,CACV,IAAM4B,EAAKkC,GAAS,KAAK,MAAO9D,CAAG,EACnC,OAAK4B,EACO,KAAK,MAAM,OAAO,KAAK,MAAM,QAAQA,CAAE,EAAG,CAAC,EAC5C,OAAS,EAFJ,EAGlB,CAEA,IAAI5B,EAAKG,EAAY,CACnB,IAAMyB,EAAKkC,GAAS,KAAK,MAAO9D,CAAG,EAC7BE,EAAO0B,GAAMA,EAAG,MACtB,MAAO,CAACzB,GAAcD,aAAgBV,EAASU,EAAK,MAAQA,CAC9D,CAEA,IAAIF,EAAK,CACP,MAAO,CAAC,CAAC8D,GAAS,KAAK,MAAO9D,CAAG,CACnC,CAEA,IAAIA,EAAKf,EAAO,CACd,KAAK,IAAI,IAAIgD,EAAKjC,EAAKf,CAAK,EAAG,EAAI,CACrC,CASA,OAAO4C,EAAG1C,EAAKiF,EAAM,CACnB,IAAMhC,EAAMgC,EAAO,IAAIA,EAASjF,GAAOA,EAAI,SAAW,IAAI,IAAQ,CAAC,EAC/DA,GAAOA,EAAI,UAAUA,EAAI,SAASiD,CAAG,EAEzC,QAAWlB,KAAQ,KAAK,MAAOA,EAAK,WAAW/B,EAAKiD,CAAG,EAEvD,OAAOA,CACT,CAEA,SAASjD,EAAKsB,EAAWC,EAAa,CACpC,GAAI,CAACvB,EAAK,OAAO,KAAK,UAAU,IAAI,EAEpC,QAAW+B,KAAQ,KAAK,MACtB,GAAI,EAAEA,aAAgBe,GAAO,MAAM,IAAI,MAAM,sCAAsC,KAAK,UAAUf,CAAI,WAAW,EAGnH,OAAO,MAAM,SAAS/B,EAAK,CACzB,UAAWiB,GAAKA,EAAE,IAClB,UAAW,CACT,MAAO,IACP,IAAK,GACP,EACA,MAAO,GACP,WAAYjB,EAAI,QAAU,EAC5B,EAAGsB,EAAWC,CAAW,CAC3B,CAEF,EAEM2D,GAAY,KACZC,GAAN,cAAoBrC,CAAK,CACvB,YAAYK,EAAM,CAChB,GAAIA,aAAgBL,EAAM,CACxB,IAAIH,EAAMQ,EAAK,MAETR,aAAeH,IACnBG,EAAM,IAAIH,EACVG,EAAI,MAAM,KAAKQ,EAAK,KAAK,EACzBR,EAAI,MAAQQ,EAAK,MAAM,OAGzB,MAAMA,EAAK,IAAKR,CAAG,EACnB,KAAK,MAAQQ,EAAK,KACpB,MACE,MAAM,IAAI9C,EAAO6E,EAAS,EAAG,IAAI1C,CAAS,EAG5C,KAAK,KAAOM,EAAK,KAAK,UACxB,CASA,WAAW9C,EAAKiD,EAAK,CACnB,OAAW,CACT,OAAAqB,CACF,IAAK,KAAK,MAAM,MAAO,CACrB,GAAI,EAAEA,aAAkBO,IAAU,MAAM,IAAI,MAAM,4BAA4B,EAC9E,IAAMO,EAASd,EAAO,OAAO,KAAMtE,EAAK,GAAG,EAE3C,OAAW,CAACa,EAAKf,CAAK,IAAKsF,EACrBnC,aAAe,IACZA,EAAI,IAAIpC,CAAG,GAAGoC,EAAI,IAAIpC,EAAKf,CAAK,EAC5BmD,aAAe,IACxBA,EAAI,IAAIpC,CAAG,EACD,OAAO,UAAU,eAAe,KAAKoC,EAAKpC,CAAG,GACvD,OAAO,eAAeoC,EAAKpC,EAAK,CAC9B,MAAAf,EACA,SAAU,GACV,WAAY,GACZ,aAAc,EAChB,CAAC,CAGP,CAEA,OAAOmD,CACT,CAEA,SAASjD,EAAKsB,EAAW,CACvB,IAAMqB,EAAM,KAAK,MACjB,GAAIA,EAAI,MAAM,OAAS,EAAG,OAAO,MAAM,SAAS3C,EAAKsB,CAAS,EAC9D,KAAK,MAAQqB,EAAI,MAAM,GACvB,IAAMnD,EAAM,MAAM,SAASQ,EAAKsB,CAAS,EACzC,YAAK,MAAQqB,EACNnD,CACT,CAEF,EAEM6F,GAAgB,CACpB,YAAa/F,EAAW,KAAK,cAC7B,UAAW,EACb,EACMgG,GAAc,CAClB,QAAS,OACT,SAAU,OACZ,EACMC,GAAa,CACjB,SAAU,EACZ,EACMC,GAAc,CAClB,QAAS,MACX,EACMC,GAAa,CACjB,YAAanG,EAAW,KAAK,MAC7B,aAAc,CACZ,aAAc,GACd,mBAAoB,EACtB,EACA,KAAM,CACJ,UAAW,GACX,gBAAiB,EACnB,CACF,EAEA,SAASoG,GAAclG,EAAKmG,EAAMC,EAAgB,CAChD,OAAW,CACT,OAAAC,EACA,KAAAC,EACA,QAAAC,CACF,IAAKJ,EACH,GAAIG,EAAM,CACR,IAAME,EAAQxG,EAAI,MAAMsG,CAAI,EAE5B,GAAIE,EAAO,CACT,IAAI5F,EAAM2F,EAAQ,MAAM,KAAMC,CAAK,EACnC,OAAM5F,aAAeC,IAASD,EAAM,IAAIC,EAAOD,CAAG,GAC9CyF,IAAQzF,EAAI,OAASyF,GAClBzF,CACT,CACF,CAGF,OAAIwF,IAAgBpG,EAAMoG,EAAepG,CAAG,GACrC,IAAIa,EAAOb,CAAG,CACvB,CAEA,IAAMyG,GAAY,OACZC,GAAa,QACbC,GAAc,SAGdC,GAA2B,CAACC,EAAMnG,IAAM,CAC5C,IAAIoG,EAAKD,EAAKnG,EAAI,GAElB,KAAOoG,IAAO,KAAOA,IAAO,KAAM,CAChC,GACEA,EAAKD,EAAKnG,GAAK,SACRoG,GAAMA,IAAO;AAAA,GAEtBA,EAAKD,EAAKnG,EAAI,EAChB,CAEA,OAAOA,CACT,EAuBA,SAASqG,GAAcF,EAAM5G,EAAQ+G,EAAM,CACzC,cAAAC,EACA,UAAAC,EAAY,GACZ,gBAAAC,EAAkB,GAClB,OAAAC,EACA,WAAAC,CACF,EAAG,CACD,GAAI,CAACH,GAAaA,EAAY,EAAG,OAAOL,EACxC,IAAMS,EAAU,KAAK,IAAI,EAAIH,EAAiB,EAAID,EAAYjH,EAAO,MAAM,EAC3E,GAAI4G,EAAK,QAAUS,EAAS,OAAOT,EACnC,IAAMU,EAAQ,CAAC,EACTC,EAAe,CAAC,EAClB9E,EAAMwE,EAAYjH,EAAO,OAEzB,OAAOgH,GAAkB,WACvBA,EAAgBC,EAAY,KAAK,IAAI,EAAGC,CAAe,EAAGI,EAAM,KAAK,CAAC,EAAO7E,EAAMwE,EAAYD,GAGrG,IAAIQ,EACAlC,EACAmC,EAAW,GACXhH,EAAI,GACJiH,EAAW,GACXC,EAAS,GAETZ,IAASN,KACXhG,EAAIkG,GAAyBC,EAAMnG,CAAC,EAChCA,IAAM,KAAIgC,EAAMhC,EAAI4G,IAG1B,QAASR,EAAIA,EAAKD,EAAKnG,GAAK,IAAK,CAC/B,GAAIsG,IAASL,IAAeG,IAAO,KAAM,CAGvC,OAFAa,EAAWjH,EAEHmG,EAAKnG,EAAI,QACV,IACHA,GAAK,EACL,UAEG,IACHA,GAAK,EACL,UAEG,IACHA,GAAK,EACL,cAGAA,GAAK,EAGTkH,EAASlH,CACX,CAEA,GAAIoG,IAAO;AAAA,EACLE,IAASN,KAAYhG,EAAIkG,GAAyBC,EAAMnG,CAAC,GAC7DgC,EAAMhC,EAAI4G,EACVG,EAAQ,WACH,CACL,GAAIX,IAAO,KAAOvB,GAAQA,IAAS,KAAOA,IAAS;AAAA,GAAQA,IAAS,IAAM,CAExE,IAAMsC,EAAOhB,EAAKnG,EAAI,GAClBmH,GAAQA,IAAS,KAAOA,IAAS;AAAA,GAAQA,IAAS,MAAMJ,EAAQ/G,EACtE,CAEA,GAAIA,GAAKgC,EACP,GAAI+E,EACFF,EAAM,KAAKE,CAAK,EAChB/E,EAAM+E,EAAQH,EACdG,EAAQ,eACCT,IAASL,GAAa,CAE/B,KAAOpB,IAAS,KAAOA,IAAS,KAC9BA,EAAOuB,EACPA,EAAKD,EAAKnG,GAAK,GACfgH,EAAW,GAIb,IAAMI,EAAIpH,EAAIkH,EAAS,EAAIlH,EAAI,EAAIiH,EAAW,EAE9C,GAAIH,EAAaM,GAAI,OAAOjB,EAC5BU,EAAM,KAAKO,CAAC,EACZN,EAAaM,GAAK,GAClBpF,EAAMoF,EAAIR,EACVG,EAAQ,MACV,MACEC,EAAW,EAGjB,CAEAnC,EAAOuB,CACT,CAGA,GADIY,GAAYL,GAAYA,EAAW,EACnCE,EAAM,SAAW,EAAG,OAAOV,EAC3BO,GAAQA,EAAO,EACnB,IAAIxG,EAAMiG,EAAK,MAAM,EAAGU,EAAM,EAAE,EAEhC,QAAS7G,EAAI,EAAGA,EAAI6G,EAAM,OAAQ,EAAE7G,EAAG,CACrC,IAAMqH,EAAOR,EAAM7G,GACbgC,EAAM6E,EAAM7G,EAAI,IAAMmG,EAAK,OAC7BkB,IAAS,EAAGnH,EAAM;AAAA,EAAKX,IAAS4G,EAAK,MAAM,EAAGnE,CAAG,KAC/CsE,IAASL,IAAea,EAAaO,KAAOnH,GAAO,GAAGiG,EAAKkB,QAC/DnH,GAAO;AAAA,EAAKX,IAAS4G,EAAK,MAAMkB,EAAO,EAAGrF,CAAG,IAEjD,CAEA,OAAO9B,CACT,CAEA,IAAMoH,GAAiB,CAAC,CACtB,cAAAf,CACF,IAAMA,EAAgB,OAAO,OAAO,CAClC,cAAAA,CACF,EAAGhB,GAAW,IAAI,EAAIA,GAAW,KAI3BgC,GAAyBjI,GAAO,mBAAmB,KAAKA,CAAG,EAEjE,SAASkI,GAAoBlI,EAAKkH,EAAWiB,EAAc,CACzD,GAAI,CAACjB,GAAaA,EAAY,EAAG,MAAO,GACxC,IAAMkB,EAAQlB,EAAYiB,EACpBE,EAASrI,EAAI,OACnB,GAAIqI,GAAUD,EAAO,MAAO,GAE5B,QAAS,EAAI,EAAG3F,EAAQ,EAAG,EAAI4F,EAAQ,EAAE,EACvC,GAAIrI,EAAI,KAAO;AAAA,EAAM,CACnB,GAAI,EAAIyC,EAAQ2F,EAAO,MAAO,GAE9B,GADA3F,EAAQ,EAAI,EACR4F,EAAS5F,GAAS2F,EAAO,MAAO,EACtC,CAGF,MAAO,EACT,CAEA,SAASE,GAAmBhI,EAAOE,EAAK,CACtC,GAAM,CACJ,YAAAuE,CACF,EAAIvE,EACE,CACJ,aAAA+H,EACA,mBAAAC,CACF,EAAIvC,GAAW,aACTwC,EAAO,KAAK,UAAUnI,CAAK,EACjC,GAAIiI,EAAc,OAAOE,EACzB,IAAMxI,EAASO,EAAI,SAAWyH,GAAuB3H,CAAK,EAAI,KAAO,IACjEN,EAAM,GACNyC,EAAQ,EAEZ,QAAS/B,EAAI,EAAGoG,EAAK2B,EAAK/H,GAAIoG,EAAIA,EAAK2B,EAAK,EAAE/H,GAS5C,GARIoG,IAAO,KAAO2B,EAAK/H,EAAI,KAAO,MAAQ+H,EAAK/H,EAAI,KAAO,MAExDV,GAAOyI,EAAK,MAAMhG,EAAO/B,CAAC,EAAI,MAC9BA,GAAK,EACL+B,EAAQ/B,EACRoG,EAAK,MAGHA,IAAO,KAAM,OAAQ2B,EAAK/H,EAAI,QAC3B,IACH,CACEV,GAAOyI,EAAK,MAAMhG,EAAO/B,CAAC,EAC1B,IAAMgI,EAAOD,EAAK,OAAO/H,EAAI,EAAG,CAAC,EAEjC,OAAQgI,OACD,OACH1I,GAAO,MACP,UAEG,OACHA,GAAO,MACP,UAEG,OACHA,GAAO,MACP,UAEG,OACHA,GAAO,MACP,UAEG,OACHA,GAAO,MACP,UAEG,OACHA,GAAO,MACP,UAEG,OACHA,GAAO,MACP,UAEG,OACHA,GAAO,MACP,cAGI0I,EAAK,OAAO,EAAG,CAAC,IAAM,KAAM1I,GAAO,MAAQ0I,EAAK,OAAO,CAAC,EAAO1I,GAAOyI,EAAK,OAAO/H,EAAG,CAAC,EAG9FA,GAAK,EACL+B,EAAQ/B,EAAI,CACd,CACA,UAEG,IACH,GAAIqE,GAAe0D,EAAK/H,EAAI,KAAO,KAAO+H,EAAK,OAASD,EACtD9H,GAAK,MACA,CAIL,IAFAV,GAAOyI,EAAK,MAAMhG,EAAO/B,CAAC,EAAI;AAAA;AAAA,EAEvB+H,EAAK/H,EAAI,KAAO,MAAQ+H,EAAK/H,EAAI,KAAO,KAAO+H,EAAK/H,EAAI,KAAO,KACpEV,GAAO;AAAA,EACPU,GAAK,EAGPV,GAAOC,EAEHwI,EAAK/H,EAAI,KAAO,MAAKV,GAAO,MAChCU,GAAK,EACL+B,EAAQ/B,EAAI,CACd,CAEA,cAGAA,GAAK,EAIX,OAAAV,EAAMyC,EAAQzC,EAAMyI,EAAK,MAAMhG,CAAK,EAAIgG,EACjC1D,EAAc/E,EAAM+G,GAAc/G,EAAKC,EAAQ0G,GAAaqB,GAAexH,CAAG,CAAC,CACxF,CAEA,SAASmI,GAAmBrI,EAAOE,EAAK,CACtC,GAAIA,EAAI,aACN,GAAI,KAAK,KAAKF,CAAK,EAAG,OAAOgI,GAAmBhI,EAAOE,CAAG,UAGtD,kBAAkB,KAAKF,CAAK,EAAG,OAAOgI,GAAmBhI,EAAOE,CAAG,EAGzE,IAAMP,EAASO,EAAI,SAAWyH,GAAuB3H,CAAK,EAAI,KAAO,IAC/DM,EAAM,IAAMN,EAAM,QAAQ,KAAM,IAAI,EAAE,QAAQ,OAAQ;AAAA,EAAOL,GAAQ,EAAI,IAC/E,OAAOO,EAAI,YAAcI,EAAMmG,GAAcnG,EAAKX,EAAQwG,GAAWuB,GAAexH,CAAG,CAAC,CAC1F,CAEA,SAASoI,GAAY,CACnB,QAAA1I,EACA,KAAA2I,EACA,MAAAvI,CACF,EAAGE,EAAKsB,EAAWC,EAAa,CAG9B,GAAI,YAAY,KAAKzB,CAAK,GAAK,QAAQ,KAAKA,CAAK,EAC/C,OAAOgI,GAAmBhI,EAAOE,CAAG,EAGtC,IAAMP,EAASO,EAAI,SAAWA,EAAI,kBAAoByH,GAAuB3H,CAAK,EAAI,KAAO,IACvFsD,EAAa3D,EAAS,IAAM,IAE5B6I,EAAUD,IAAS/I,EAAW,KAAK,aAAe,GAAQ+I,IAAS/I,EAAW,KAAK,cAAgB,GAAO,CAACoI,GAAoB5H,EAAO2F,GAAW,KAAK,UAAWhG,EAAO,MAAM,EAChL8I,EAASD,EAAU,IAAM,IAC7B,GAAI,CAACxI,EAAO,OAAOyI,EAAS;AAAA,EAC5B,IAAIC,EAAU,GACVC,EAAQ,GAkCZ,GAjCA3I,EAAQA,EAAM,QAAQ,YAAa+D,GAAM,CACvC,IAAM5C,EAAI4C,EAAG,QAAQ;AAAA,CAAI,EAEzB,OAAI5C,IAAM,GACRsH,GAAU,KACDzI,IAAU+D,GAAM5C,IAAM4C,EAAG,OAAS,KAC3C0E,GAAU,IAENhH,GAAaA,EAAY,GAG/BkH,EAAQ5E,EAAG,QAAQ,MAAO,EAAE,EACrB,EACT,CAAC,EAAE,QAAQ,UAAWA,GAAM,CACtBA,EAAG,QAAQ,GAAG,IAAM,KAAI0E,GAAUnF,GACtC,IAAMsF,EAAI7E,EAAG,MAAM,KAAK,EAExB,OAAI6E,GACFF,EAAU3E,EAAG,MAAM,EAAG,CAAC6E,EAAE,GAAG,MAAM,EAC3BA,EAAE,KAETF,EAAU3E,EACH,GAEX,CAAC,EACG4E,IAAOA,EAAQA,EAAM,QAAQ,eAAgB,KAAKhJ,GAAQ,GAC1D+I,IAASA,EAAUA,EAAQ,QAAQ,OAAQ,KAAK/I,GAAQ,GAExDC,IACF6I,GAAU,KAAO7I,EAAQ,QAAQ,aAAc,GAAG,EAC9C4B,GAAWA,EAAU,GAGvB,CAACxB,EAAO,MAAO,GAAGyI,IAASnF;AAAA,EAAe3D,IAASgJ,IAEvD,GAAIH,EACF,OAAAxI,EAAQA,EAAM,QAAQ,OAAQ,KAAKL,GAAQ,EACpC,GAAG8I;AAAA,EAAW9I,IAAS+I,IAAU1I,IAAQ2I,IAGlD3I,EAAQA,EAAM,QAAQ,OAAQ;AAAA,GAAM,EAAE,QAAQ,iDAAkD,MAAM,EAErG,QAAQ,OAAQ,KAAKL,GAAQ,EAC9B,IAAMkJ,EAAOpC,GAAc,GAAGiC,IAAU1I,IAAQ2I,IAAShJ,EAAQyG,GAAYT,GAAW,IAAI,EAC5F,MAAO,GAAG8C;AAAA,EAAW9I,IAASkJ,GAChC,CAEA,SAASC,GAAY7G,EAAM/B,EAAKsB,EAAWC,EAAa,CACtD,GAAM,CACJ,QAAA7B,EACA,KAAA2I,EACA,MAAAvI,CACF,EAAIiC,EACE,CACJ,aAAA8G,EACA,YAAAtE,EACA,OAAA9E,EACA,OAAAiC,CACF,EAAI1B,EAEJ,GAAIuE,GAAe,aAAa,KAAKzE,CAAK,GAAK4B,GAAU,WAAW,KAAK5B,CAAK,EAC5E,OAAOgI,GAAmBhI,EAAOE,CAAG,EAGtC,GAAI,CAACF,GAAS,oFAAoF,KAAKA,CAAK,EAO1G,OAAOyE,GAAe7C,GAAU5B,EAAM,QAAQ;AAAA,CAAI,IAAM,GAAKA,EAAM,QAAQ,GAAG,IAAM,IAAMA,EAAM,QAAQ,GAAG,IAAM,GAAKqI,GAAmBrI,EAAOE,CAAG,EAAI8H,GAAmBhI,EAAOE,CAAG,EAAIoI,GAAYrG,EAAM/B,EAAKsB,EAAWC,CAAW,EAGvO,GAAI,CAACgD,GAAe,CAAC7C,GAAU2G,IAAS/I,EAAW,KAAK,OAASQ,EAAM,QAAQ;AAAA,CAAI,IAAM,GAEvF,OAAOsI,GAAYrG,EAAM/B,EAAKsB,EAAWC,CAAW,EAGtD,GAAI9B,IAAW,IAAMgI,GAAuB3H,CAAK,EAC/C,OAAAE,EAAI,iBAAmB,GAChBoI,GAAYrG,EAAM/B,EAAKsB,EAAWC,CAAW,EAGtD,IAAM/B,EAAMM,EAAM,QAAQ,OAAQ;AAAA,EAAOL,GAAQ,EAIjD,GAAIoJ,EAAc,CAChB,GAAM,CACJ,KAAAlD,CACF,EAAI3F,EAAI,IAAI,OAEZ,GAAI,OADa0F,GAAclG,EAAKmG,EAAMA,EAAK,cAAc,EAAE,OACvC,SAAU,OAAOmC,GAAmBhI,EAAOE,CAAG,CACxE,CAEA,IAAM2I,EAAOpE,EAAc/E,EAAM+G,GAAc/G,EAAKC,EAAQwG,GAAWuB,GAAexH,CAAG,CAAC,EAE1F,OAAIN,GAAW,CAACgC,IAAWiH,EAAK,QAAQ;AAAA,CAAI,IAAM,IAAMjJ,EAAQ,QAAQ;AAAA,CAAI,IAAM,KAC5E4B,GAAWA,EAAU,EAClB/B,GAAiBoJ,EAAMlJ,EAAQC,CAAO,GAGxCiJ,CACT,CAEA,SAASG,GAAgB/G,EAAM/B,EAAKsB,EAAWC,EAAa,CAC1D,GAAM,CACJ,YAAAwH,CACF,EAAItD,GACE,CACJ,YAAAlB,EACA,OAAA7C,CACF,EAAI1B,EACA,CACF,KAAAqI,EACA,MAAAvI,CACF,EAAIiC,EAEA,OAAOjC,GAAU,WACnBA,EAAQ,OAAOA,CAAK,EACpBiC,EAAO,OAAO,OAAO,CAAC,EAAGA,EAAM,CAC7B,MAAAjC,CACF,CAAC,GAGH,IAAMkJ,EAAaC,GAAS,CAC1B,OAAQA,QACD3J,EAAW,KAAK,kBAChBA,EAAW,KAAK,cACnB,OAAO8I,GAAYrG,EAAM/B,EAAKsB,EAAWC,CAAW,OAEjDjC,EAAW,KAAK,aACnB,OAAOwI,GAAmBhI,EAAOE,CAAG,OAEjCV,EAAW,KAAK,aACnB,OAAO6I,GAAmBrI,EAAOE,CAAG,OAEjCV,EAAW,KAAK,MACnB,OAAOsJ,GAAY7G,EAAM/B,EAAKsB,EAAWC,CAAW,UAGpD,OAAO,KAEb,GAEI8G,IAAS/I,EAAW,KAAK,cAAgB,gCAAgC,KAAKQ,CAAK,IAG3EyE,GAAe7C,KAAY2G,IAAS/I,EAAW,KAAK,cAAgB+I,IAAS/I,EAAW,KAAK,kBAEvG+I,EAAO/I,EAAW,KAAK,cAGzB,IAAIc,EAAM4I,EAAWX,CAAI,EAEzB,GAAIjI,IAAQ,OACVA,EAAM4I,EAAWD,CAAW,EACxB3I,IAAQ,MAAM,MAAM,IAAI,MAAM,mCAAmC2I,GAAa,EAGpF,OAAO3I,CACT,CAEA,SAAS8I,GAAgB,CACvB,OAAArD,EACA,kBAAAsD,EACA,IAAAC,EACA,MAAAtJ,CACF,EAAG,CACD,GAAI,OAAOA,GAAU,SAAU,OAAO,OAAOA,CAAK,EAClD,GAAI,CAAC,SAASA,CAAK,EAAG,OAAO,MAAMA,CAAK,EAAI,OAASA,EAAQ,EAAI,QAAU,OAC3E,IAAImB,EAAI,KAAK,UAAUnB,CAAK,EAE5B,GAAI,CAAC+F,GAAUsD,IAAsB,CAACC,GAAOA,IAAQ,4BAA8B,MAAM,KAAKnI,CAAC,EAAG,CAChG,IAAI,EAAIA,EAAE,QAAQ,GAAG,EAEjB,EAAI,IACN,EAAIA,EAAE,OACNA,GAAK,KAGP,IAAIoI,EAAIF,GAAqBlI,EAAE,OAAS,EAAI,GAE5C,KAAOoI,KAAM,GAAGpI,GAAK,GACvB,CAEA,OAAOA,CACT,CAEA,SAASqI,GAAuBC,EAAQC,EAAK,CAC3C,IAAIC,EAAMC,EAEV,OAAQF,EAAI,WACLlK,EAAW,KAAK,SACnBmK,EAAO,IACPC,EAAO,WACP,WAEGpK,EAAW,KAAK,SACnBmK,EAAO,IACPC,EAAO,gBACP,cAGAH,EAAO,KAAK,IAAIjK,EAAW,kBAAkBkK,EAAK,yBAAyB,CAAC,EAC5E,OAGJ,IAAIG,EAEJ,QAAS,EAAIH,EAAI,MAAM,OAAS,EAAG,GAAK,EAAG,EAAE,EAAG,CAC9C,IAAMzH,EAAOyH,EAAI,MAAM,GAEvB,GAAI,CAACzH,GAAQA,EAAK,OAASzC,EAAW,KAAK,QAAS,CAClDqK,EAAW5H,EACX,KACF,CACF,CAEA,GAAI4H,GAAYA,EAAS,OAASF,EAAM,CACtC,IAAMzG,EAAM,YAAY0G,iBAAoBD,IACxCG,EAEA,OAAOD,EAAS,QAAW,UAC7BC,EAAM,IAAItK,EAAW,kBAAkBkK,EAAKxG,CAAG,EAC/C4G,EAAI,OAASD,EAAS,OAAS,IAE/BC,EAAM,IAAItK,EAAW,kBAAkBqK,EAAU3G,CAAG,EAChD2G,EAAS,OAASA,EAAS,MAAM,MAAKC,EAAI,OAASD,EAAS,MAAM,IAAMA,EAAS,MAAM,QAG7FJ,EAAO,KAAKK,CAAG,CACjB,CACF,CACA,SAASC,GAAsBN,EAAQ7J,EAAS,CAC9C,IAAMqF,EAAOrF,EAAQ,QAAQ,IAAIA,EAAQ,MAAM,MAAQ,GAEvD,GAAIqF,IAAS;AAAA,GAAQA,IAAS,KAAQA,IAAS,IAAK,CAClD,IAAM/B,EAAM,yEACZuG,EAAO,KAAK,IAAIjK,EAAW,kBAAkBI,EAASsD,CAAG,CAAC,CAC5D,CACF,CACA,SAAS8G,GAAgBxF,EAAQzD,EAAK,CACpC,IAAMkJ,EAAK,OAAOlJ,CAAG,EACfJ,EAAIsJ,EAAG,OAAO,EAAG,CAAC,EAAI,MAAQA,EAAG,OAAO,EAAE,EAChD,OAAO,IAAIzK,EAAW,kBAAkBgF,EAAQ,QAAQ7D,oBAAoB,CAC9E,CACA,SAASuJ,GAAgBC,EAAYC,EAAU,CAC7C,OAAW,CACT,SAAAC,EACA,OAAAC,EACA,QAAA1K,CACF,IAAKwK,EAAU,CACb,IAAInI,EAAOkI,EAAW,MAAMG,GAEvBrI,GAKCoI,GAAYpI,EAAK,QAAOA,EAAOA,EAAK,OAEpCrC,IAAY,QACVyK,GAAY,CAACpI,EAAK,iBAAeA,EAAK,YAAc,IAEpDA,EAAK,cAAeA,EAAK,eAAiB;AAAA,EAAOrC,EAAaqC,EAAK,cAAgBrC,GATrFA,IAAY,SACVuK,EAAW,QAASA,EAAW,SAAW;AAAA,EAAOvK,EAAauK,EAAW,QAAUvK,EAW7F,CACF,CAGA,SAAS2K,GAAc5G,EAAK1C,EAAM,CAChC,IAAMX,EAAMW,EAAK,SACjB,OAAKX,EACD,OAAOA,GAAQ,SAAiBA,GACpCA,EAAI,OAAO,QAAQkK,GAAS,CACrBA,EAAM,SAAQA,EAAM,OAASvJ,GAClC0C,EAAI,OAAO,KAAK6G,CAAK,CACvB,CAAC,EACMlK,EAAI,KANM,EAOnB,CAEA,SAASmK,GAAiB9G,EAAK1C,EAAM,CACnC,GAAM,CACJ,OAAAyJ,EACA,OAAAC,CACF,EAAI1J,EAAK,IACL2J,EAASjH,EAAI,YAAY,KAAKkH,GAAKA,EAAE,SAAWH,CAAM,EAE1D,GAAI,CAACE,EAAQ,CACX,IAAME,EAAMnH,EAAI,YAAY,EAAE,YAE9B,GADImH,IAAKF,EAASE,EAAI,KAAKD,GAAKA,EAAE,SAAWH,CAAM,GAC/C,CAACE,EAAQ,MAAM,IAAIpL,EAAW,kBAAkByB,EAAM,OAAOyJ,mDAAwD,CAC3H,CAEA,GAAI,CAACC,EAAQ,MAAM,IAAInL,EAAW,kBAAkByB,EAAM,OAAOyJ,sBAA2B,EAE5F,GAAIA,IAAW,MAAQ/G,EAAI,SAAWA,EAAI,QAAQ,WAAa,MAAO,CACpE,GAAIgH,EAAO,KAAO,IAChB,OAAAhH,EAAI,SAAS,KAAK,IAAInE,EAAW,YAAYyB,EAAM,2CAA2C,CAAC,EACxF0J,EAGT,GAAI,OAAO,KAAKA,CAAM,EAAG,CAEvB,IAAMI,EAAQJ,EAAO,MAAM,sBAAsB,EACjD,OAAOI,EAAQ,OAAOA,EAAM,oBAAoBA,EAAM,KAAO,OAAOJ,GACtE,CACF,CAEA,OAAOC,EAAO,OAAS,mBAAmBD,CAAM,CAClD,CAEA,SAASK,GAAerH,EAAK1C,EAAM,CACjC,GAAM,CACJ,IAAAqI,EACA,KAAAf,CACF,EAAItH,EACAgK,EAAc,GAElB,GAAI3B,EAAK,CACP,GAAM,CACJ,OAAAoB,EACA,OAAAC,EACA,SAAAO,CACF,EAAI5B,EAEJ,GAAI4B,EAAU,CACZ,GAAIA,IAAa,KAAOA,IAAa,KAAM,OAAOA,EAClD,IAAMhI,EAAM,qCAAqCgI,gBACjDvH,EAAI,OAAO,KAAK,IAAInE,EAAW,kBAAkByB,EAAMiC,CAAG,CAAC,CAC7D,SAAWwH,IAAW,KAAO,CAACC,EAC5BM,EAAc,OAEd,IAAI,CACF,OAAOR,GAAiB9G,EAAK1C,CAAI,CACnC,OAASuJ,EAAP,CACA7G,EAAI,OAAO,KAAK6G,CAAK,CACvB,CAEJ,CAEA,OAAQjC,QACD/I,EAAW,KAAK,kBAChBA,EAAW,KAAK,mBAChBA,EAAW,KAAK,kBAChBA,EAAW,KAAK,aACnB,OAAOA,EAAW,YAAY,SAE3BA,EAAW,KAAK,cAChBA,EAAW,KAAK,IACnB,OAAOA,EAAW,YAAY,SAE3BA,EAAW,KAAK,cAChBA,EAAW,KAAK,IACnB,OAAOA,EAAW,YAAY,SAE3BA,EAAW,KAAK,MACnB,OAAOyL,EAAczL,EAAW,YAAY,IAAM,aAGlD,OAAO,KAEb,CAEA,SAAS2L,GAAiBxH,EAAK1C,EAAMmK,EAAS,CAC5C,GAAM,CACJ,KAAAvF,CACF,EAAIlC,EAAI,OACF0H,EAAgB,CAAC,EAEvB,QAAW/B,KAAOzD,EAChB,GAAIyD,EAAI,MAAQ8B,EACd,GAAI9B,EAAI,KAAM+B,EAAc,KAAK/B,CAAG,MAAO,CACzC,IAAMhJ,EAAMgJ,EAAI,QAAQ3F,EAAK1C,CAAI,EACjC,OAAOX,aAAeQ,EAAaR,EAAM,IAAIC,EAAOD,CAAG,CACzD,CAIJ,IAAMZ,EAAM6K,GAAc5G,EAAK1C,CAAI,EACnC,OAAI,OAAOvB,GAAQ,UAAY2L,EAAc,OAAS,EAAUzF,GAAclG,EAAK2L,EAAexF,EAAK,cAAc,EAC9G,IACT,CAEA,SAASyF,GAAmB,CAC1B,KAAA/C,CACF,EAAG,CACD,OAAQA,QACD/I,EAAW,KAAK,cAChBA,EAAW,KAAK,IACnB,OAAOA,EAAW,YAAY,SAE3BA,EAAW,KAAK,cAChBA,EAAW,KAAK,IACnB,OAAOA,EAAW,YAAY,YAG9B,OAAOA,EAAW,YAAY,IAEpC,CAEA,SAAS+L,GAAW5H,EAAK1C,EAAMmK,EAAS,CACtC,GAAI,CACF,IAAM9K,EAAM6K,GAAiBxH,EAAK1C,EAAMmK,CAAO,EAE/C,GAAI9K,EACF,OAAI8K,GAAWnK,EAAK,MAAKX,EAAI,IAAM8K,GAC5B9K,CAEX,OAASkK,EAAP,CAEA,OAAKA,EAAM,SAAQA,EAAM,OAASvJ,GAClC0C,EAAI,OAAO,KAAK6G,CAAK,EACd,IACT,CAEA,GAAI,CACF,IAAMgB,EAAWF,GAAmBrK,CAAI,EACxC,GAAI,CAACuK,EAAU,MAAM,IAAI,MAAM,WAAWJ,kBAAwB,EAClE,IAAMlI,EAAM,WAAWkI,qCAA2CI,IAClE7H,EAAI,SAAS,KAAK,IAAInE,EAAW,YAAYyB,EAAMiC,CAAG,CAAC,EACvD,IAAM5C,EAAM6K,GAAiBxH,EAAK1C,EAAMuK,CAAQ,EAChD,OAAAlL,EAAI,IAAM8K,EACH9K,CACT,OAASkK,EAAP,CACA,IAAMiB,EAAW,IAAIjM,EAAW,mBAAmByB,EAAMuJ,EAAM,OAAO,EACtE,OAAAiB,EAAS,MAAQjB,EAAM,MACvB7G,EAAI,OAAO,KAAK8H,CAAQ,EACjB,IACT,CACF,CAEA,IAAMC,GAAmBzK,GAAQ,CAC/B,GAAI,CAACA,EAAM,MAAO,GAClB,GAAM,CACJ,KAAAsH,CACF,EAAItH,EACJ,OAAOsH,IAAS/I,EAAW,KAAK,SAAW+I,IAAS/I,EAAW,KAAK,WAAa+I,IAAS/I,EAAW,KAAK,QAC5G,EAEA,SAASmM,GAAiBlC,EAAQxI,EAAM,CACtC,IAAMmJ,EAAW,CACf,OAAQ,CAAC,EACT,MAAO,CAAC,CACV,EACIwB,EAAY,GACZC,EAAS,GACPC,EAAQJ,GAAiBzK,EAAK,QAAQ,MAAM,EAAIA,EAAK,QAAQ,OAAO,MAAM,OAAOA,EAAK,KAAK,EAAIA,EAAK,MAE1G,OAAW,CACT,MAAAkB,EACA,IAAAC,CACF,IAAK0J,EACH,OAAQ7K,EAAK,QAAQ,IAAIkB,SAClB3C,EAAW,KAAK,QACnB,CACE,GAAI,CAACyB,EAAK,6BAA6BkB,CAAK,EAAG,CAC7C,IAAMe,EAAM,yEACZuG,EAAO,KAAK,IAAIjK,EAAW,kBAAkByB,EAAMiC,CAAG,CAAC,CACzD,CAEA,GAAM,CACJ,OAAAuF,EACA,WAAAsD,CACF,EAAI9K,GACO8K,IAAe5J,EAAQ4J,EAAW,OAAStD,GAAUtG,EAAQsG,EAAO,OAAS2B,EAAS,MAAQA,EAAS,QAC/G,KAAKnJ,EAAK,QAAQ,IAAI,MAAMkB,EAAQ,EAAGC,CAAG,CAAC,EAC9C,KACF,MAGG5C,EAAW,KAAK,OACnB,GAAIoM,EAAW,CACb,IAAM1I,EAAM,qCACZuG,EAAO,KAAK,IAAIjK,EAAW,kBAAkByB,EAAMiC,CAAG,CAAC,CACzD,CAEA0I,EAAY,GACZ,WAEGpM,EAAW,KAAK,IACnB,GAAIqM,EAAQ,CACV,IAAM3I,EAAM,kCACZuG,EAAO,KAAK,IAAIjK,EAAW,kBAAkByB,EAAMiC,CAAG,CAAC,CACzD,CAEA2I,EAAS,GACT,MAIN,MAAO,CACL,SAAAzB,EACA,UAAAwB,EACA,OAAAC,CACF,CACF,CAEA,SAASG,GAAiBrI,EAAK1C,EAAM,CACnC,GAAM,CACJ,QAAAgD,EACA,OAAAwF,EACA,OAAAhJ,CACF,EAAIkD,EAEJ,GAAI1C,EAAK,OAASzB,EAAW,KAAK,MAAO,CACvC,IAAMoK,EAAO3I,EAAK,SACZgL,EAAMhI,EAAQ,QAAQ2F,CAAI,EAEhC,GAAI,CAACqC,EAAK,CACR,IAAM/I,EAAM,6BAA6B0G,IACzC,OAAAH,EAAO,KAAK,IAAIjK,EAAW,mBAAmByB,EAAMiC,CAAG,CAAC,EACjD,IACT,CAGA,IAAM5C,EAAM,IAAI4D,EAAM+H,CAAG,EAEzB,OAAAhI,EAAQ,YAAY,KAAK3D,CAAG,EAErBA,CACT,CAEA,IAAM8K,EAAUJ,GAAerH,EAAK1C,CAAI,EACxC,GAAImK,EAAS,OAAOG,GAAW5H,EAAK1C,EAAMmK,CAAO,EAEjD,GAAInK,EAAK,OAASzB,EAAW,KAAK,MAAO,CACvC,IAAM0D,EAAM,qBAAqBjC,EAAK,iBACtC,OAAAwI,EAAO,KAAK,IAAIjK,EAAW,gBAAgByB,EAAMiC,CAAG,CAAC,EAC9C,IACT,CAEA,GAAI,CACF,IAAMxD,EAAM6K,GAAc5G,EAAK1C,CAAI,EACnC,OAAO2E,GAAclG,EAAKe,EAAO,KAAMA,EAAO,KAAK,cAAc,CACnE,OAAS+J,EAAP,CACA,OAAKA,EAAM,SAAQA,EAAM,OAASvJ,GAClCwI,EAAO,KAAKe,CAAK,EACV,IACT,CACF,CAGA,SAAS0B,EAAYvI,EAAK1C,EAAM,CAC9B,GAAI,CAACA,EAAM,OAAO,KACdA,EAAK,OAAO0C,EAAI,OAAO,KAAK1C,EAAK,KAAK,EAC1C,GAAM,CACJ,SAAAmJ,EACA,UAAAwB,EACA,OAAAC,CACF,EAAIF,GAAiBhI,EAAI,OAAQ1C,CAAI,EAErC,GAAI2K,EAAW,CACb,GAAM,CACJ,QAAA3H,CACF,EAAIN,EACEiG,EAAO3I,EAAK,OACZgE,EAAOhB,EAAQ,QAAQ2F,CAAI,EAG7B3E,IAAMhB,EAAQ,IAAIA,EAAQ,QAAQ2F,CAAI,GAAK3E,GAI/ChB,EAAQ,IAAI2F,GAAQ3I,CACtB,CAEA,GAAIA,EAAK,OAASzB,EAAW,KAAK,QAAUoM,GAAaC,GAAS,CAChE,IAAM3I,EAAM,gDACZS,EAAI,OAAO,KAAK,IAAInE,EAAW,kBAAkByB,EAAMiC,CAAG,CAAC,CAC7D,CAEA,IAAM5C,EAAM0L,GAAiBrI,EAAK1C,CAAI,EAEtC,GAAIX,EAAK,CACPA,EAAI,MAAQ,CAACW,EAAK,MAAM,MAAOA,EAAK,MAAM,GAAG,EACzC0C,EAAI,QAAQ,eAAcrD,EAAI,QAAUW,GACxC0C,EAAI,QAAQ,gBAAerD,EAAI,KAAOW,EAAK,MAC/C,IAAMgC,EAAKmH,EAAS,OAAO,KAAK;AAAA,CAAI,EAEhCnH,IACF3C,EAAI,cAAgBA,EAAI,cAAgB,GAAGA,EAAI;AAAA,EAAkB2C,IAAOA,GAG1E,IAAMkJ,EAAK/B,EAAS,MAAM,KAAK;AAAA,CAAI,EAC/B+B,IAAI7L,EAAI,QAAUA,EAAI,QAAU,GAAGA,EAAI;AAAA,EAAY6L,IAAOA,EAChE,CAEA,OAAOlL,EAAK,SAAWX,CACzB,CAEA,SAAS8L,GAAWzI,EAAK+F,EAAK,CAC5B,GAAIA,EAAI,OAASlK,EAAW,KAAK,KAAOkK,EAAI,OAASlK,EAAW,KAAK,SAAU,CAC7E,IAAM0D,EAAM,KAAKwG,EAAI,4CACrB,OAAA/F,EAAI,OAAO,KAAK,IAAInE,EAAW,gBAAgBkK,EAAKxG,CAAG,CAAC,EACjD,IACT,CAEA,GAAM,CACJ,SAAAkH,EACA,MAAAtF,CACF,EAAI4E,EAAI,OAASlK,EAAW,KAAK,SAAW6M,GAAoB1I,EAAK+F,CAAG,EAAI4C,GAAqB3I,EAAK+F,CAAG,EACnGvG,EAAM,IAAI4B,GAChB5B,EAAI,MAAQ2B,EACZoF,GAAgB/G,EAAKiH,CAAQ,EAC7B,IAAImC,EAAmB,GAEvB,QAASnM,EAAI,EAAGA,EAAI0E,EAAM,OAAQ,EAAE1E,EAAG,CACrC,GAAM,CACJ,IAAKoM,CACP,EAAI1H,EAAM1E,GAGV,GAFIoM,aAAgB1L,IAAYyL,EAAmB,IAE/C5I,EAAI,OAAO,OAAS6I,GAAQA,EAAK,QAAUpH,GAAW,CACxDN,EAAM1E,GAAK,IAAIiF,GAAMP,EAAM1E,EAAE,EAC7B,IAAMqM,EAAU3H,EAAM1E,GAAG,MAAM,MAC3BoK,EAAQ,KACZiC,EAAQ,KAAKxL,GAAQ,CACnB,GAAIA,aAAgBiD,EAAO,CAGzB,GAAM,CACJ,KAAAqE,CACF,EAAItH,EAAK,OACT,OAAIsH,IAAS/I,EAAW,KAAK,KAAO+I,IAAS/I,EAAW,KAAK,SAAiB,GACvEgL,EAAQ,4CACjB,CAEA,OAAOA,EAAQ,iDACjB,CAAC,EACGA,GAAO7G,EAAI,OAAO,KAAK,IAAInE,EAAW,kBAAkBkK,EAAKc,CAAK,CAAC,CACzE,KACE,SAAShD,EAAIpH,EAAI,EAAGoH,EAAI1C,EAAM,OAAQ,EAAE0C,EAAG,CACzC,GAAM,CACJ,IAAKkF,CACP,EAAI5H,EAAM0C,GAEV,GAAIgF,IAASE,GAAQF,GAAQE,GAAQ,OAAO,UAAU,eAAe,KAAKF,EAAM,OAAO,GAAKA,EAAK,QAAUE,EAAK,MAAO,CACrH,IAAMxJ,EAAM,6BAA6BsJ,iBACzC7I,EAAI,OAAO,KAAK,IAAInE,EAAW,kBAAkBkK,EAAKxG,CAAG,CAAC,EAC1D,KACF,CACF,CAEJ,CAEA,GAAIqJ,GAAoB,CAAC5I,EAAI,QAAQ,SAAU,CAC7C,IAAMgJ,EAAO,2HACbhJ,EAAI,SAAS,KAAK,IAAInE,EAAW,YAAYkK,EAAKiD,CAAI,CAAC,CACzD,CAEA,OAAAjD,EAAI,SAAWvG,EACRA,CACT,CAEA,IAAMyJ,GAAsB,CAAC,CAC3B,QAAS,CACP,UAAAC,EACA,KAAA5L,EACA,IAAAgL,CACF,EACA,MAAAH,CACF,IAAM,CACJ,GAAIA,EAAM,SAAW,EAAG,MAAO,GAC/B,GAAM,CACJ,MAAA3J,CACF,EAAI2J,EAAM,GAEV,GADI7K,GAAQkB,EAAQlB,EAAK,WAAW,OAChCgL,EAAI9J,KAAW3C,EAAW,KAAK,QAAS,MAAO,GAEnD,QAAS,EAAIqN,EAAW,EAAI1K,EAAO,EAAE,EAAG,GAAI8J,EAAI,KAAO;AAAA,EAAM,MAAO,GAEpE,MAAO,EACT,EAEA,SAASa,GAAmB7K,EAAMoB,EAAM,CACtC,GAAI,CAACuJ,GAAoB3K,CAAI,EAAG,OAChC,IAAMrC,EAAUqC,EAAK,aAAa,EAAGzC,EAAW,KAAK,QAAS,EAAI,EAC9DuN,EAAQ,GACN9J,EAAKI,EAAK,MAAM,cAEtB,GAAIJ,GAAMA,EAAG,WAAWrD,CAAO,EAC7ByD,EAAK,MAAM,cAAgBJ,EAAG,OAAOrD,EAAQ,OAAS,CAAC,EACvDmN,EAAQ,OACH,CACL,IAAMC,EAAK3J,EAAK,MAAM,QAElB,CAACpB,EAAK,MAAQ+K,GAAMA,EAAG,WAAWpN,CAAO,IAC3CyD,EAAK,MAAM,QAAU2J,EAAG,OAAOpN,EAAQ,OAAS,CAAC,EACjDmN,EAAQ,GAEZ,CAEIA,IAAO1J,EAAK,QAAUzD,EAC5B,CAEA,SAAS0M,GAAqB3I,EAAK+F,EAAK,CACtC,IAAMU,EAAW,CAAC,EACZtF,EAAQ,CAAC,EACX/D,EACAkM,EAAW,KAEf,QAAS7M,EAAI,EAAGA,EAAIsJ,EAAI,MAAM,OAAQ,EAAEtJ,EAAG,CACzC,IAAM6B,EAAOyH,EAAI,MAAMtJ,GAEvB,OAAQ6B,EAAK,WACNzC,EAAW,KAAK,WACnB4K,EAAS,KAAK,CACZ,SAAU,CAAC,CAACrJ,EACZ,OAAQ+D,EAAM,MAChB,CAAC,EACD,WAEGtF,EAAW,KAAK,QACnB4K,EAAS,KAAK,CACZ,SAAU,CAAC,CAACrJ,EACZ,OAAQ+D,EAAM,OACd,QAAS7C,EAAK,OAChB,CAAC,EACD,WAEGzC,EAAW,KAAK,QACfuB,IAAQ,QAAW+D,EAAM,KAAK,IAAI9B,EAAKjC,CAAG,CAAC,EAC3CkB,EAAK,OAAO0B,EAAI,OAAO,KAAK1B,EAAK,KAAK,EAC1ClB,EAAMmL,EAAYvI,EAAK1B,EAAK,IAAI,EAChCgL,EAAW,KACX,WAEGzN,EAAW,KAAK,UACnB,CAIE,GAHIuB,IAAQ,SAAWA,EAAM,MACzBkB,EAAK,OAAO0B,EAAI,OAAO,KAAK1B,EAAK,KAAK,EAEtC,CAACA,EAAK,QAAQ,aAAeA,EAAK,MAAQA,EAAK,KAAK,OAASzC,EAAW,KAAK,KAAO,CAACyC,EAAK,KAAK,QAAQ,YAAa,CACtH,IAAMiB,EAAM,sDACZS,EAAI,OAAO,KAAK,IAAInE,EAAW,kBAAkByC,EAAK,KAAMiB,CAAG,CAAC,CAClE,CAEA,IAAIgK,EAAYjL,EAAK,KAErB,GAAI,CAACiL,GAAajL,EAAK,MAAM,OAAS,EAAG,CAIvCiL,EAAY,IAAI1N,EAAW,WAAWA,EAAW,KAAK,MAAO,CAAC,CAAC,EAC/D0N,EAAU,QAAU,CAClB,OAAQjL,EACR,IAAKA,EAAK,QAAQ,GACpB,EACA,IAAMkL,EAAMlL,EAAK,MAAM,MAAQ,EAU/B,GATAiL,EAAU,MAAQ,CAChB,MAAOC,EACP,IAAKA,CACP,EACAD,EAAU,WAAa,CACrB,MAAOC,EACP,IAAKA,CACP,EAEI,OAAOlL,EAAK,MAAM,WAAc,SAAU,CAC5C,IAAMmL,EAAUnL,EAAK,MAAM,UAAY,EACvCiL,EAAU,MAAM,UAAYA,EAAU,MAAM,QAAUE,EACtDF,EAAU,WAAW,UAAYA,EAAU,WAAW,QAAUE,CAClE,CACF,CAEA,IAAM/J,EAAO,IAAIL,EAAKjC,EAAKmL,EAAYvI,EAAKuJ,CAAS,CAAC,EACtDJ,GAAmB7K,EAAMoB,CAAI,EAC7ByB,EAAM,KAAKzB,CAAI,EAEXtC,GAAO,OAAOkM,GAAa,UACzBhL,EAAK,MAAM,MAAQgL,EAAW,MAAMtJ,EAAI,OAAO,KAAKqG,GAAgBN,EAAK3I,CAAG,CAAC,EAGnFA,EAAM,OACNkM,EAAW,IACb,CACA,cAGIlM,IAAQ,QAAW+D,EAAM,KAAK,IAAI9B,EAAKjC,CAAG,CAAC,EAC/CA,EAAMmL,EAAYvI,EAAK1B,CAAI,EAC3BgL,EAAWhL,EAAK,MAAM,MAClBA,EAAK,OAAO0B,EAAI,OAAO,KAAK1B,EAAK,KAAK,EAE1CsF,EAAM,QAASC,EAAIpH,EAAI,GAAI,EAAEoH,EAAG,CAC9B,IAAM6F,EAAW3D,EAAI,MAAMlC,GAE3B,OAAQ6F,GAAYA,EAAS,WACtB7N,EAAW,KAAK,gBAChBA,EAAW,KAAK,QACnB,SAAS+H,OAEN/H,EAAW,KAAK,UACnB,MAAM+H,UAGN,CACE,IAAMrE,EAAM,sDACZS,EAAI,OAAO,KAAK,IAAInE,EAAW,kBAAkByC,EAAMiB,CAAG,CAAC,EAC3D,MAAMqE,CACR,EAEN,CAEA,GAAItF,EAAK,0BAA2B,CAClC,IAAMiB,EAAM,gDACZS,EAAI,OAAO,KAAK,IAAInE,EAAW,kBAAkByC,EAAMiB,CAAG,CAAC,CAC7D,EAGN,CAEA,OAAInC,IAAQ,QAAW+D,EAAM,KAAK,IAAI9B,EAAKjC,CAAG,CAAC,EACxC,CACL,SAAAqJ,EACA,MAAAtF,CACF,CACF,CAEA,SAASuH,GAAoB1I,EAAK+F,EAAK,CACrC,IAAMU,EAAW,CAAC,EACZtF,EAAQ,CAAC,EACX/D,EACA2C,EAAc,GACd6D,EAAO,IAEX,QAASnH,EAAI,EAAGA,EAAIsJ,EAAI,MAAM,OAAQ,EAAEtJ,EAAG,CACzC,IAAM6B,EAAOyH,EAAI,MAAMtJ,GAEvB,GAAI,OAAO6B,EAAK,MAAS,SAAU,CACjC,GAAM,CACJ,KAAA0H,EACA,OAAA2D,CACF,EAAIrL,EAEJ,GAAI0H,IAAS,KAAO5I,IAAQ,QAAa,CAAC2C,EAAa,CACrDA,EAAc,GACd6D,EAAO,IACP,QACF,CAEA,GAAIoC,IAAS,KAGX,GAFI5I,IAAQ,SAAWA,EAAM,MAEzBwG,IAAS,IAAK,CAChBA,EAAO,IACP,QACF,UAEI7D,IACE3C,IAAQ,QAAa4I,IAAS,MAAK5I,EAAM,MAC7C2C,EAAc,IAGZ3C,IAAQ,SACV+D,EAAM,KAAK,IAAI9B,EAAKjC,CAAG,CAAC,EACxBA,EAAM,OAEF4I,IAAS,KAAK,CAChBpC,EAAO,IACP,QACF,CAIJ,GAAIoC,IAAS,KACX,GAAIvJ,IAAMsJ,EAAI,MAAM,OAAS,EAAG,iBACvBC,IAASpC,EAAM,CACxBA,EAAO,IACP,QACF,CAEA,IAAMrE,EAAM,mCAAmCyG,IACzCG,EAAM,IAAItK,EAAW,gBAAgBkK,EAAKxG,CAAG,EACnD4G,EAAI,OAASwD,EACb3J,EAAI,OAAO,KAAKmG,CAAG,CACrB,MAAW7H,EAAK,OAASzC,EAAW,KAAK,WACvC4K,EAAS,KAAK,CACZ,SAAU,CAAC,CAACrJ,EACZ,OAAQ+D,EAAM,MAChB,CAAC,EACQ7C,EAAK,OAASzC,EAAW,KAAK,SACvCuK,GAAsBpG,EAAI,OAAQ1B,CAAI,EACtCmI,EAAS,KAAK,CACZ,SAAU,CAAC,CAACrJ,EACZ,OAAQ+D,EAAM,OACd,QAAS7C,EAAK,OAChB,CAAC,GACQlB,IAAQ,QACbwG,IAAS,KAAK5D,EAAI,OAAO,KAAK,IAAInE,EAAW,kBAAkByC,EAAM,iCAAiC,CAAC,EAC3GlB,EAAMmL,EAAYvI,EAAK1B,CAAI,IAEvBsF,IAAS,KAAK5D,EAAI,OAAO,KAAK,IAAInE,EAAW,kBAAkByC,EAAM,uCAAuC,CAAC,EACjH6C,EAAM,KAAK,IAAI9B,EAAKjC,EAAKmL,EAAYvI,EAAK1B,CAAI,CAAC,CAAC,EAChDlB,EAAM,OACN2C,EAAc,GAElB,CAEA,OAAA8F,GAAuB7F,EAAI,OAAQ+F,CAAG,EAClC3I,IAAQ,QAAW+D,EAAM,KAAK,IAAI9B,EAAKjC,CAAG,CAAC,EACxC,CACL,SAAAqJ,EACA,MAAAtF,CACF,CACF,CAEA,SAASyI,GAAW5J,EAAK+F,EAAK,CAC5B,GAAIA,EAAI,OAASlK,EAAW,KAAK,KAAOkK,EAAI,OAASlK,EAAW,KAAK,SAAU,CAC7E,IAAM0D,EAAM,KAAKwG,EAAI,6CACrB,OAAA/F,EAAI,OAAO,KAAK,IAAInE,EAAW,gBAAgBkK,EAAKxG,CAAG,CAAC,EACjD,IACT,CAEA,GAAM,CACJ,SAAAkH,EACA,MAAAtF,CACF,EAAI4E,EAAI,OAASlK,EAAW,KAAK,SAAWgO,GAAoB7J,EAAK+F,CAAG,EAAI+D,GAAqB9J,EAAK+F,CAAG,EACnG7G,EAAM,IAAIH,EAIhB,GAHAG,EAAI,MAAQiC,EACZoF,GAAgBrH,EAAKuH,CAAQ,EAEzB,CAACzG,EAAI,QAAQ,UAAYmB,EAAM,KAAKnC,GAAMA,aAAcK,GAAQL,EAAG,eAAe7B,CAAU,EAAG,CACjG,IAAM6L,EAAO,2HACbhJ,EAAI,SAAS,KAAK,IAAInE,EAAW,YAAYkK,EAAKiD,CAAI,CAAC,CACzD,CAEA,OAAAjD,EAAI,SAAW7G,EACRA,CACT,CAEA,SAAS4K,GAAqB9J,EAAK+F,EAAK,CACtC,IAAMU,EAAW,CAAC,EACZtF,EAAQ,CAAC,EAEf,QAAS1E,EAAI,EAAGA,EAAIsJ,EAAI,MAAM,OAAQ,EAAEtJ,EAAG,CACzC,IAAM6B,EAAOyH,EAAI,MAAMtJ,GAEvB,OAAQ6B,EAAK,WACNzC,EAAW,KAAK,WACnB4K,EAAS,KAAK,CACZ,OAAQtF,EAAM,MAChB,CAAC,EACD,WAEGtF,EAAW,KAAK,QACnB4K,EAAS,KAAK,CACZ,QAASnI,EAAK,QACd,OAAQ6C,EAAM,MAChB,CAAC,EACD,WAEGtF,EAAW,KAAK,SAInB,GAHIyC,EAAK,OAAO0B,EAAI,OAAO,KAAK1B,EAAK,KAAK,EAC1C6C,EAAM,KAAKoH,EAAYvI,EAAK1B,EAAK,IAAI,CAAC,EAElCA,EAAK,SAAU,CACjB,IAAMiB,EAAM,oEACZS,EAAI,OAAO,KAAK,IAAInE,EAAW,kBAAkByC,EAAMiB,CAAG,CAAC,CAC7D,CAEA,cAGIjB,EAAK,OAAO0B,EAAI,OAAO,KAAK1B,EAAK,KAAK,EAC1C0B,EAAI,OAAO,KAAK,IAAInE,EAAW,gBAAgByC,EAAM,cAAcA,EAAK,uBAAuB,CAAC,EAEtG,CAEA,MAAO,CACL,SAAAmI,EACA,MAAAtF,CACF,CACF,CAEA,SAAS0I,GAAoB7J,EAAK+F,EAAK,CACrC,IAAMU,EAAW,CAAC,EACZtF,EAAQ,CAAC,EACXpB,EAAc,GACd3C,EACAkM,EAAW,KACX1F,EAAO,IACPmG,EAAW,KAEf,QAAStN,EAAI,EAAGA,EAAIsJ,EAAI,MAAM,OAAQ,EAAEtJ,EAAG,CACzC,IAAM6B,EAAOyH,EAAI,MAAMtJ,GAEvB,GAAI,OAAO6B,EAAK,MAAS,SAAU,CACjC,GAAM,CACJ,KAAA0H,EACA,OAAA2D,CACF,EAAIrL,EAUJ,GARI0H,IAAS,MAAQjG,GAAe3C,IAAQ,UACtC2C,GAAe3C,IAAQ,SAAWA,EAAMwG,EAAOzC,EAAM,IAAI,EAAI,MACjEA,EAAM,KAAK,IAAI9B,EAAKjC,CAAG,CAAC,EACxB2C,EAAc,GACd3C,EAAM,OACNkM,EAAW,MAGTtD,IAASpC,EACXA,EAAO,aACE,CAACA,GAAQoC,IAAS,IAC3BjG,EAAc,WACL6D,IAAS,KAAOoC,IAAS,KAAO5I,IAAQ,OAAW,CAC5D,GAAIwG,IAAS,IAAK,CAGhB,GAFAxG,EAAM+D,EAAM,IAAI,EAEZ/D,aAAeiC,EAAM,CACvB,IAAME,EAAM,0CACN4G,EAAM,IAAItK,EAAW,kBAAkBkK,EAAKxG,CAAG,EACrD4G,EAAI,OAASwD,EACb3J,EAAI,OAAO,KAAKmG,CAAG,CACrB,CAEA,GAAI,CAACpG,GAAe,OAAOuJ,GAAa,SAAU,CAChD,IAAMU,EAAS1L,EAAK,MAAQA,EAAK,MAAM,MAAQA,EAAK,OAChD0L,EAASV,EAAW,MAAMtJ,EAAI,OAAO,KAAKqG,GAAgBN,EAAK3I,CAAG,CAAC,EACvE,GAAM,CACJ,IAAAkL,CACF,EAAIyB,EAAS,QAEb,QAAStN,EAAI6M,EAAU7M,EAAIuN,EAAQ,EAAEvN,EAAG,GAAI6L,EAAI7L,KAAO;AAAA,EAAM,CAC3D,IAAM8C,EAAM,mEACZS,EAAI,OAAO,KAAK,IAAInE,EAAW,kBAAkBkO,EAAUxK,CAAG,CAAC,EAC/D,KACF,CACF,CACF,MACEnC,EAAM,KAGRkM,EAAW,KACXvJ,EAAc,GACd6D,EAAO,IACT,SAAWA,IAAS,KAAOoC,IAAS,KAAOvJ,EAAIsJ,EAAI,MAAM,OAAS,EAAG,CACnE,IAAMxG,EAAM,wCAAwCyG,IAC9CG,EAAM,IAAItK,EAAW,gBAAgBkK,EAAKxG,CAAG,EACnD4G,EAAI,OAASwD,EACb3J,EAAI,OAAO,KAAKmG,CAAG,CACrB,CACF,SAAW7H,EAAK,OAASzC,EAAW,KAAK,WACvC4K,EAAS,KAAK,CACZ,OAAQtF,EAAM,MAChB,CAAC,UACQ7C,EAAK,OAASzC,EAAW,KAAK,QACvCuK,GAAsBpG,EAAI,OAAQ1B,CAAI,EACtCmI,EAAS,KAAK,CACZ,QAASnI,EAAK,QACd,OAAQ6C,EAAM,MAChB,CAAC,MACI,CACL,GAAIyC,EAAM,CACR,IAAMrE,EAAM,cAAcqE,qBAC1B5D,EAAI,OAAO,KAAK,IAAInE,EAAW,kBAAkByC,EAAMiB,CAAG,CAAC,CAC7D,CAEA,IAAMlD,EAAQkM,EAAYvI,EAAK1B,CAAI,EAE/BlB,IAAQ,QACV+D,EAAM,KAAK9E,CAAK,EAChB0N,EAAWzL,IAEX6C,EAAM,KAAK,IAAI9B,EAAKjC,EAAKf,CAAK,CAAC,EAC/Be,EAAM,QAGRkM,EAAWhL,EAAK,MAAM,MACtBsF,EAAO,GACT,CACF,CAEA,OAAAiC,GAAuB7F,EAAI,OAAQ+F,CAAG,EAClC3I,IAAQ,QAAW+D,EAAM,KAAK,IAAI9B,EAAKjC,CAAG,CAAC,EACxC,CACL,SAAAqJ,EACA,MAAAtF,CACF,CACF,CAEAvF,EAAQ,MAAQ2E,EAChB3E,EAAQ,WAAauB,EACrBvB,EAAQ,MAAQ8F,GAChB9F,EAAQ,KAAOO,EACfP,EAAQ,KAAOyD,EACfzD,EAAQ,OAASgB,EACjBhB,EAAQ,QAAUwF,GAClBxF,EAAQ,QAAUmD,EAClBnD,EAAQ,WAAaM,GACrBN,EAAQ,cAAgBgG,GACxBhG,EAAQ,YAAciG,GACtBjG,EAAQ,SAAWsF,GACnBtF,EAAQ,WAAakG,GACrBlG,EAAQ,YAAcsB,GACtBtB,EAAQ,YAAcmG,GACtBnG,EAAQ,WAAa6M,GACrB7M,EAAQ,YAAc2M,EACtB3M,EAAQ,WAAagO,GACrBhO,EAAQ,cAAgBgL,GACxBhL,EAAQ,WAAaoG,GACrBpG,EAAQ,gBAAkB6J,GAC1B7J,EAAQ,gBAAkByJ,GAC1BzJ,EAAQ,OAASQ,IChnEjB,IAAA6N,GAAAC,EAAAC,GAAA,cAEA,IAAIC,EAAa,IACbC,EAAa,KAGXC,GAAS,CACb,SAAUC,GAASA,aAAiB,WAEpC,QAAS,GACT,IAAK,2BAUL,QAAS,CAACC,EAAKC,IAAS,CACtB,IAAMC,EAAML,EAAW,cAAcG,EAAKC,CAAI,EAE9C,GAAI,OAAO,QAAW,WACpB,OAAO,OAAO,KAAKC,EAAK,QAAQ,EAC3B,GAAI,OAAO,MAAS,WAAY,CAErC,IAAMC,EAAM,KAAKD,EAAI,QAAQ,UAAW,EAAE,CAAC,EACrCE,EAAS,IAAI,WAAWD,EAAI,MAAM,EAExC,QAAS,EAAI,EAAG,EAAIA,EAAI,OAAQ,EAAE,EAAGC,EAAO,GAAKD,EAAI,WAAW,CAAC,EAEjE,OAAOC,CACT,KAAO,CACL,IAAMC,EAAM,2FACZ,OAAAL,EAAI,OAAO,KAAK,IAAIJ,EAAW,mBAAmBK,EAAMI,CAAG,CAAC,EACrD,IACT,CACF,EACA,QAASR,EAAW,cACpB,UAAW,CAAC,CACV,QAAAS,EACA,KAAAC,EACA,MAAAR,CACF,EAAGS,EAAKC,EAAWC,IAAgB,CACjC,IAAIR,EAEJ,GAAI,OAAO,QAAW,WACpBA,EAAMH,aAAiB,OAASA,EAAM,SAAS,QAAQ,EAAI,OAAO,KAAKA,EAAM,MAAM,EAAE,SAAS,QAAQ,UAC7F,OAAO,MAAS,WAAY,CACrC,IAAIY,EAAI,GAER,QAASC,EAAI,EAAGA,EAAIb,EAAM,OAAQ,EAAEa,EAAGD,GAAK,OAAO,aAAaZ,EAAMa,EAAE,EAExEV,EAAM,KAAKS,CAAC,CACd,KACE,OAAM,IAAI,MAAM,0FAA0F,EAK5G,GAFKJ,IAAMA,EAAOV,EAAW,cAAc,aAEvCU,IAASX,EAAW,KAAK,aAC3BG,EAAQG,MACH,CACL,GAAM,CACJ,UAAAW,CACF,EAAIhB,EAAW,cACTiB,EAAI,KAAK,KAAKZ,EAAI,OAASW,CAAS,EACpCE,EAAQ,IAAI,MAAMD,CAAC,EAEzB,QAASF,EAAI,EAAGI,EAAI,EAAGJ,EAAIE,EAAG,EAAEF,EAAGI,GAAKH,EACtCE,EAAMH,GAAKV,EAAI,OAAOc,EAAGH,CAAS,EAGpCd,EAAQgB,EAAM,KAAKR,IAASX,EAAW,KAAK,cAAgB;AAAA,EAAO,GAAG,CACxE,CAEA,OAAOC,EAAW,gBAAgB,CAChC,QAAAS,EACA,KAAAC,EACA,MAAAR,CACF,EAAGS,EAAKC,EAAWC,CAAW,CAChC,CACF,EAEA,SAASO,GAAWjB,EAAKkB,EAAK,CAC5B,IAAMC,EAAMtB,EAAW,WAAWG,EAAKkB,CAAG,EAE1C,QAASN,EAAI,EAAGA,EAAIO,EAAI,MAAM,OAAQ,EAAEP,EAAG,CACzC,IAAIQ,EAAOD,EAAI,MAAMP,GACrB,GAAI,EAAAQ,aAAgBvB,EAAW,MAAoB,IAAIuB,aAAgBvB,EAAW,QAAS,CACzF,GAAIuB,EAAK,MAAM,OAAS,EAAG,CACzB,IAAMf,EAAM,iDACZ,MAAM,IAAIT,EAAW,kBAAkBsB,EAAKb,CAAG,CACjD,CAEA,IAAMgB,EAAOD,EAAK,MAAM,IAAM,IAAIvB,EAAW,KACzCuB,EAAK,gBAAeC,EAAK,cAAgBA,EAAK,cAAgB,GAAGD,EAAK;AAAA,EAAkBC,EAAK,gBAAkBD,EAAK,eACpHA,EAAK,UAASC,EAAK,QAAUA,EAAK,QAAU,GAAGD,EAAK;AAAA,EAAYC,EAAK,UAAYD,EAAK,SAC1FA,EAAOC,CACT,CACAF,EAAI,MAAMP,GAAKQ,aAAgBvB,EAAW,KAAOuB,EAAO,IAAIvB,EAAW,KAAKuB,CAAI,EAClF,CAEA,OAAOD,CACT,CACA,SAASG,GAAYC,EAAQC,EAAUhB,EAAK,CAC1C,IAAMiB,EAAQ,IAAI5B,EAAW,QAAQ0B,CAAM,EAC3CE,EAAM,IAAM,0BAEZ,QAAWC,KAAMF,EAAU,CACzB,IAAIG,EAAK5B,EAET,GAAI,MAAM,QAAQ2B,CAAE,EAClB,GAAIA,EAAG,SAAW,EAChBC,EAAMD,EAAG,GACT3B,EAAQ2B,EAAG,OACN,OAAM,IAAI,UAAU,gCAAgCA,GAAI,UACtDA,GAAMA,aAAc,OAAQ,CACrC,IAAME,EAAO,OAAO,KAAKF,CAAE,EAE3B,GAAIE,EAAK,SAAW,EAClBD,EAAMC,EAAK,GACX7B,EAAQ2B,EAAGC,OACN,OAAM,IAAI,UAAU,kCAAkCD,GAAI,CACnE,MACEC,EAAMD,EAGR,IAAML,EAAOE,EAAO,WAAWI,EAAK5B,EAAOS,CAAG,EAC9CiB,EAAM,MAAM,KAAKJ,CAAI,CACvB,CAEA,OAAOI,CACT,CACA,IAAMA,GAAQ,CACZ,QAAS,GACT,IAAK,0BACL,QAASR,GACT,WAAYK,EACd,EAEMO,EAAN,cAAuBhC,EAAW,OAAQ,CACxC,aAAc,CACZ,MAAM,EAEND,EAAW,gBAAgB,KAAM,MAAOC,EAAW,QAAQ,UAAU,IAAI,KAAK,IAAI,CAAC,EAEnFD,EAAW,gBAAgB,KAAM,SAAUC,EAAW,QAAQ,UAAU,OAAO,KAAK,IAAI,CAAC,EAEzFD,EAAW,gBAAgB,KAAM,MAAOC,EAAW,QAAQ,UAAU,IAAI,KAAK,IAAI,CAAC,EAEnFD,EAAW,gBAAgB,KAAM,MAAOC,EAAW,QAAQ,UAAU,IAAI,KAAK,IAAI,CAAC,EAEnFD,EAAW,gBAAgB,KAAM,MAAOC,EAAW,QAAQ,UAAU,IAAI,KAAK,IAAI,CAAC,EAEnF,KAAK,IAAMgC,EAAS,GACtB,CAEA,OAAOC,EAAGtB,EAAK,CACb,IAAMuB,EAAM,IAAI,IACZvB,GAAOA,EAAI,UAAUA,EAAI,SAASuB,CAAG,EAEzC,QAAWV,KAAQ,KAAK,MAAO,CAC7B,IAAIM,EAAK5B,EAST,GAPIsB,aAAgBxB,EAAW,MAC7B8B,EAAM9B,EAAW,OAAOwB,EAAK,IAAK,GAAIb,CAAG,EACzCT,EAAQF,EAAW,OAAOwB,EAAK,MAAOM,EAAKnB,CAAG,GAE9CmB,EAAM9B,EAAW,OAAOwB,EAAM,GAAIb,CAAG,EAGnCuB,EAAI,IAAIJ,CAAG,EAAG,MAAM,IAAI,MAAM,8CAA8C,EAChFI,EAAI,IAAIJ,EAAK5B,CAAK,CACpB,CAEA,OAAOgC,CACT,CAEF,EAEAnC,EAAW,gBAAgBiC,EAAU,MAAO,wBAAwB,EAEpE,SAASG,GAAUhC,EAAKkB,EAAK,CAC3B,IAAMO,EAAQR,GAAWjB,EAAKkB,CAAG,EAC3Be,EAAW,CAAC,EAElB,OAAW,CACT,IAAAN,CACF,IAAKF,EAAM,MACT,GAAIE,aAAe9B,EAAW,OAC5B,GAAIoC,EAAS,SAASN,EAAI,KAAK,EAAG,CAChC,IAAMtB,EAAM,+CACZ,MAAM,IAAIT,EAAW,kBAAkBsB,EAAKb,CAAG,CACjD,MACE4B,EAAS,KAAKN,EAAI,KAAK,EAK7B,OAAO,OAAO,OAAO,IAAIE,EAAYJ,CAAK,CAC5C,CAEA,SAASS,GAAWX,EAAQC,EAAUhB,EAAK,CACzC,IAAMiB,EAAQH,GAAYC,EAAQC,EAAUhB,CAAG,EACzC2B,EAAO,IAAIN,EACjB,OAAAM,EAAK,MAAQV,EAAM,MACZU,CACT,CAEA,IAAMA,GAAO,CACX,SAAUpC,GAASA,aAAiB,IACpC,UAAW8B,EACX,QAAS,GACT,IAAK,yBACL,QAASG,GACT,WAAYE,EACd,EAEME,EAAN,cAAsBvC,EAAW,OAAQ,CACvC,aAAc,CACZ,MAAM,EACN,KAAK,IAAMuC,EAAQ,GACrB,CAEA,IAAIT,EAAK,CACP,IAAMN,EAAOM,aAAe9B,EAAW,KAAO8B,EAAM,IAAI9B,EAAW,KAAK8B,CAAG,EAC9D9B,EAAW,SAAS,KAAK,MAAOwB,EAAK,GAAG,GAC1C,KAAK,MAAM,KAAKA,CAAI,CACjC,CAEA,IAAIM,EAAKU,EAAU,CACjB,IAAMhB,EAAOxB,EAAW,SAAS,KAAK,MAAO8B,CAAG,EAChD,MAAO,CAACU,GAAYhB,aAAgBxB,EAAW,KAAOwB,EAAK,eAAexB,EAAW,OAASwB,EAAK,IAAI,MAAQA,EAAK,IAAMA,CAC5H,CAEA,IAAIM,EAAK5B,EAAO,CACd,GAAI,OAAOA,GAAU,UAAW,MAAM,IAAI,MAAM,iEAAiE,OAAOA,GAAO,EAC/H,IAAMuC,EAAOzC,EAAW,SAAS,KAAK,MAAO8B,CAAG,EAE5CW,GAAQ,CAACvC,EACX,KAAK,MAAM,OAAO,KAAK,MAAM,QAAQuC,CAAI,EAAG,CAAC,EACpC,CAACA,GAAQvC,GAClB,KAAK,MAAM,KAAK,IAAIF,EAAW,KAAK8B,CAAG,CAAC,CAE5C,CAEA,OAAOG,EAAGtB,EAAK,CACb,OAAO,MAAM,OAAOsB,EAAGtB,EAAK,GAAG,CACjC,CAEA,SAASA,EAAKC,EAAWC,EAAa,CACpC,GAAI,CAACF,EAAK,OAAO,KAAK,UAAU,IAAI,EACpC,GAAI,KAAK,iBAAiB,EAAG,OAAO,MAAM,SAASA,EAAKC,EAAWC,CAAW,EAAO,MAAM,IAAI,MAAM,qCAAqC,CAC5I,CAEF,EAEAd,EAAW,gBAAgBwC,EAAS,MAAO,uBAAuB,EAElE,SAASG,GAASvC,EAAKkB,EAAK,CAC1B,IAAMa,EAAMlC,EAAW,WAAWG,EAAKkB,CAAG,EAC1C,GAAI,CAACa,EAAI,iBAAiB,EAAG,MAAM,IAAInC,EAAW,kBAAkBsB,EAAK,qCAAqC,EAC9G,OAAO,OAAO,OAAO,IAAIkB,EAAWL,CAAG,CACzC,CAEA,SAASS,GAAUjB,EAAQC,EAAUhB,EAAK,CACxC,IAAMiC,EAAM,IAAIL,EAEhB,QAAWrC,KAASyB,EAAUiB,EAAI,MAAM,KAAKlB,EAAO,WAAWxB,EAAO,KAAMS,CAAG,CAAC,EAEhF,OAAOiC,CACT,CAEA,IAAMA,GAAM,CACV,SAAU1C,GAASA,aAAiB,IACpC,UAAWqC,EACX,QAAS,GACT,IAAK,wBACL,QAASG,GACT,WAAYC,EACd,EAEME,GAAmB,CAACC,EAAMC,IAAU,CACxC,IAAM9B,EAAI8B,EAAM,MAAM,GAAG,EAAE,OAAO,CAAC,EAAGC,IAAM,EAAI,GAAK,OAAOA,CAAC,EAAG,CAAC,EACjE,OAAOF,IAAS,IAAM,CAAC7B,EAAIA,CAC7B,EAGMgC,GAAuB,CAAC,CAC5B,MAAA/C,CACF,IAAM,CACJ,GAAI,MAAMA,CAAK,GAAK,CAAC,SAASA,CAAK,EAAG,OAAOF,EAAW,gBAAgBE,CAAK,EAC7E,IAAI4C,EAAO,GAEP5C,EAAQ,IACV4C,EAAO,IACP5C,EAAQ,KAAK,IAAIA,CAAK,GAGxB,IAAM6C,EAAQ,CAAC7C,EAAQ,EAAE,EAEzB,OAAIA,EAAQ,GACV6C,EAAM,QAAQ,CAAC,GAEf7C,EAAQ,KAAK,OAAOA,EAAQ6C,EAAM,IAAM,EAAE,EAC1CA,EAAM,QAAQ7C,EAAQ,EAAE,EAEpBA,GAAS,KACXA,EAAQ,KAAK,OAAOA,EAAQ6C,EAAM,IAAM,EAAE,EAC1CA,EAAM,QAAQ7C,CAAK,IAIhB4C,EAAOC,EAAM,IAAI,GAAK,EAAI,GAAK,IAAM,OAAO,CAAC,EAAI,OAAO,CAAC,CAAC,EAAE,KAAK,GAAG,EAAE,QAAQ,aAAc,EAAE,CAEvG,EAEMG,GAAU,CACd,SAAUhD,GAAS,OAAOA,GAAU,SACpC,QAAS,GACT,IAAK,wBACL,OAAQ,OACR,KAAM,2CACN,QAAS,CAACI,EAAKwC,EAAMC,IAAUF,GAAiBC,EAAMC,EAAM,QAAQ,KAAM,EAAE,CAAC,EAC7E,UAAWE,EACb,EACME,GAAY,CAChB,SAAUjD,GAAS,OAAOA,GAAU,SACpC,QAAS,GACT,IAAK,0BACL,OAAQ,OACR,KAAM,oDACN,QAAS,CAACI,EAAKwC,EAAMC,IAAUF,GAAiBC,EAAMC,EAAM,QAAQ,KAAM,EAAE,CAAC,EAC7E,UAAWE,EACb,EACMG,GAAY,CAChB,SAAUlD,GAASA,aAAiB,KACpC,QAAS,GACT,IAAK,8BAIL,KAAM,OAAO,+JAIF,EACX,QAAS,CAACI,EAAK+C,EAAMC,EAAOC,EAAKC,EAAMC,EAAQC,EAAQC,EAAUC,IAAO,CAClED,IAAUA,GAAYA,EAAW,MAAM,OAAO,EAAG,CAAC,GACtD,IAAIE,EAAO,KAAK,IAAIR,EAAMC,EAAQ,EAAGC,EAAKC,GAAQ,EAAGC,GAAU,EAAGC,GAAU,EAAGC,GAAY,CAAC,EAE5F,GAAIC,GAAMA,IAAO,IAAK,CACpB,IAAIE,EAAIjB,GAAiBe,EAAG,GAAIA,EAAG,MAAM,CAAC,CAAC,EACvC,KAAK,IAAIE,CAAC,EAAI,KAAIA,GAAK,IAC3BD,GAAQ,IAAQC,CAClB,CAEA,OAAO,IAAI,KAAKD,CAAI,CACtB,EACA,UAAW,CAAC,CACV,MAAA3D,CACF,IAAMA,EAAM,YAAY,EAAE,QAAQ,yBAA0B,EAAE,CAChE,EAGA,SAAS6D,GAAWC,EAAa,CAC/B,IAAMC,EAAM,OAAO,QAAY,KAAe,QAAQ,KAAO,CAAC,EAE9D,OAAID,EACE,OAAO,kCAAsC,IAAoB,CAAC,kCAC/D,CAACC,EAAI,kCAGV,OAAO,sBAA0B,IAAoB,CAAC,sBACnD,CAACA,EAAI,qBACd,CAEA,SAASC,GAAKC,EAASzD,EAAM,CAC3B,GAAIqD,GAAW,EAAK,EAAG,CACrB,IAAMK,EAAO,OAAO,QAAY,KAAe,QAAQ,YAGnDA,EAAMA,EAAKD,EAASzD,CAAI,EAE1B,QAAQ,KAAKA,EAAO,GAAGA,MAASyD,IAAYA,CAAO,CAEvD,CACF,CACA,SAASE,GAAoBC,EAAU,CACrC,GAAIP,GAAW,EAAI,EAAG,CACpB,IAAMQ,EAAOD,EAAS,QAAQ,eAAgB,EAAE,EAAE,QAAQ,QAAS,EAAE,EAAE,QAAQ,MAAO,GAAG,EACzFJ,GAAK,sBAAsBK,0CAA8C,oBAAoB,CAC/F,CACF,CACA,IAAMC,GAAS,CAAC,EAChB,SAASC,GAAsBC,EAAMC,EAAa,CAChD,GAAI,CAACH,GAAOE,IAASX,GAAW,EAAI,EAAG,CACrCS,GAAOE,GAAQ,GACf,IAAIlE,EAAM,eAAekE,yCACzBlE,GAAOmE,EAAc,UAAUA,cAA0B,IACzDT,GAAK1D,EAAK,oBAAoB,CAChC,CACF,CAEAV,EAAQ,OAASG,GACjBH,EAAQ,UAAYqD,GACpBrD,EAAQ,QAAUoD,GAClBpD,EAAQ,KAAOwC,GACfxC,EAAQ,MAAQ8B,GAChB9B,EAAQ,IAAM8C,GACd9C,EAAQ,UAAYsD,GACpBtD,EAAQ,KAAOoE,GACfpE,EAAQ,oBAAsBuE,GAC9BvE,EAAQ,sBAAwB2E,KC/ZhC,IAAAG,GAAAC,EAAAC,IAAA,cAEA,IAAIC,GAAa,IACbC,EAAa,KACbC,EAAW,KAEf,SAASC,GAAUC,EAAQC,EAAKC,EAAK,CACnC,IAAMC,EAAM,IAAIN,EAAW,QAAQG,CAAM,EAEzC,GAAIC,aAAe,IACjB,OAAW,CAACG,EAAKC,CAAK,IAAKJ,EAAKE,EAAI,MAAM,KAAKH,EAAO,WAAWI,EAAKC,EAAOH,CAAG,CAAC,UACxED,GAAO,OAAOA,GAAQ,SAC/B,QAAWG,KAAO,OAAO,KAAKH,CAAG,EAAGE,EAAI,MAAM,KAAKH,EAAO,WAAWI,EAAKH,EAAIG,GAAMF,CAAG,CAAC,EAG1F,OAAI,OAAOF,EAAO,gBAAmB,YACnCG,EAAI,MAAM,KAAKH,EAAO,cAAc,EAG/BG,CACT,CAEA,IAAMA,GAAM,CACV,WAAYJ,GACZ,QAAS,GACT,UAAWF,EAAW,QACtB,IAAK,wBACL,QAASA,EAAW,UACtB,EAEA,SAASS,GAAUN,EAAQC,EAAKC,EAAK,CACnC,IAAMK,EAAM,IAAIV,EAAW,QAAQG,CAAM,EAEzC,GAAIC,GAAOA,EAAI,OAAO,UACpB,QAAWO,KAAMP,EAAK,CACpB,IAAMQ,EAAIT,EAAO,WAAWQ,EAAIN,EAAI,YAAa,KAAMA,CAAG,EAC1DK,EAAI,MAAM,KAAKE,CAAC,CAClB,CAGF,OAAOF,CACT,CAEA,IAAMA,GAAM,CACV,WAAYD,GACZ,QAAS,GACT,UAAWT,EAAW,QACtB,IAAK,wBACL,QAASA,EAAW,UACtB,EAEMa,GAAS,CACb,SAAUL,GAAS,OAAOA,GAAU,SACpC,QAAS,GACT,IAAK,wBACL,QAASR,EAAW,cAEpB,UAAUc,EAAMT,EAAKU,EAAWC,EAAa,CAC3C,OAAAX,EAAM,OAAO,OAAO,CAClB,aAAc,EAChB,EAAGA,CAAG,EACCL,EAAW,gBAAgBc,EAAMT,EAAKU,EAAWC,CAAW,CACrE,EAEA,QAAShB,EAAW,UACtB,EAEMiB,GAAW,CAACX,GAAKI,GAAKG,EAAM,EAI5BK,GAAgBV,GAAS,OAAOA,GAAU,UAAY,OAAO,UAAUA,CAAK,EAE5EW,GAAe,CAACC,EAAKC,EAAMC,IAAUtB,EAAW,WAAW,SAAW,OAAOoB,CAAG,EAAI,SAASC,EAAMC,CAAK,EAE9G,SAASC,GAAeC,EAAMF,EAAOG,EAAQ,CAC3C,GAAM,CACJ,MAAAjB,CACF,EAAIgB,EACJ,OAAIN,GAAcV,CAAK,GAAKA,GAAS,EAAUiB,EAASjB,EAAM,SAASc,CAAK,EACrEtB,EAAW,gBAAgBwB,CAAI,CACxC,CAEA,IAAME,GAAU,CACd,SAAUlB,GAASA,GAAS,KAC5B,WAAY,CAACL,EAAQK,EAAOH,IAAQA,EAAI,YAAc,IAAIL,EAAW,OAAO,IAAI,EAAI,KACpF,QAAS,GACT,IAAK,yBACL,KAAM,wBACN,QAAS,IAAM,KACf,QAASA,EAAW,YACpB,UAAW,IAAMA,EAAW,YAAY,OAC1C,EACM2B,GAAU,CACd,SAAUnB,GAAS,OAAOA,GAAU,UACpC,QAAS,GACT,IAAK,yBACL,KAAM,oCACN,QAASoB,GAAOA,EAAI,KAAO,KAAOA,EAAI,KAAO,IAC7C,QAAS5B,EAAW,YACpB,UAAW,CAAC,CACV,MAAAQ,CACF,IAAMA,EAAQR,EAAW,YAAY,QAAUA,EAAW,YAAY,QACxE,EACM6B,GAAS,CACb,SAAUrB,GAASU,GAAcV,CAAK,GAAKA,GAAS,EACpD,QAAS,GACT,IAAK,wBACL,OAAQ,MACR,KAAM,eACN,QAAS,CAACoB,EAAKE,IAAQX,GAAaS,EAAKE,EAAK,CAAC,EAC/C,QAAS9B,EAAW,WACpB,UAAWwB,GAAQD,GAAeC,EAAM,EAAG,IAAI,CACjD,EACMO,GAAS,CACb,SAAUb,GACV,QAAS,GACT,IAAK,wBACL,KAAM,gBACN,QAASU,GAAOT,GAAaS,EAAKA,EAAK,EAAE,EACzC,QAAS5B,EAAW,WACpB,UAAWA,EAAW,eACxB,EACMgC,GAAS,CACb,SAAUxB,GAASU,GAAcV,CAAK,GAAKA,GAAS,EACpD,QAAS,GACT,IAAK,wBACL,OAAQ,MACR,KAAM,qBACN,QAAS,CAACoB,EAAKK,IAAQd,GAAaS,EAAKK,EAAK,EAAE,EAChD,QAASjC,EAAW,WACpB,UAAWwB,GAAQD,GAAeC,EAAM,GAAI,IAAI,CAClD,EACMU,GAAS,CACb,SAAU1B,GAAS,OAAOA,GAAU,SACpC,QAAS,GACT,IAAK,0BACL,KAAM,4BACN,QAAS,CAACoB,EAAKO,IAAQA,EAAM,IAAMP,EAAI,KAAO,IAAM,OAAO,kBAAoB,OAAO,kBACtF,UAAW5B,EAAW,eACxB,EACMoC,GAAS,CACb,SAAU5B,GAAS,OAAOA,GAAU,SACpC,QAAS,GACT,IAAK,0BACL,OAAQ,MACR,KAAM,yDACN,QAASoB,GAAO,WAAWA,CAAG,EAC9B,UAAW,CAAC,CACV,MAAApB,CACF,IAAM,OAAOA,CAAK,EAAE,cAAc,CACpC,EACM6B,GAAW,CACf,SAAU7B,GAAS,OAAOA,GAAU,SACpC,QAAS,GACT,IAAK,0BACL,KAAM,yCAEN,QAAQoB,EAAKU,EAAOC,EAAO,CACzB,IAAMC,EAAOF,GAASC,EAChBf,EAAO,IAAIxB,EAAW,OAAO,WAAW4B,CAAG,CAAC,EAClD,OAAIY,GAAQA,EAAKA,EAAK,OAAS,KAAO,MAAKhB,EAAK,kBAAoBgB,EAAK,QAClEhB,CACT,EAEA,UAAWxB,EAAW,eACxB,EACMyC,GAAOxB,GAAS,OAAO,CAACS,GAASC,GAASE,GAAQE,GAAQC,GAAQE,GAAQE,GAAQC,EAAQ,CAAC,EAI3FK,GAAgBlC,GAAS,OAAOA,GAAU,UAAY,OAAO,UAAUA,CAAK,EAE5EmC,GAAgB,CAAC,CACrB,MAAAnC,CACF,IAAM,KAAK,UAAUA,CAAK,EAEpBoC,GAAO,CAACtC,GAAKI,GAAK,CACtB,SAAUF,GAAS,OAAOA,GAAU,SACpC,QAAS,GACT,IAAK,wBACL,QAASR,EAAW,cACpB,UAAW2C,EACb,EAAG,CACD,SAAUnC,GAASA,GAAS,KAC5B,WAAY,CAACL,EAAQK,EAAOH,IAAQA,EAAI,YAAc,IAAIL,EAAW,OAAO,IAAI,EAAI,KACpF,QAAS,GACT,IAAK,yBACL,KAAM,SACN,QAAS,IAAM,KACf,UAAW2C,EACb,EAAG,CACD,SAAUnC,GAAS,OAAOA,GAAU,UACpC,QAAS,GACT,IAAK,yBACL,KAAM,eACN,QAASoB,GAAOA,IAAQ,OACxB,UAAWe,EACb,EAAG,CACD,SAAUD,GACV,QAAS,GACT,IAAK,wBACL,KAAM,wBACN,QAASd,GAAO5B,EAAW,WAAW,SAAW,OAAO4B,CAAG,EAAI,SAASA,EAAK,EAAE,EAC/E,UAAW,CAAC,CACV,MAAApB,CACF,IAAMkC,GAAclC,CAAK,EAAIA,EAAM,SAAS,EAAI,KAAK,UAAUA,CAAK,CACtE,EAAG,CACD,SAAUA,GAAS,OAAOA,GAAU,SACpC,QAAS,GACT,IAAK,0BACL,KAAM,yDACN,QAASoB,GAAO,WAAWA,CAAG,EAC9B,UAAWe,EACb,CAAC,EAEDC,GAAK,eAAiBhB,GAAO,CAC3B,MAAM,IAAI,YAAY,2BAA2B,KAAK,UAAUA,CAAG,GAAG,CACxE,EAIA,IAAMiB,GAAgB,CAAC,CACrB,MAAArC,CACF,IAAMA,EAAQR,EAAW,YAAY,QAAUA,EAAW,YAAY,SAEhE8C,GAActC,GAAS,OAAOA,GAAU,UAAY,OAAO,UAAUA,CAAK,EAEhF,SAASuC,GAAWC,EAAM5B,EAAKE,EAAO,CACpC,IAAIM,EAAMR,EAAI,QAAQ,KAAM,EAAE,EAE9B,GAAIpB,EAAW,WAAW,SAAU,CAClC,OAAQsB,OACD,GACHM,EAAM,KAAKA,IACX,UAEG,GACHA,EAAM,KAAKA,IACX,UAEG,IACHA,EAAM,KAAKA,IACX,MAGJ,IAAMqB,EAAI,OAAOrB,CAAG,EACpB,OAAOoB,IAAS,IAAM,OAAO,EAAE,EAAIC,EAAIA,CACzC,CAEA,IAAMA,EAAI,SAASrB,EAAKN,CAAK,EAC7B,OAAO0B,IAAS,IAAM,GAAKC,EAAIA,CACjC,CAEA,SAASC,GAAa1B,EAAMF,EAAOG,EAAQ,CACzC,GAAM,CACJ,MAAAjB,CACF,EAAIgB,EAEJ,GAAIsB,GAAYtC,CAAK,EAAG,CACtB,IAAMoB,EAAMpB,EAAM,SAASc,CAAK,EAChC,OAAOd,EAAQ,EAAI,IAAMiB,EAASG,EAAI,OAAO,CAAC,EAAIH,EAASG,CAC7D,CAEA,OAAO5B,EAAW,gBAAgBwB,CAAI,CACxC,CAEA,IAAM2B,GAASlC,GAAS,OAAO,CAAC,CAC9B,SAAUT,GAASA,GAAS,KAC5B,WAAY,CAACL,EAAQK,EAAOH,IAAQA,EAAI,YAAc,IAAIL,EAAW,OAAO,IAAI,EAAI,KACpF,QAAS,GACT,IAAK,yBACL,KAAM,wBACN,QAAS,IAAM,KACf,QAASA,EAAW,YACpB,UAAW,IAAMA,EAAW,YAAY,OAC1C,EAAG,CACD,SAAUQ,GAAS,OAAOA,GAAU,UACpC,QAAS,GACT,IAAK,yBACL,KAAM,6CACN,QAAS,IAAM,GACf,QAASR,EAAW,YACpB,UAAW6C,EACb,EAAG,CACD,SAAUrC,GAAS,OAAOA,GAAU,UACpC,QAAS,GACT,IAAK,yBACL,KAAM,gDACN,QAAS,IAAM,GACf,QAASR,EAAW,YACpB,UAAW6C,EACb,EAAG,CACD,SAAUC,GACV,QAAS,GACT,IAAK,wBACL,OAAQ,MACR,KAAM,uBACN,QAAS,CAAClB,EAAKoB,EAAMI,IAAQL,GAAWC,EAAMI,EAAK,CAAC,EACpD,UAAW5B,GAAQ0B,GAAa1B,EAAM,EAAG,IAAI,CAC/C,EAAG,CACD,SAAUsB,GACV,QAAS,GACT,IAAK,wBACL,OAAQ,MACR,KAAM,sBACN,QAAS,CAAClB,EAAKoB,EAAMlB,IAAQiB,GAAWC,EAAMlB,EAAK,CAAC,EACpD,UAAWN,GAAQ0B,GAAa1B,EAAM,EAAG,GAAG,CAC9C,EAAG,CACD,SAAUsB,GACV,QAAS,GACT,IAAK,wBACL,KAAM,0BACN,QAAS,CAAClB,EAAKoB,EAAMK,IAAQN,GAAWC,EAAMK,EAAK,EAAE,EACrD,UAAWrD,EAAW,eACxB,EAAG,CACD,SAAU8C,GACV,QAAS,GACT,IAAK,wBACL,OAAQ,MACR,KAAM,6BACN,QAAS,CAAClB,EAAKoB,EAAMf,IAAQc,GAAWC,EAAMf,EAAK,EAAE,EACrD,UAAWT,GAAQ0B,GAAa1B,EAAM,GAAI,IAAI,CAChD,EAAG,CACD,SAAUhB,GAAS,OAAOA,GAAU,SACpC,QAAS,GACT,IAAK,0BACL,KAAM,4BACN,QAAS,CAACoB,EAAKO,IAAQA,EAAM,IAAMP,EAAI,KAAO,IAAM,OAAO,kBAAoB,OAAO,kBACtF,UAAW5B,EAAW,eACxB,EAAG,CACD,SAAUQ,GAAS,OAAOA,GAAU,SACpC,QAAS,GACT,IAAK,0BACL,OAAQ,MACR,KAAM,oDACN,QAASoB,GAAO,WAAWA,EAAI,QAAQ,KAAM,EAAE,CAAC,EAChD,UAAW,CAAC,CACV,MAAApB,CACF,IAAM,OAAOA,CAAK,EAAE,cAAc,CACpC,EAAG,CACD,SAAUA,GAAS,OAAOA,GAAU,SACpC,QAAS,GACT,IAAK,0BACL,KAAM,sCAEN,QAAQoB,EAAKY,EAAM,CACjB,IAAMhB,EAAO,IAAIxB,EAAW,OAAO,WAAW4B,EAAI,QAAQ,KAAM,EAAE,CAAC,CAAC,EAEpE,GAAIY,EAAM,CACR,IAAMc,EAAId,EAAK,QAAQ,KAAM,EAAE,EAC3Bc,EAAEA,EAAE,OAAS,KAAO,MAAK9B,EAAK,kBAAoB8B,EAAE,OAC1D,CAEA,OAAO9B,CACT,EAEA,UAAWxB,EAAW,eACxB,CAAC,EAAGC,EAAS,OAAQA,EAAS,KAAMA,EAAS,MAAOA,EAAS,IAAKA,EAAS,QAASA,EAAS,UAAWA,EAAS,SAAS,EAEpHsD,GAAU,CACd,KAAAd,GACA,SAAAxB,GACA,KAAA2B,GACA,OAAAO,EACF,EACMK,GAAO,CACX,OAAQvD,EAAS,OACjB,KAAM0B,GACN,MAAOU,GACP,SAAUD,GACV,SAAUF,GACV,UAAWjC,EAAS,UACpB,IAAK8B,GACL,OAAQC,GACR,OAAQH,GACR,QAAS5B,EAAS,QAClB,IAAAK,GACA,KAAMoB,GACN,KAAMzB,EAAS,KACf,MAAOA,EAAS,MAChB,IAAAS,GACA,IAAKT,EAAS,IACd,UAAWA,EAAS,SACtB,EAEA,SAASwD,GAAcjD,EAAOkD,EAASF,EAAM,CAC3C,GAAIE,EAAS,CACX,IAAMC,EAAQH,EAAK,OAAOI,GAAKA,EAAE,MAAQF,CAAO,EAC1CG,EAASF,EAAM,KAAKC,GAAK,CAACA,EAAE,MAAM,GAAKD,EAAM,GACnD,GAAI,CAACE,EAAQ,MAAM,IAAI,MAAM,OAAOH,aAAmB,EACvD,OAAOG,CACT,CAGA,OAAOL,EAAK,KAAKI,IAAMA,EAAE,UAAYA,EAAE,SAASpD,CAAK,GAAKoD,EAAE,OAASpD,aAAiBoD,EAAE,QAAU,CAACA,EAAE,MAAM,CAC7G,CAEA,SAASE,GAAWtD,EAAOkD,EAASrD,EAAK,CACvC,GAAIG,aAAiBR,EAAW,KAAM,OAAOQ,EAC7C,GAAM,CACJ,cAAAuD,EACA,SAAAC,EACA,YAAAC,EACA,OAAA9D,EACA,YAAA+D,CACF,EAAI7D,EACAqD,GAAWA,EAAQ,WAAW,IAAI,IAAGA,EAAUK,EAAgBL,EAAQ,MAAM,CAAC,GAClF,IAAIG,EAASJ,GAAcjD,EAAOkD,EAASvD,EAAO,IAAI,EAEtD,GAAI,CAAC0D,EAAQ,CAEX,GADI,OAAOrD,EAAM,QAAW,aAAYA,EAAQA,EAAM,OAAO,GACzD,CAACA,GAAS,OAAOA,GAAU,SAAU,OAAO0D,EAAc,IAAIlE,EAAW,OAAOQ,CAAK,EAAIA,EAC7FqD,EAASrD,aAAiB,IAAMF,GAAME,EAAM,OAAO,UAAYE,GAAMJ,EACvE,CAEI0D,IACFA,EAASH,CAAM,EACf,OAAOxD,EAAI,UAKb,IAAMD,EAAM,CACV,MAAO,OACP,KAAM,MACR,EAEA,GAAII,GAAS,OAAOA,GAAU,UAAYyD,EAAa,CACrD,IAAME,EAAOF,EAAY,IAAIzD,CAAK,EAElC,GAAI2D,EAAM,CACR,IAAMC,EAAQ,IAAIpE,EAAW,MAAMmE,CAAI,EAEvC,OAAA9D,EAAI,WAAW,KAAK+D,CAAK,EAElBA,CACT,CAEAhE,EAAI,MAAQI,EACZyD,EAAY,IAAIzD,EAAOJ,CAAG,CAC5B,CAEA,OAAAA,EAAI,KAAOyD,EAAO,WAAaA,EAAO,WAAWxD,EAAI,OAAQG,EAAOH,CAAG,EAAI6D,EAAc,IAAIlE,EAAW,OAAOQ,CAAK,EAAIA,EACpHkD,GAAWtD,EAAI,gBAAgBJ,EAAW,OAAMI,EAAI,KAAK,IAAMsD,GAC5DtD,EAAI,IACb,CAEA,SAASiE,GAAcd,EAASe,EAAWC,EAAYC,EAAU,CAC/D,IAAIhB,EAAOD,EAAQiB,EAAS,QAAQ,MAAO,EAAE,GAE7C,GAAI,CAAChB,EAAM,CACT,IAAMiB,EAAO,OAAO,KAAKlB,CAAO,EAAE,IAAIhD,GAAO,KAAK,UAAUA,CAAG,CAAC,EAAE,KAAK,IAAI,EAC3E,MAAM,IAAI,MAAM,mBAAmBiE,kBAAyBC,GAAM,CACpE,CAEA,GAAI,MAAM,QAAQF,CAAU,EAC1B,QAAWG,KAAOH,EAAYf,EAAOA,EAAK,OAAOkB,CAAG,OAC3C,OAAOH,GAAe,aAC/Bf,EAAOe,EAAWf,EAAK,MAAM,CAAC,GAGhC,QAAS,EAAI,EAAG,EAAIA,EAAK,OAAQ,EAAE,EAAG,CACpC,IAAMkB,EAAMlB,EAAK,GAEjB,GAAI,OAAOkB,GAAQ,SAAU,CAC3B,IAAMb,EAASS,EAAUI,GAEzB,GAAI,CAACb,EAAQ,CACX,IAAMY,EAAO,OAAO,KAAKH,CAAS,EAAE,IAAI/D,GAAO,KAAK,UAAUA,CAAG,CAAC,EAAE,KAAK,IAAI,EAC7E,MAAM,IAAI,MAAM,uBAAuBmE,kBAAoBD,GAAM,CACnE,CAEAjB,EAAK,GAAKK,CACZ,CACF,CAEA,OAAOL,CACT,CAEA,IAAMmB,GAAsB,CAACC,EAAGC,IAAMD,EAAE,IAAMC,EAAE,IAAM,GAAKD,EAAE,IAAMC,EAAE,IAAM,EAAI,EAEzEC,GAAN,KAAa,CAGX,YAAY,CACV,WAAAP,EACA,MAAAQ,EACA,OAAA5E,EACA,eAAA6E,EACA,KAAMC,CACR,EAAG,CACD,KAAK,MAAQ,CAAC,CAACF,EACf,KAAK,KAAO5E,EACZ,KAAK,eAAiB6E,IAAmB,GAAOL,GAAsBK,GAAkB,KACpF,CAACT,GAAcU,GAAsBhF,EAAS,sBAAsB,OAAQ,YAAY,EAC5F,KAAK,KAAOoE,GAAcd,GAASC,GAAMe,GAAcU,EAAsB9E,CAAM,CACrF,CAEA,WAAWK,EAAO0D,EAAaR,EAASrD,EAAK,CAC3C,IAAM6E,EAAU,CACd,cAAeJ,GAAO,cACtB,OAAQ,KACR,YAAAZ,CACF,EACMiB,EAAY9E,EAAM,OAAO,OAAOA,EAAK6E,CAAO,EAAIA,EACtD,OAAOpB,GAAWtD,EAAOkD,EAASyB,CAAS,CAC7C,CAEA,WAAW5E,EAAKC,EAAOH,EAAK,CACrBA,IAAKA,EAAM,CACd,YAAa,EACf,GACA,IAAM+E,EAAI,KAAK,WAAW7E,EAAKF,EAAI,YAAa,KAAMA,CAAG,EACnDO,EAAI,KAAK,WAAWJ,EAAOH,EAAI,YAAa,KAAMA,CAAG,EAC3D,OAAO,IAAIL,EAAW,KAAKoF,EAAGxE,CAAC,CACjC,CAEF,EAEAb,GAAW,gBAAgB+E,GAAQ,gBAAiB/E,GAAW,gBAAgB,EAE/EA,GAAW,gBAAgB+E,GAAQ,cAAe/E,GAAW,WAAW,EAExED,GAAQ,OAASgF,KC5gBjB,IAAAO,GAAAC,EAAAC,IAAA,cAEA,IAAIC,EAAa,IACbC,EAAa,KACbC,GAAS,KAEPC,GAAiB,CACrB,aAAc,IACd,WAAY,KACZ,OAAQ,EACR,UAAW,GACX,aAAc,GACd,cAAe,GACf,gBAAiB,GACjB,SAAU,GACV,cAAe,IACf,aAAc,GAEd,WAAY,GACZ,QAAS,KACX,EACMC,GAAgB,CACpB,IAAI,QAAS,CACX,OAAOH,EAAW,aACpB,EAEA,IAAI,OAAOI,EAAK,CACd,OAAO,OAAOJ,EAAW,cAAeI,CAAG,CAC7C,EAEA,IAAI,MAAO,CACT,OAAOJ,EAAW,WACpB,EAEA,IAAI,KAAKI,EAAK,CACZ,OAAO,OAAOJ,EAAW,YAAaI,CAAG,CAC3C,EAEA,IAAI,KAAM,CACR,OAAOJ,EAAW,UACpB,EAEA,IAAI,IAAII,EAAK,CACX,OAAO,OAAOJ,EAAW,WAAYI,CAAG,CAC1C,EAEA,IAAI,MAAO,CACT,OAAOJ,EAAW,WACpB,EAEA,IAAI,KAAKI,EAAK,CACZ,OAAO,OAAOJ,EAAW,YAAaI,CAAG,CAC3C,EAEA,IAAI,KAAM,CACR,OAAOJ,EAAW,UACpB,EAEA,IAAI,IAAII,EAAK,CACX,OAAO,OAAOJ,EAAW,WAAYI,CAAG,CAC1C,CAEF,EACMC,GAAkB,CACtB,MAAO,CACL,OAAQ,WACR,MAAO,GACP,YAAa,CAAC,CACZ,OAAQ,IACR,OAAQN,EAAW,gBACrB,EAAG,CACD,OAAQ,KACR,OAAQ,4BACV,CAAC,CACH,EACA,IAAK,CACH,OAAQ,WACR,MAAO,GACP,YAAa,CAAC,CACZ,OAAQ,IACR,OAAQ,GACV,EAAG,CACD,OAAQ,KACR,OAAQA,EAAW,gBACrB,CAAC,CACH,EACA,IAAK,CACH,OAAQ,OACR,MAAO,GACP,YAAa,CAAC,CACZ,OAAQ,IACR,OAAQ,GACV,EAAG,CACD,OAAQ,KACR,OAAQA,EAAW,gBACrB,CAAC,CACH,CACF,EAEA,SAASO,GAAaC,EAAKC,EAAK,CAC9B,IAAKD,EAAI,SAAWA,EAAI,QAAQ,WAAa,MAAO,CAClD,IAAME,EAAOD,EAAI,MAAM,wCAAwC,EAC/D,GAAIC,EAAM,MAAO,IAAMA,EAAK,GAC5B,IAAMC,EAAQF,EAAI,MAAM,2CAA2C,EACnE,OAAOE,EAAQ,IAAIA,EAAM,MAAMA,EAAM,KAAO,IAAIF,EAAI,QAAQ,QAAS,EAAE,GACzE,CAEA,IAAIG,EAAIJ,EAAI,YAAY,KAAKI,GAAKH,EAAI,QAAQG,EAAE,MAAM,IAAM,CAAC,EAE7D,GAAI,CAACA,EAAG,CACN,IAAMC,EAAML,EAAI,YAAY,EAAE,YAC9BI,EAAIC,GAAOA,EAAI,KAAKD,GAAKH,EAAI,QAAQG,EAAE,MAAM,IAAM,CAAC,CACtD,CAEA,GAAI,CAACA,EAAG,OAAOH,EAAI,KAAO,IAAMA,EAAM,KAAKA,KAC3C,IAAMK,EAASL,EAAI,OAAOG,EAAE,OAAO,MAAM,EAAE,QAAQ,aAAcG,IAAO,CACtE,IAAK,MACL,IAAK,MACL,IAAK,MACL,IAAK,MACL,IAAK,MACL,IAAK,KACP,GAAGA,EAAG,EACN,OAAOH,EAAE,OAASE,CACpB,CAEA,SAASE,GAAaC,EAAMC,EAAM,CAChC,GAAIA,aAAgBjB,EAAW,MAAO,OAAOA,EAAW,MAExD,GAAIiB,EAAK,IAAK,CACZ,IAAMC,EAAQF,EAAK,OAAOG,GAAKA,EAAE,MAAQF,EAAK,GAAG,EACjD,GAAIC,EAAM,OAAS,EAAG,OAAOA,EAAM,KAAKC,GAAKA,EAAE,SAAWF,EAAK,MAAM,GAAKC,EAAM,EAClF,CAEA,IAAIE,EAAQC,EAEZ,GAAIJ,aAAgBjB,EAAW,OAAQ,CACrCqB,EAAMJ,EAAK,MAEX,IAAMC,EAAQF,EAAK,OAAOG,GAAKA,EAAE,UAAYA,EAAE,SAASE,CAAG,GAAKF,EAAE,OAASE,aAAeF,EAAE,KAAK,EACjGC,EAASF,EAAM,KAAKC,GAAKA,EAAE,SAAWF,EAAK,MAAM,GAAKC,EAAM,KAAKC,GAAK,CAACA,EAAE,MAAM,CACjF,MACEE,EAAMJ,EACNG,EAASJ,EAAK,KAAKG,GAAKA,EAAE,WAAaE,aAAeF,EAAE,SAAS,EAGnE,GAAI,CAACC,EAAQ,CACX,IAAME,EAAOD,GAAOA,EAAI,YAAcA,EAAI,YAAY,KAAO,OAAOA,EACpE,MAAM,IAAI,MAAM,wBAAwBC,SAAY,CACtD,CAEA,OAAOF,CACT,CAGA,SAASG,GAAeC,EAAMJ,EAAQ,CACpC,QAAAK,EACA,IAAAlB,CACF,EAAG,CACD,IAAMmB,EAAQ,CAAC,EACTC,EAASpB,EAAI,QAAQ,QAAQiB,CAAI,EAEvC,OAAIG,IACFF,EAAQE,GAAUH,EAClBE,EAAM,KAAK,IAAIC,GAAQ,GAGrBH,EAAK,IACPE,EAAM,KAAKpB,GAAaC,EAAKiB,EAAK,GAAG,CAAC,EAC5BJ,EAAO,SACjBM,EAAM,KAAKpB,GAAaC,EAAKa,EAAO,GAAG,CAAC,EAGnCM,EAAM,KAAK,GAAG,CACvB,CAEA,SAASE,GAAUX,EAAMY,EAAKC,EAAWC,EAAa,CACpD,GAAM,CACJ,QAAAN,EACA,OAAAO,CACF,EAAIH,EAAI,IACJT,EAEJ,GAAI,EAAEH,aAAgBjB,EAAW,MAAO,CACtC,IAAMiC,EAAY,CAChB,WAAY,CAAC,EACb,SAAUC,GAAKd,EAASc,EACxB,YAAa,IAAI,GACnB,EACAjB,EAAOe,EAAO,WAAWf,EAAM,GAAM,KAAMgB,CAAS,EAEpD,QAAWE,KAASF,EAAU,WAAY,CACxCE,EAAM,OAASA,EAAM,OAAO,KAC5B,IAAIb,EAAOG,EAAQ,QAAQU,EAAM,MAAM,EAElCb,IACHA,EAAOG,EAAQ,QAAQ,EACvBA,EAAQ,IAAIH,GAAQa,EAAM,OAE9B,CACF,CAEA,GAAIlB,aAAgBjB,EAAW,KAAM,OAAOiB,EAAK,SAASY,EAAKC,EAAWC,CAAW,EAChFX,IAAQA,EAASL,GAAaiB,EAAO,KAAMf,CAAI,GACpD,IAAMS,EAAQH,GAAeN,EAAMG,EAAQS,CAAG,EAC1CH,EAAM,OAAS,IAAGG,EAAI,eAAiBA,EAAI,eAAiB,GAAKH,EAAM,OAAS,GACpF,IAAMU,EAAM,OAAOhB,EAAO,WAAc,WAAaA,EAAO,UAAUH,EAAMY,EAAKC,EAAWC,CAAW,EAAId,aAAgBjB,EAAW,OAASA,EAAW,gBAAgBiB,EAAMY,EAAKC,EAAWC,CAAW,EAAId,EAAK,SAASY,EAAKC,EAAWC,CAAW,EACxP,OAAKL,EACET,aAAgBjB,EAAW,QAAUoC,EAAI,KAAO,KAAOA,EAAI,KAAO,IAAM,GAAGV,KAASU,IAAQ,GAAGV;AAAA,EAAUG,EAAI,SAASO,IAD1GA,CAErB,CAEA,IAAMC,GAAN,KAAc,CACZ,OAAO,gBAAgBb,EAAM,CAC3B,OAAOA,aAAgBxB,EAAW,QAAUwB,aAAgBxB,EAAW,SAAWwB,aAAgBxB,EAAW,OAC/G,CAEA,YAAYsC,EAAQ,CAClBvC,EAAW,gBAAgB,KAAM,MAAO,OAAO,OAAO,IAAI,CAAC,EAE3D,KAAK,OAASuC,CAChB,CAEA,YAAYd,EAAMF,EAAM,CACtB,YAAK,UAAUE,EAAMF,CAAI,EAClB,IAAItB,EAAW,MAAMwB,CAAI,CAClC,CAEA,mBAAmBe,EAAS,CAC1B,IAAMC,EAAQ,IAAIxC,EAAW,MAC7B,OAAAwC,EAAM,MAAM,MAAQD,EAAQ,IAAIE,GAAK,CACnC,GAAIA,aAAazC,EAAW,OAC1B,GAAIyC,EAAE,kBAAkBzC,EAAW,QAAS,OAAOyC,UAC1CA,aAAazC,EAAW,QACjC,OAAO,KAAK,YAAYyC,CAAC,EAG3B,MAAM,IAAI,MAAM,kDAAkD,CACpE,CAAC,EACMD,CACT,CAEA,QAAQhB,EAAM,CACZ,GAAM,CACJ,IAAAkB,CACF,EAAI,KACJ,OAAO,OAAO,KAAKA,CAAG,EAAE,KAAKC,GAAKD,EAAIC,KAAOnB,CAAI,CACnD,CAEA,UAAW,CACT,OAAO,OAAO,KAAK,KAAK,GAAG,CAC7B,CAEA,QAAQF,EAAM,CACZ,OAAO,KAAK,IAAIA,EAClB,CAEA,QAAQgB,EAAQ,CACTA,IAAQA,EAAS,KAAK,QAC3B,IAAMM,EAAQ,OAAO,KAAK,KAAK,GAAG,EAElC,QAASC,EAAI,GAAS,EAAEA,EAAG,CACzB,IAAMvB,EAAO,GAAGgB,IAASO,IACzB,GAAI,CAACD,EAAM,SAAStB,CAAI,EAAG,OAAOA,CACpC,CACF,CAGA,cAAe,CACb,GAAM,CACJ,IAAAoB,EACA,YAAAI,CACF,EAAI,KACJ,OAAO,KAAKJ,CAAG,EAAE,QAAQC,GAAK,CAC5BD,EAAIC,GAAKD,EAAIC,GAAG,QAClB,CAAC,EAEDG,EAAY,QAAQH,GAAK,CACvBA,EAAE,OAASA,EAAE,OAAO,QACtB,CAAC,EAED,OAAO,KAAK,WACd,CAEA,UAAUnB,EAAMF,EAAM,CACpB,GAAIE,GAAQ,MAAQ,CAACa,GAAQ,gBAAgBb,CAAI,EAC/C,MAAM,IAAI,MAAM,uDAAuD,EAGzE,GAAIF,GAAQ,sBAAsB,KAAKA,CAAI,EACzC,MAAM,IAAI,MAAM,gEAAgE,EAGlF,GAAM,CACJ,IAAAoB,CACF,EAAI,KACEK,EAAOvB,GAAQ,OAAO,KAAKkB,CAAG,EAAE,KAAKC,GAAKD,EAAIC,KAAOnB,CAAI,EAE/D,GAAIuB,EACF,GAAKzB,EAEMyB,IAASzB,IAClB,OAAOoB,EAAIK,GACXL,EAAIpB,GAAQE,OAHZ,QAAOuB,MAKJ,CACL,GAAI,CAACzB,EAAM,CACT,GAAI,CAACE,EAAM,OAAO,KAClBF,EAAO,KAAK,QAAQ,CACtB,CAEAoB,EAAIpB,GAAQE,CACd,CAEA,OAAOF,CACT,CAEF,EAEM0B,GAAQ,CAACxB,EAAMR,IAAS,CAC5B,GAAIQ,GAAQ,OAAOA,GAAS,SAAU,CACpC,GAAM,CACJ,IAAAhB,CACF,EAAIgB,EAEAA,aAAgBxB,EAAW,YACzBQ,IAAKQ,EAAKR,GAAO,IACrBgB,EAAK,MAAM,QAAQ,GAAKwB,GAAM,EAAGhC,CAAI,CAAC,GAC7BQ,aAAgBxB,EAAW,MACpCgD,GAAMxB,EAAK,IAAKR,CAAI,EACpBgC,GAAMxB,EAAK,MAAOR,CAAI,GACbQ,aAAgBxB,EAAW,QAChCQ,IAAKQ,EAAKR,GAAO,GAEzB,CAEA,OAAOQ,CACT,EAEMiC,GAAezB,GAAQ,OAAO,KAAKwB,GAAMxB,EAAM,CAAC,CAAC,CAAC,EAExD,SAAS0B,GAAc3C,EAAK4C,EAAU,CACpC,IAAMC,EAAW,CACf,OAAQ,CAAC,EACT,MAAO,CAAC,CACV,EACIC,EACAC,EAAc,GAElB,QAAW9B,KAAQ2B,EACjB,GAAI3B,EAAK,WAAY,CACnB,GAAI6B,IAAS,OAAW,CACtB,IAAME,EAAM,wEACZhD,EAAI,OAAO,KAAK,IAAIR,EAAW,gBAAgByB,EAAM+B,CAAG,CAAC,EACzD,KACF,CAEA,IAAMC,EAAMxD,EAAW,YAAYO,EAAKiB,CAAI,EAExC8B,IACFE,EAAI,YAAc,GAClBF,EAAc,IAGhBD,EAAOG,CACT,MAAWhC,EAAK,UAAY,MACf6B,IAAS,OAAYD,EAAS,OAASA,EAAS,OACxD,KAAK5B,EAAK,OAAO,EACXA,EAAK,OAASzB,EAAW,KAAK,aACvCuD,EAAc,GAEVD,IAAS,QAAaD,EAAS,OAAO,OAAS,GAAK,CAAC7C,EAAI,gBAE3DA,EAAI,cAAgB6C,EAAS,OAAO,KAAK;AAAA,CAAI,EAC7CA,EAAS,OAAS,CAAC,IAOzB,GAFA7C,EAAI,SAAW8C,GAAQ,KAEnB,CAACA,EACH9C,EAAI,QAAU6C,EAAS,OAAO,OAAOA,EAAS,KAAK,EAAE,KAAK;AAAA,CAAI,GAAK,SAC9D,CACL,IAAMK,EAAKL,EAAS,OAAO,KAAK;AAAA,CAAI,EAEpC,GAAIK,EAAI,CACN,IAAMC,EAASL,aAAgBrD,EAAW,YAAcqD,EAAK,MAAM,GAAKA,EAAK,MAAM,GAAKA,EACxFK,EAAO,cAAgBA,EAAO,cAAgB,GAAGD;AAAA,EAAOC,EAAO,gBAAkBD,CACnF,CAEAlD,EAAI,QAAU6C,EAAS,MAAM,KAAK;AAAA,CAAI,GAAK,IAC7C,CACF,CAEA,SAASO,GAAoB,CAC3B,YAAAC,CACF,EAAGC,EAAW,CACZ,GAAM,CAACC,EAAQxB,CAAM,EAAIuB,EAAU,WAEnC,GAAI,CAACC,GAAU,CAACxB,EAAQ,CACtB,IAAMiB,EAAM,mDACZ,MAAM,IAAIxD,EAAW,kBAAkB8D,EAAWN,CAAG,CACvD,CAEA,GAAIK,EAAY,KAAKjD,GAAKA,EAAE,SAAWmD,CAAM,EAAG,CAC9C,IAAMP,EAAM,sFACZ,MAAM,IAAIxD,EAAW,kBAAkB8D,EAAWN,CAAG,CACvD,CAEA,MAAO,CACL,OAAAO,EACA,OAAAxB,CACF,CACF,CAEA,SAASyB,GAAqBxD,EAAKsD,EAAW,CAC5C,GAAI,CAACG,CAAO,EAAIH,EAAU,WAG1B,GAFIA,EAAU,OAAS,aAAYG,EAAU,OAEzC,CAACA,EAAS,CACZ,IAAMT,EAAM,oDACZ,MAAM,IAAIxD,EAAW,kBAAkB8D,EAAWN,CAAG,CACvD,CAEA,GAAI,CAAClD,GAAgB2D,GAAU,CAE7B,IAAMT,EAAM,mCADDhD,EAAI,SAAWA,EAAI,QAAQ,4BACgCyD,IACtEzD,EAAI,SAAS,KAAK,IAAIR,EAAW,YAAY8D,EAAWN,CAAG,CAAC,CAC9D,CAEA,OAAOS,CACT,CAEA,SAASC,GAAgB1D,EAAK2D,EAAYC,EAAS,CACjD,IAAMC,EAAoB,CAAC,EACvBC,EAAgB,GAEpB,QAAWR,KAAaK,EAAY,CAClC,GAAM,CACJ,QAAAI,EACA,KAAAhD,CACF,EAAIuC,EAEJ,OAAQvC,OACD,MACH,GAAI,CACFf,EAAI,YAAY,KAAKoD,GAAoBpD,EAAKsD,CAAS,CAAC,CAC1D,OAASU,EAAP,CACAhE,EAAI,OAAO,KAAKgE,CAAK,CACvB,CAEAF,EAAgB,GAChB,UAEG,WACA,WACH,GAAI9D,EAAI,QAAS,CACf,IAAMgD,EAAM,oEACZhD,EAAI,OAAO,KAAK,IAAIR,EAAW,kBAAkB8D,EAAWN,CAAG,CAAC,CAClE,CAEA,GAAI,CACFhD,EAAI,QAAUwD,GAAqBxD,EAAKsD,CAAS,CACnD,OAASU,EAAP,CACAhE,EAAI,OAAO,KAAKgE,CAAK,CACvB,CAEAF,EAAgB,GAChB,cAGA,GAAI/C,EAAM,CACR,IAAMiC,EAAM,0DAA0DjC,IACtEf,EAAI,SAAS,KAAK,IAAIR,EAAW,YAAY8D,EAAWN,CAAG,CAAC,CAC9D,EAIAe,GAASF,EAAkB,KAAKE,CAAO,CAC7C,CAEA,GAAIH,GAAW,CAACE,IAA4B9D,EAAI,SAAW4D,EAAQ,SAAW5D,EAAI,QAAQ,WAAzD,MAAmE,CAClG,IAAMiE,EAAgB,CAAC,CACrB,OAAAV,EACA,OAAAxB,CACF,KAAO,CACL,OAAAwB,EACA,OAAAxB,CACF,GAEA/B,EAAI,YAAc4D,EAAQ,YAAY,IAAIK,CAAa,EACvDjE,EAAI,QAAU4D,EAAQ,OACxB,CAEA5D,EAAI,cAAgB6D,EAAkB,KAAK;AAAA,CAAI,GAAK,IACtD,CAEA,SAASK,GAAiBtB,EAAU,CAClC,GAAIA,aAAoBnD,EAAW,WAAY,MAAO,GACtD,MAAM,IAAI,MAAM,iDAAiD,CACnE,CAEA,IAAM0E,GAAN,KAAe,CACb,YAAYC,EAAS,CACnB,KAAK,QAAU,IAAItC,GAAQsC,EAAQ,YAAY,EAC/C,KAAK,cAAgB,KACrB,KAAK,QAAU,KACf,KAAK,SAAW,KAChB,KAAK,oBAAsB,KAC3B,KAAK,OAAS,CAAC,EACf,KAAK,QAAUA,EACf,KAAK,OAAS,KACd,KAAK,YAAc,CAAC,EACpB,KAAK,QAAU,KACf,KAAK,SAAW,CAAC,CACnB,CAEA,IAAIC,EAAO,CACT,OAAAH,GAAiB,KAAK,QAAQ,EACvB,KAAK,SAAS,IAAIG,CAAK,CAChC,CAEA,MAAMC,EAAMD,EAAO,CACjBH,GAAiB,KAAK,QAAQ,EAC9B,KAAK,SAAS,MAAMI,EAAMD,CAAK,CACjC,CAEA,OAAOE,EAAK,CACV,OAAAL,GAAiB,KAAK,QAAQ,EACvB,KAAK,SAAS,OAAOK,CAAG,CACjC,CAEA,SAASD,EAAM,CACb,OAAI7E,EAAW,YAAY6E,CAAI,EACzB,KAAK,UAAY,KAAa,IAClC,KAAK,SAAW,KACT,KAGTJ,GAAiB,KAAK,QAAQ,EACvB,KAAK,SAAS,SAASI,CAAI,EACpC,CAEA,aAAc,CACZ,OAAOH,GAAS,SAAS,KAAK,UAAYA,GAAS,SAAS,KAAK,QAAQ,UAAY,CAAC,CACxF,CAEA,IAAII,EAAKC,EAAY,CACnB,OAAO,KAAK,oBAAoB/E,EAAW,WAAa,KAAK,SAAS,IAAI8E,EAAKC,CAAU,EAAI,MAC/F,CAEA,MAAMF,EAAME,EAAY,CACtB,OAAI/E,EAAW,YAAY6E,CAAI,EAAU,CAACE,GAAc,KAAK,oBAAoB/E,EAAW,OAAS,KAAK,SAAS,MAAQ,KAAK,SACzH,KAAK,oBAAoBA,EAAW,WAAa,KAAK,SAAS,MAAM6E,EAAME,CAAU,EAAI,MAClG,CAEA,IAAID,EAAK,CACP,OAAO,KAAK,oBAAoB9E,EAAW,WAAa,KAAK,SAAS,IAAI8E,CAAG,EAAI,EACnF,CAEA,MAAMD,EAAM,CACV,OAAI7E,EAAW,YAAY6E,CAAI,EAAU,KAAK,WAAa,OACpD,KAAK,oBAAoB7E,EAAW,WAAa,KAAK,SAAS,MAAM6E,CAAI,EAAI,EACtF,CAEA,IAAIC,EAAKF,EAAO,CACdH,GAAiB,KAAK,QAAQ,EAC9B,KAAK,SAAS,IAAIK,EAAKF,CAAK,CAC9B,CAEA,MAAMC,EAAMD,EAAO,CACb5E,EAAW,YAAY6E,CAAI,EAAG,KAAK,SAAWD,GAChDH,GAAiB,KAAK,QAAQ,EAC9B,KAAK,SAAS,MAAMI,EAAMD,CAAK,EAEnC,CAEA,UAAUI,EAAIC,EAAY,CACxB,GAAI,CAACD,GAAM,CAACC,GAAc,KAAK,OAAQ,OACnC,OAAOD,GAAO,WAAUA,EAAKA,EAAG,QAAQ,CAAC,GAEzCA,IAAO,OAASA,IAAO,OAASA,IAAO,OACrC,KAAK,QAAS,KAAK,QAAUA,EAAQ,KAAK,QAAQ,QAAUA,EAChE,OAAO,KAAK,QAAQ,QACXA,GAAM,OAAOA,GAAO,WAC7B,KAAK,QAAQ,OAASA,GAGpB,MAAM,QAAQC,CAAU,IAAG,KAAK,QAAQ,WAAaA,GACzD,IAAM7E,EAAM,OAAO,OAAO,CAAC,EAAG,KAAK,YAAY,EAAG,KAAK,OAAO,EAC9D,KAAK,OAAS,IAAIH,GAAO,OAAOG,CAAG,CACrC,CAEA,MAAMoB,EAAM2C,EAAS,CACf,KAAK,QAAQ,eAAc,KAAK,QAAU3C,GAC1C,KAAK,QAAQ,gBAAe,KAAK,KAAO,YAC5C,GAAM,CACJ,WAAA0C,EAAa,CAAC,EACd,SAAAf,EAAW,CAAC,EACZ,oBAAA+B,EACA,MAAAX,EACA,WAAAY,CACF,EAAI3D,EAeJ,GAbI+C,IACGA,EAAM,SAAQA,EAAM,OAAS,MAClC,KAAK,OAAO,KAAKA,CAAK,GAGxBN,GAAgB,KAAMC,EAAYC,CAAO,EACrCe,IAAqB,KAAK,oBAAsB,IACpD,KAAK,MAAQC,EAAa,CAACA,EAAW,MAAOA,EAAW,GAAG,EAAI,KAC/D,KAAK,UAAU,EACf,KAAK,QAAQ,YAAc,CAAC,EAC5BjC,GAAc,KAAMC,CAAQ,EAC5B,KAAK,QAAQ,aAAa,EAEtB,KAAK,QAAQ,aAAc,CAC7B,QAAWoB,KAAS,KAAK,OAAYA,aAAiBxE,EAAW,WAAWwE,EAAM,WAAW,EAE7F,QAAWa,KAAQ,KAAK,SAAcA,aAAgBrF,EAAW,WAAWqF,EAAK,WAAW,CAC9F,CAEA,OAAO,IACT,CAEA,oBAAqB,CACnB,OAAOnC,GAAa,KAAK,QAAQ,EAAE,OAAO9B,GAAKA,EAAE,QAAQlB,GAAO,OAAO,aAAa,IAAM,CAAC,CAC7F,CAEA,aAAa6D,EAAQxB,EAAQ,CAC3B,GAAIwB,EAAO,KAAO,KAAOA,EAAOA,EAAO,OAAS,KAAO,IAAK,MAAM,IAAI,MAAM,kCAAkC,EAE9G,GAAIxB,EAAQ,CACV,IAAMS,EAAO,KAAK,YAAY,KAAKpC,GAAKA,EAAE,SAAWmD,CAAM,EACvDf,EAAMA,EAAK,OAAST,EAAY,KAAK,YAAY,KAAK,CACxD,OAAAwB,EACA,OAAAxB,CACF,CAAC,CACH,MACE,KAAK,YAAc,KAAK,YAAY,OAAO3B,GAAKA,EAAE,SAAWmD,CAAM,CAEvE,CAEA,OAAOuB,EAAKC,EAAU,CACpB,GAAM,CACJ,gBAAAC,EACA,SAAAC,EACA,cAAAC,CACF,EAAI,KAAK,QACHC,EAAOH,IAAoB,OAAOF,GAAQ,UAAY,EAAE,KAAK,oBAAoBrF,EAAW,SAC5F6B,EAAM,CACV,IAAK,KACL,WAAY,KACZ,KAAA6D,EACA,SAAUA,GAAQ,CAAC,CAACF,EACpB,cAAAC,EACA,UAAA7D,EAEF,EACM+D,EAAc,OAAO,KAAK,KAAK,QAAQ,GAAG,EAC5CA,EAAY,OAAS,IAAG9D,EAAI,QAAU,IAAI,IAAI8D,EAAY,IAAIrE,GAAQ,CAAC,KAAK,QAAQ,IAAIA,GAAO,CACjG,MAAO,CAAC,EACR,WAAY,EACZ,MAAO,CACT,CAAC,CAAC,CAAC,GACH,IAAMkC,EAAMxD,EAAW,OAAO,KAAK,SAAUqF,EAAKxD,CAAG,EACrD,GAAI,OAAOyD,GAAa,YAAczD,EAAI,QAAS,OAAW,CAC5D,MAAA+D,EACA,IAAApC,CACF,IAAK3B,EAAI,QAAQ,OAAO,EAAGyD,EAAS9B,EAAKoC,CAAK,EAC9C,OAAOpC,CACT,CAEA,UAAW,CACT,GAAI,KAAK,OAAO,OAAS,EAAG,MAAM,IAAI,MAAM,4CAA4C,EACxF,IAAMqC,EAAa,KAAK,QAAQ,OAEhC,GAAI,CAAC,OAAO,UAAUA,CAAU,GAAKA,GAAc,EAAG,CACpD,IAAMpD,EAAI,KAAK,UAAUoD,CAAU,EACnC,MAAM,IAAI,MAAM,mDAAmDpD,GAAG,CACxE,CAEA,KAAK,UAAU,EACf,IAAMqD,EAAQ,CAAC,EACXzB,EAAgB,GAEpB,GAAI,KAAK,QAAS,CAChB,IAAI0B,EAAK,YAEL,KAAK,OAAO,OAAS,aACnB,KAAK,UAAY,MAAOA,EAAK,YAAqB,KAAK,UAAY,QAAOA,EAAK,cAGrFD,EAAM,KAAKC,CAAE,EACb1B,EAAgB,EAClB,CAEA,IAAM2B,EAAW,KAAK,mBAAmB,EACzC,KAAK,YAAY,QAAQ,CAAC,CACxB,OAAAlC,EACA,OAAAxB,CACF,IAAM,CACA0D,EAAS,KAAK7E,GAAKA,EAAE,QAAQmB,CAAM,IAAM,CAAC,IAC5CwD,EAAM,KAAK,QAAQhC,KAAUxB,GAAQ,EACrC+B,EAAgB,GAEpB,CAAC,GACGA,GAAiB,KAAK,sBAAqByB,EAAM,KAAK,KAAK,EAE3D,KAAK,iBACHzB,GAAiB,CAAC,KAAK,sBAAqByB,EAAM,QAAQ,EAAE,EAChEA,EAAM,QAAQ,KAAK,cAAc,QAAQ,MAAO,GAAG,CAAC,GAGtD,IAAMjE,EAAM,CACV,QAAS,OAAO,OAAO,IAAI,EAC3B,IAAK,KACL,OAAQ,GACR,WAAY,IAAI,OAAOgE,CAAU,EACjC,UAAAjE,EAEF,EACIqE,EAAY,GACZC,EAAiB,KAErB,GAAI,KAAK,SAAU,CACb,KAAK,oBAAoBlG,EAAW,OAClC,KAAK,SAAS,cAAgBqE,GAAiB,KAAK,sBAAsByB,EAAM,KAAK,EAAE,EACvF,KAAK,SAAS,eAAeA,EAAM,KAAK,KAAK,SAAS,cAAc,QAAQ,MAAO,GAAG,CAAC,EAE3FjE,EAAI,iBAAmB,CAAC,CAAC,KAAK,QAC9BqE,EAAiB,KAAK,SAAS,SAGjC,IAAMnE,EAAcmE,EAAiB,KAAO,IAAMD,EAAY,GACxD5C,EAAOzB,GAAU,KAAK,SAAUC,EAAK,IAAMqE,EAAiB,KAAMnE,CAAW,EACnF+D,EAAM,KAAK9F,EAAW,WAAWqD,EAAM,GAAI6C,CAAc,CAAC,CAC5D,MAAW,KAAK,WAAa,QAC3BJ,EAAM,KAAKlE,GAAU,KAAK,SAAUC,CAAG,CAAC,EAG1C,OAAI,KAAK,WACF,CAACoE,GAAaC,IAAmBJ,EAAMA,EAAM,OAAS,KAAO,IAAIA,EAAM,KAAK,EAAE,EACnFA,EAAM,KAAK,KAAK,QAAQ,QAAQ,MAAO,GAAG,CAAC,GAGtCA,EAAM,KAAK;AAAA,CAAI,EAAI;AAAA,CAC5B,CAEF,EAEA/F,EAAW,gBAAgB2E,GAAU,WAAYrE,EAAe,EAEhEP,GAAQ,SAAW4E,GACnB5E,GAAQ,eAAiBI,GACzBJ,GAAQ,cAAgBK,KCpvBxB,IAAAgG,GAAAC,EAAAC,IAAA,cAEA,IAAIC,GAAW,KACXC,GAAa,KACbC,GAAS,KACTC,GAAa,IACbC,GAAW,KACf,KAEA,SAASC,GAAWC,EAAOC,EAAc,GAAMC,EAAK,CAC9CA,IAAQ,QAAa,OAAOD,GAAgB,WAC9CC,EAAMD,EACNA,EAAc,IAGhB,IAAME,EAAU,OAAO,OAAO,CAAC,EAAGR,GAAW,SAAS,SAASA,GAAW,eAAe,SAAUA,GAAW,cAAc,EAE5H,OADe,IAAIC,GAAO,OAAOO,CAAO,EAC1B,WAAWH,EAAOC,EAAaC,CAAG,CAClD,CAEA,IAAME,GAAN,cAAuBT,GAAW,QAAS,CACzC,YAAYQ,EAAS,CACnB,MAAM,OAAO,OAAO,CAAC,EAAGR,GAAW,eAAgBQ,CAAO,CAAC,CAC7D,CAEF,EAEA,SAASE,GAAkBC,EAAKH,EAAS,CACvC,IAAMI,EAAS,CAAC,EACZC,EAEJ,QAAWC,KAAUf,GAAS,MAAMY,CAAG,EAAG,CACxC,IAAMI,EAAM,IAAIN,GAASD,CAAO,EAChCO,EAAI,MAAMD,EAAQD,CAAI,EACtBD,EAAO,KAAKG,CAAG,EACfF,EAAOE,CACT,CAEA,OAAOH,CACT,CAEA,SAASI,GAAcL,EAAKH,EAAS,CACnC,IAAMS,EAAMlB,GAAS,MAAMY,CAAG,EACxBI,EAAM,IAAIN,GAASD,CAAO,EAAE,MAAMS,EAAI,EAAE,EAE9C,GAAIA,EAAI,OAAS,EAAG,CAClB,IAAMC,EAAS,0EACfH,EAAI,OAAO,QAAQ,IAAIb,GAAW,kBAAkBe,EAAI,GAAIC,CAAM,CAAC,CACrE,CAEA,OAAOH,CACT,CAEA,SAASI,GAAMR,EAAKH,EAAS,CAC3B,IAAMO,EAAMC,GAAcL,EAAKH,CAAO,EAEtC,GADAO,EAAI,SAAS,QAAQK,GAAWjB,GAAS,KAAKiB,CAAO,CAAC,EAClDL,EAAI,OAAO,OAAS,EAAG,MAAMA,EAAI,OAAO,GAC5C,OAAOA,EAAI,OAAO,CACpB,CAEA,SAASM,GAAUhB,EAAOG,EAAS,CACjC,IAAMO,EAAM,IAAIN,GAASD,CAAO,EAChC,OAAAO,EAAI,SAAWV,EACR,OAAOU,CAAG,CACnB,CAEA,IAAMO,GAAO,CACX,WAAAlB,GACA,eAAgBJ,GAAW,eAC3B,SAAAS,GACA,MAAAU,GACA,kBAAAT,GACA,SAAUX,GAAS,MACnB,cAAAiB,GACA,cAAehB,GAAW,cAC1B,UAAAqB,EACF,EAEAvB,GAAQ,KAAOwB,KC9Ef,IAAAC,GAAAC,EAAA,CAAAC,GAAAC,KAAA,CAAAA,GAAO,QAAU,KAAkB,OCAnC,IAAAC,GAAAC,EAAA,CAAAC,GAAAC,KAAA,KAAMC,GAAO,KAGPC,GAAS,IAAI,IAAI,CACrB,qBACA,oBACA,kBACA,aACF,CAAC,EAED,SAASC,GAAMC,EAAK,CAClB,GAAI,OAAOA,GAAQ,SACjB,MAAO,CAAE,GAAI,GAAO,OAAQ,MAAU,EAGxC,IAAMC,EAA+B,OAAO,sBAC5C,GAAI,CAEF,cAAO,sBAAwB,GACxB,CAAE,GAAI,GAAM,OAAQJ,GAAK,MAAMG,CAAG,CAAE,CAC7C,OAASE,EAAP,CAEA,GAAIA,GAAOJ,GAAO,IAAII,EAAI,IAAI,EAC5B,MAAO,CAAE,GAAI,GAAO,OAAQ,MAAU,EAExC,MAAMA,CACR,QAAE,CACA,OAAO,sBAAwBD,CACjC,CACF,CAEAL,GAAO,QAAU,CAGf,gBAAkBI,GAAQ,OAAOA,GAAQ,SAAWD,GAAMC,CAAG,EAAE,GAAK,OACpE,eAAiBG,GAASN,GAAK,UAAUM,CAAI,EAC7C,iBAAmBH,GAAQD,GAAMC,CAAG,EAAE,MACxC,ICrCA,IAAAI,GAAAC,EAAA,CAAAC,GAAAC,KAAA,KAAMC,GAAO,KACPC,GAAU,KACVC,GAAQ,KACRC,GAAO,KAEbJ,GAAO,QAAU,CACf,GAAGC,GACH,GAAGC,GACH,GAAGC,GACH,GAAGC,EACL,ICVA,IAAAC,GAAAC,EAAA,CAAAC,GAAAC,KAAA,CAGA,IAAMC,GAAW,KAKjB,SAASC,GAAcC,EAAK,CAC1B,OAAO,SAAUC,EAAM,CACrB,IAAMC,EAAK,IAAI,UAAUF,EAAI,MAAM,EAC/BG,EAAI,GACR,KAAOD,EAAGD,KAAU,GAClBE,GAAK,OAAO,aAAaD,EAAGD,IAAO,EAErC,OAAOE,CACT,CACF,CASA,SAASC,GAAUC,EAAcC,EAAQC,EAAO,CAC9C,GAAIA,IAAU,OACZ,MAAO,GAGT,IAAIC,EACJ,GAAID,aAAiB,YACnBC,EAAW,IAAI,WAAWD,CAAK,MAC1B,CACL,IAAME,EAAc,KAAK,UAAUF,CAAK,EACxCC,EAAW,IAAI,YAAY,EAAE,OAAOC,CAAW,CACjD,CAEA,IAAMC,EAAcF,EAAS,WACvBG,EAAUN,EAAa,QAAQ,WAAWK,CAAW,EACtC,IAAI,WAAWJ,EAAO,MAAM,EACpC,IAAIE,EAAUG,CAAO,EAElC,IAAMC,EAAaP,EAAa,QAAQ,eAAeM,EAASD,CAAW,EAE3E,GAAIE,IAAe,EACjB,KAAM,6BAER,OAAOA,CACT,CASA,SAASC,GAAUR,EAAcC,EAAQL,EAAM,CAC7C,IAAMU,EAAUN,EAAa,QAAQ,cAAcJ,CAAI,EACvD,OAAOa,GAAaR,EAAQK,CAAO,CACrC,CAQA,SAASG,GAAaR,EAAQL,EAAM,CAClC,IAAMc,EAAM,IAAI,WAAWT,EAAO,MAAM,EAEpCU,EAAMf,EAEV,KAAOc,EAAIC,KAAS,GAClBA,IAGF,IAAMC,EAAW,IAAI,WAAWX,EAAO,OAAQL,EAAMe,EAAMf,CAAI,EACzDiB,EAAa,IAAI,YAAY,EAAE,OAAOD,CAAQ,EAEpD,OAAO,KAAK,MAAMC,CAAU,CAC9B,CAEA,IAAMC,GAAerB,GAWrB,SAASsB,GACPf,EACAC,EACAe,EACAC,EACAC,EACA,CACA,IAAMC,EAAcH,EAASE,GACvBE,EAAON,GAAaK,IAAgBF,EAAeE,GAEzD,GAAIC,IAAS,OACX,KAAM,CACJ,QAAS,sCACPF,EACA,KACAF,EAASE,EACb,EAGF,IAAMG,EAAW,MAAM,UAAU,MAAM,MAAM,SAAS,EAChDC,EAAO,CAAC,EAEd,QAASC,EAAI,EAAGA,EAAIF,EAAS,OAAQE,IAAK,CACxC,IAAMC,EAAQhB,GAAUR,EAAcC,EAAQoB,EAASE,EAAE,EACzDD,EAAK,KAAKE,CAAK,CACjB,CAEA,IAAMC,EAASL,EAAK,GAAGE,CAAI,EAE3B,OAAOvB,GAAUC,EAAcC,EAAQwB,CAAM,CAC/C,CASA,SAASC,GAAcC,EAAK1B,EAAQgB,EAAgB,CAClD,IAAMW,EAAclC,GAAcO,CAAM,EAExC,MAAO,CACL,IAAK,CACH,OAAAA,EACA,UAAW,SAAUL,EAAM,CACzB,MAAMgC,EAAYhC,CAAI,CACxB,EACA,YAAa,SAAUA,EAAM,CAC3B,QAAQ,IAAIgC,EAAYhC,CAAI,CAAC,CAC/B,EACA,aAAc,SAAUsB,EAAWW,EAAM,CACvC,OAAOd,GACLY,EAAI,SACJ1B,EACA0B,EAAI,SACJV,EACAC,CACF,CACF,EACA,aAAc,SAAUA,EAAWW,EAAMC,EAAM,CAC7C,OAAOf,GACLY,EAAI,SACJ1B,EACA0B,EAAI,SACJV,EACAC,EACAY,CACF,CACF,EACA,aAAc,SAAUZ,EAAWW,EAAMC,EAAMC,EAAM,CACnD,OAAOhB,GACLY,EAAI,SACJ1B,EACA0B,EAAI,SACJV,EACAC,EACAY,EACAC,CACF,CACF,EACA,aAAc,SAAUb,EAAWW,EAAMC,EAAMC,EAAMC,EAAM,CACzD,OAAOjB,GACLY,EAAI,SACJ1B,EACA0B,EAAI,SACJV,EACAC,EACAY,EACAC,EACAC,CACF,CACF,EACA,aAAc,SAAUd,EAAWW,EAAMC,EAAMC,EAAMC,EAAMC,EAAM,CAC/D,OAAOlB,GACLY,EAAI,SACJ1B,EACA0B,EAAI,SACJV,EACAC,EACAY,EACAC,EACAC,EACAC,CACF,CACF,CACF,CACF,CACF,CASA,SAASC,GAAeP,EAAKQ,EAAMlC,EAAQ,CACzC0B,EAAI,SAAWQ,EAAK,SAAWA,EAAK,SAAWA,EAI/C,IAAMC,EAAmBT,EAAI,SAAS,QAAQ,qBAC9C,GAAIS,IAAqB,OAAW,CAClC,IAAMC,EAAa,OAAOD,GAAqB,SAC3CA,EACAA,EAAiB,MACrB,GAAIC,IAAe,EACjB,KAAM,2BAA2BA,GAErC,MACE,QAAQ,MAAM,gCAAgC,EAGhD,IAAMC,EAAwBX,EAAI,SAAS,QAAQ,2BAC/CY,EACAD,IAA0B,OAC5BC,EAAkB,OAAOD,GAA0B,SAC/CA,EACAA,EAAsB,MAE1B,QAAQ,MAAM,sCAAsC,EAGtD,IAAMtB,EAAWR,GACfmB,EAAI,SACJ1B,EACA0B,EAAI,SAAS,QAAQ,SAAS,CAChC,EAGAA,EAAI,SAAW,CAAC,EAEhB,QAAWa,KAAO,OAAO,KAAKxB,CAAQ,EACpCW,EAAI,SAASX,EAASwB,IAAQA,EAGhC,MAAO,CAAE,OAAQL,EAAM,aAAcI,CAAgB,CACvD,CAeA,eAAeE,GAAYC,EAAYzC,EAAQgB,EAAgB,CAC7D,IAAMU,EAAM,CAAC,EAEPQ,EAAO,MAAM,YAAY,YAC7BO,EACAhB,GAAcC,EAAK1B,EAAQgB,CAAc,CAC3C,EAEA,OAAOiB,GAAeP,EAAKQ,EAAMlC,CAAM,CACzC,CAaA,SAAS0C,GAAgBD,EAAYzC,EAAQgB,EAAgB,CAC3D,IAAMU,EAAM,CAAC,GAGXe,aAAsB,aACtBA,EAAW,kBAAkB,eAE7BA,EAAa,IAAI,YAAY,OAAOA,CAAU,GAGhD,IAAMP,EAAO,IAAI,YAAY,SAC3BO,EACAhB,GAAcC,EAAK1B,EAAQgB,CAAc,CAC3C,EAEA,OAAOiB,GAAeP,EAAKQ,EAAMlC,CAAM,CACzC,CAOA,IAAM2C,GAAN,KAAmB,CAMjB,YAAYC,EAAQ5C,EAAQ6C,EAAc,CACxC,KAAK,aAAeA,EACpB,KAAK,IAAM7C,EAKX,KAAK,aAAe4C,EAAO,SAAWA,EAAO,SAAWA,EAExD,KAAK,SAAW9C,GAAU,KAAK,aAAc,KAAK,IAAK,CAAC,CAAC,EACzD,KAAK,YAAc,KAAK,aAAa,QAAQ,iBAAiB,EAC9D,KAAK,YAAc,KAAK,YACxB,KAAK,YAAcS,GACjB,KAAK,aACL,KAAK,IACL,KAAK,aAAa,QAAQ,YAAY,CACxC,CACF,CAaA,SAASuC,EAAOC,EAAa,EAAG,CAE9B,GAAI,OAAOA,GAAe,SAEnB,GAAI,OAAOA,GAAe,SAC/B,GAAI,OAAO,UAAU,eAAe,KAAK,KAAK,YAAaA,CAAU,EACnEA,EAAa,KAAK,YAAYA,OAE9B,MAAM,cAAcA,sCAGtB,MAAM,uEAIR,GAAI,KAAK,cAAgB,EAAG,CAE1B,IAAIC,EAAW,KACXC,EAAW,EACXC,EAAY,EAChB,GAAIJ,EAAO,CACT,GAAIA,aAAiB,YACnBE,EAAW,IAAI,WAAWF,CAAK,MAC1B,CACL,IAAMK,EAAc,KAAK,UAAUL,CAAK,EACxCE,EAAW,IAAI,YAAY,EAAE,OAAOG,CAAW,CACjD,CAEAD,EAAY,KAAK,YACjBD,EAAWD,EAAS,WACpB,IAAMI,EAAQF,EAAYD,EAAW,KAAK,IAAI,OAAO,WACrD,GAAIG,EAAQ,EAAG,CACb,IAAMC,EAAQC,GAAQF,CAAK,EAC3B,KAAK,IAAI,KAAKC,CAAK,CACrB,CACY,IAAI,WAAW,KAAK,IAAI,MAAM,EACtC,IAAIL,EAAU,KAAK,WAAW,CACpC,CAGA,IAAMO,EAAU,KAAK,YAAcN,EAE7BO,EAAM,KAAK,aAAa,QAAQ,SACpC,EACAT,EACA,KAAK,SACLG,EACAD,EACAM,EACA,CACF,EACA,OAAO/C,GAAa,KAAK,IAAKgD,CAAG,CACnC,CAGA,KAAK,aAAa,QAAQ,iBAAiB,KAAK,WAAW,EAG3D,IAAMN,EAAYpD,GAAU,KAAK,aAAc,KAAK,IAAKgD,CAAK,EAGxDW,EAAU,KAAK,aAAa,QAAQ,iBAAiB,EAC3D,KAAK,aAAa,QAAQ,uBAAuBA,EAASP,CAAS,EACnE,KAAK,aAAa,QAAQ,sBAAsBO,EAAS,KAAK,QAAQ,EACtE,KAAK,aAAa,QAAQ,4BAA4BA,EAASV,CAAU,EAGzE,KAAK,aAAa,QAAQ,KAAKU,CAAO,EAGtC,IAAMC,EAAa,KAAK,aAAa,QAAQ,wBAC3CD,CACF,EACA,OAAOlD,GAAU,KAAK,aAAc,KAAK,IAAKmD,CAAU,CAC1D,CAQA,SAASZ,EAAO,CACd,IAAMa,EAAK,KAAK,SAASb,CAAK,EAC9B,OAAOa,GAAMA,EAAG,SAAW,GAAKA,EAAG,KAAO,EAC5C,CAMA,QAAQC,EAAM,CACZ,KAAK,aAAa,QAAQ,iBAAiB,KAAK,WAAW,EAC3D,KAAK,SAAW9D,GAAU,KAAK,aAAc,KAAK,IAAK8D,CAAI,EAC3D,KAAK,YAAc,KAAK,aAAa,QAAQ,iBAAiB,CAChE,CACF,EAEA,SAASN,GAAQO,EAAO,CAEtB,OAAO,KAAK,KAAKA,EAAQ,KAAQ,CACnC,CAEAtE,GAAO,QAAU,CAcf,MAAM,WAAWuE,EAAUC,EAAmB,CAAC,EAAG/C,EAAiB,CAAC,EAAG,CAEjE,OAAO+C,GAAqB,WAC9BA,EAAmB,CAAE,QAASA,CAAiB,GAEjDA,EAAiB,QAAUA,EAAiB,SAAW,EAEvD,IAAM/D,EAAS,IAAI,YAAY,OAAO+D,CAAgB,EAChD,CAAE,OAAAnB,EAAQ,aAAAC,CAAa,EAAI,MAAML,GACrCsB,EACA9D,EACAgB,CACF,EACA,OAAO,IAAI2B,GAAaC,EAAQ5C,EAAQ6C,CAAY,CACtD,EAmBA,eAAeiB,EAAUC,EAAmB,CAAC,EAAG/C,EAAiB,CAAC,EAAG,CAE/D,OAAO+C,GAAqB,WAC9BA,EAAmB,CAAE,QAASA,CAAiB,GAEjDA,EAAiB,QAAUA,EAAiB,SAAW,EAEvD,IAAM/D,EAAS,IAAI,YAAY,OAAO+D,CAAgB,EAChD,CAAE,OAAAnB,EAAQ,aAAAC,CAAa,EAAIH,GAC/BoB,EACA9D,EACAgB,CACF,EACA,OAAO,IAAI2B,GAAaC,EAAQ5C,EAAQ6C,CAAY,CACtD,CACF",
  "names": ["require_json", "__commonJSMin", "exports", "module", "isValidJSON", "str", "err", "require_sprintf", "__commonJSMin", "exports", "re", "sprintf", "key", "sprintf_format", "sprintf_parse", "vsprintf", "fmt", "argv", "parse_tree", "cursor", "tree_length", "arg", "output", "i", "k", "ph", "pad", "pad_character", "pad_length", "is_positive", "sign", "sprintf_cache", "_fmt", "match", "arg_names", "field_list", "replacement_field", "field_match", "require_strings", "__commonJSMin", "exports", "module", "vsprintf", "sprintf", "s", "values", "require_regex", "__commonJSMin", "exports", "module", "regexSplit", "pattern", "s", "require_PlainValue_ec8e588e", "__commonJSMin", "exports", "Char", "Type", "defaultTagPrefix", "defaultTags", "findLineStarts", "src", "ls", "offset", "getSrcInfo", "cst", "lineStarts", "getLinePos", "start", "line", "getLine", "end", "getPrettyContext", "maxWidth", "col", "halfWidth", "errLen", "errEnd", "err", "Range", "orig", "cr", "nextOffset", "Node", "str", "next", "sep", "ch0", "prev", "ch1", "ch2", "ch3", "ch", "isVerbatim", "notOk", "indent", "lineStart", "inEnd", "wsEnd", "endAsBlank", "indentDiff", "indicatorAsIndent", "inCount", "error", "fold", "type", "props", "context", "idx", "key", "skipKey", "prop", "i", "anchor", "comments", "comment", "tag", "_", "handle", "suffix", "commentRange", "range", "value", "YAMLError", "name", "source", "message", "ctx", "YAMLReferenceError", "YAMLSemanticError", "YAMLSyntaxError", "YAMLWarning", "_defineProperty", "obj", "PlainValue", "inFlow", "wsStart", "msg", "valueEnd", "require_parse_cst", "__commonJSMin", "exports", "PlainValue", "BlankLine", "context", "start", "CollectionItem", "type", "props", "parseNode", "src", "atLineStart", "lineStart", "indent", "offset", "ch", "inlineComment", "comments", "blankLine", "end", "wsEnd", "items", "c", "cr", "node", "range", "value", "str", "Comment", "grabCollectionEndComments", "cnode", "Collection", "len", "ci", "i", "n", "ca", "prevEnd", "firstItem", "itemRange", "ec", "prevIncludesTrailingLines", "comment", "next", "msg", "ls", "prev", "item", "Directive", "raw", "Document", "hasDirectives", "directive", "iEnd", "contents", "directives", "Alias", "Chomp", "BlockValue", "lastNewLine", "keepStart", "bi", "folded", "atStart", "sep", "prevMoreIndented", "j", "lineEnd", "line", "explicit", "valueEnd", "minBlockIndent", "lineIndent", "FlowCollection", "idx", "char", "nodes", "prefix", "QuoteDouble", "errors", "fold", "error", "wsStart", "length", "cc", "code", "QuoteSingle", "createNewNode", "ParseContext", "inFlow", "orig", "inCollection", "parent", "overlay", "valueStart", "collection", "lineHasProps", "inEnd", "indentDiff", "noIndicatorAsIndent", "parse", "match", "documents", "doc", "crOffset", "require_resolveSeq_d03cb037", "__commonJSMin", "exports", "PlainValue", "addCommentBefore", "str", "indent", "comment", "addComment", "Node", "toJSON", "value", "arg", "ctx", "v", "i", "anchor", "res", "Scalar", "collectionFromPath", "schema", "path", "k", "a", "isEmptyPath", "Collection", "key", "rest", "node", "keepScalar", "n", "blockItem", "flowChars", "isMap", "itemIndent", "onComment", "onChompKeep", "indentStep", "stringify", "inFlow", "allNullValues", "chompKeep", "hasItemWithNewLine", "nodes", "item", "line", "start", "end", "strings", "sum", "s", "asItemIndex", "idx", "YAMLSeq", "it", "_", "seq", "stringifyKey", "jsKey", "Pair", "cb", "msg", "map", "stringKey", "pair", "indentSize", "indentSeq", "simpleKeys", "keyComment", "explicitKey", "doc", "vcb", "valueComment", "valueStr", "ws", "getAliasCount", "anchors", "Alias", "count", "c", "kc", "vc", "range", "source", "implicitKey", "inStringifyKey", "t", "maxAliasCount", "findPair", "items", "YAMLMap", "overwrite", "prev", "sortEntries", "Type", "MERGE_KEY", "Merge", "srcMap", "binaryOptions", "boolOptions", "intOptions", "nullOptions", "strOptions", "resolveScalar", "tags", "scalarFallback", "format", "test", "resolve", "match", "FOLD_FLOW", "FOLD_BLOCK", "FOLD_QUOTED", "consumeMoreIndentedLines", "text", "ch", "foldFlowLines", "mode", "indentAtStart", "lineWidth", "minContentWidth", "onFold", "onOverflow", "endStep", "folds", "escapedFolds", "split", "overflow", "escStart", "escEnd", "next", "j", "fold", "getFoldOptions", "containsDocumentMarker", "lineLengthOverLimit", "indentLength", "limit", "strLen", "doubleQuotedString", "jsonEncoding", "minMultiLineLength", "json", "code", "singleQuotedString", "blockString", "type", "literal", "header", "wsStart", "wsEnd", "m", "body", "plainString", "actualString", "stringifyString", "defaultType", "_stringify", "_type", "stringifyNumber", "minFractionDigits", "tag", "d", "checkFlowCollectionEnd", "errors", "cst", "char", "name", "lastItem", "err", "checkFlowCommentSpace", "getLongKeyError", "sk", "resolveComments", "collection", "comments", "afterKey", "before", "resolveString", "error", "resolveTagHandle", "handle", "suffix", "prefix", "p", "dtp", "vocab", "resolveTagName", "nonSpecific", "verbatim", "resolveByTagName", "tagName", "matchWithTest", "getFallbackTagName", "resolveTag", "fallback", "refError", "isCollectionItem", "resolveNodeProps", "hasAnchor", "hasTag", "props", "valueRange", "resolveNodeValue", "src", "resolveNode", "ca", "resolveMap", "resolveFlowMapItems", "resolveBlockMapItems", "hasCollectionKey", "iKey", "sources", "jKey", "warn", "valueHasPairComment", "lineStart", "resolvePairComment", "found", "cc", "keyStart", "valueNode", "pos", "origPos", "nextItem", "offset", "resolveSeq", "resolveFlowSeqItems", "resolveBlockSeqItems", "prevItem", "keyEnd", "require_warnings_1000a372", "__commonJSMin", "exports", "PlainValue", "resolveSeq", "binary", "value", "doc", "node", "src", "str", "buffer", "msg", "comment", "type", "ctx", "onComment", "onChompKeep", "s", "i", "lineWidth", "n", "lines", "o", "parsePairs", "cst", "seq", "item", "pair", "createPairs", "schema", "iterable", "pairs", "it", "key", "keys", "YAMLOMap", "_", "map", "parseOMap", "seenKeys", "createOMap", "omap", "YAMLSet", "keepPair", "prev", "parseSet", "createSet", "set", "parseSexagesimal", "sign", "parts", "p", "stringifySexagesimal", "intTime", "floatTime", "timestamp", "year", "month", "day", "hour", "minute", "second", "millisec", "tz", "date", "d", "shouldWarn", "deprecation", "env", "warn", "warning", "emit", "warnFileDeprecation", "filename", "path", "warned", "warnOptionDeprecation", "name", "alternative", "require_Schema_88e323a7", "__commonJSMin", "exports", "PlainValue", "resolveSeq", "warnings", "createMap", "schema", "obj", "ctx", "map", "key", "value", "createSeq", "seq", "it", "v", "string", "item", "onComment", "onChompKeep", "failsafe", "intIdentify$2", "intResolve$1", "src", "part", "radix", "intStringify$1", "node", "prefix", "nullObj", "boolObj", "str", "octObj", "oct", "intObj", "hexObj", "hex", "nanObj", "nan", "expObj", "floatObj", "frac1", "frac2", "frac", "core", "intIdentify$1", "stringifyJSON", "json", "boolStringify", "intIdentify", "intResolve", "sign", "n", "intStringify", "yaml11", "bin", "abs", "f", "schemas", "tags", "findTagObject", "tagName", "match", "t", "tagObj", "createNode", "defaultPrefix", "onTagObj", "prevObjects", "wrapScalars", "prev", "alias", "getSchemaTags", "knownTags", "customTags", "schemaId", "keys", "tag", "sortMapEntriesByKey", "a", "b", "Schema", "merge", "sortMapEntries", "deprecatedCustomTags", "baseCtx", "createCtx", "k", "require_Document_9b4560a1", "__commonJSMin", "exports", "PlainValue", "resolveSeq", "Schema", "defaultOptions", "scalarOptions", "opt", "documentOptions", "stringifyTag", "doc", "tag", "priv", "vocab", "p", "dtp", "suffix", "ch", "getTagObject", "tags", "item", "match", "t", "tagObj", "obj", "name", "stringifyProps", "node", "anchors", "props", "anchor", "stringify", "ctx", "onComment", "onChompKeep", "schema", "createCtx", "o", "alias", "str", "Anchors", "prefix", "sources", "merge", "s", "map", "a", "names", "i", "_cstAliases", "prev", "visit", "listTagNames", "parseContents", "contents", "comments", "body", "spaceBefore", "msg", "res", "cb", "cbNode", "resolveTagDirective", "tagPrefixes", "directive", "handle", "resolveYamlDirective", "version", "parseDirectives", "directives", "prevDoc", "directiveComments", "hasDirectives", "comment", "error", "copyTagPrefix", "assertCollection", "Document", "options", "value", "path", "key", "keepScalar", "id", "customTags", "directivesEndMarker", "valueRange", "warn", "arg", "onAnchor", "keepBlobsInJSON", "mapAsMap", "maxAliasCount", "keep", "anchorNames", "count", "indentSize", "lines", "vd", "tagNames", "chompKeep", "contentComment", "require_dist", "__commonJSMin", "exports", "parseCst", "Document$1", "Schema", "PlainValue", "warnings", "createNode", "value", "wrapScalars", "tag", "options", "Document", "parseAllDocuments", "src", "stream", "prev", "cstDoc", "doc", "parseDocument", "cst", "errMsg", "parse", "warning", "stringify", "YAML", "require_yaml", "__commonJSMin", "exports", "module", "require_yaml", "__commonJSMin", "exports", "module", "yaml", "errors", "parse", "str", "YAML_SILENCE_WARNINGS_CACHED", "err", "data", "require_builtins", "__commonJSMin", "exports", "module", "json", "strings", "regex", "yaml", "require_opa", "__commonJSMin", "exports", "module", "builtIns", "stringDecoder", "mem", "addr", "i8", "s", "_loadJSON", "wasmInstance", "memory", "value", "valueBuf", "valueAsText", "valueBufLen", "rawAddr", "parsedAddr", "_dumpJSON", "_dumpJSONRaw", "buf", "idx", "utf8View", "jsonAsText", "builtinFuncs", "_builtinCall", "builtins", "customBuiltins", "builtinId", "builtInName", "impl", "argArray", "args", "i", "jsArg", "result", "_importObject", "env", "addr2string", "_ctx", "arg1", "arg2", "arg3", "arg4", "_preparePolicy", "wasm", "abiVersionGlobal", "abiVersion", "abiMinorVersionGlobal", "abiMinorVersion", "key", "_loadPolicy", "policyWasm", "_loadPolicySync", "LoadedPolicy", "policy", "minorVersion", "input", "entrypoint", "inputBuf", "inputLen", "inputAddr", "inputAsText", "delta", "pages", "roundup", "heapPtr", "ret", "ctxAddr", "resultAddr", "rs", "data", "bytes", "regoWasm", "memoryDescriptor"]
}
